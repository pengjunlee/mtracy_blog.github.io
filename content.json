{"meta":{"title":"李朋军的个人博客","subtitle":"学习是一种生活方式","description":"我还是从前那个少年，没有一丝丝改变。","author":"pengjunlee","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2023-04-30T10:21:41.374Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2023-04-30T10:21:41.375Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2023-04-30T10:21:41.375Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2023-04-30T10:21:41.376Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2023-04-30T10:21:41.377Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2023-04-30T10:21:41.376Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2023-04-30T10:21:41.377Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2023-04-30T10:21:41.377Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2023-04-30T10:21:41.378Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"Are U Happy","date":"2020-05-31T03:56:03.000Z","updated":"2023-04-30T10:21:41.378Z","comments":true,"path":"tags/Are U Happy.html","permalink":"/tags/Are U Happy.html","excerpt":"","text":"","keywords":"Happy"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2023-04-30T10:21:41.378Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2023-04-30T10:21:41.379Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2023-04-30T10:21:41.379Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"字符编码","slug":"Java核心基础之--字符编码","date":"2020-06-06T09:24:10.000Z","updated":"2023-04-30T10:21:41.351Z","comments":true,"path":"2020/06/06/Java核心基础之--字符编码/","link":"","permalink":"/2020/06/06/Java核心基础之--字符编码/","excerpt":"","text":"参考书籍：《深入分析Java Web技术内幕（修订版）》—-许令波著 编码问题一直在困扰着程序开发人员，这在Java中尤其突出，因为Java是跨平台语言，字符在不同平台之间进行传输时经常需要进行编码切换。 为什么要编码？众所周知，计算机其实是很笨的，它只识别数字0和1，所以，无论什么内容在计算机内最终都必须以01串的形式进行存储，字符也不例外。在计算机中存储信息的最小单元是1个字节，即8个bit，一个字节所能表示的字符个数最多为256个（0~255，二进制11111111=十进制255）。但是，人类要表示的符号太多了，用一个字节来表示显然是远远不够的，必须用更多的字节来表示，比如：用两个字节最多可以表示65535个字符，用4个字节表示的字符数可多达4294967295个。一个字符究竟应该用多少个字节来表示才合适呢？这就是编码所实现的功能，不同的编码使用不同的字节数或数值来表示字符。 常用编码格式ASCII码由于计算机是美国人发明的，因此，最早只有128个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII（American Standard Code for Information Interchange，美国信息交换标准码），采用一个字节的低7位来表示，0~31是控制字符，如换行、回车、删除等，32~127是打印字符，包括那些可以通过键盘输入并且能够显示出来的字符，比如大写字母、小写字母、数字等。 ISO-8859-1128个字符显然是不够用的，于是ISO组织在ASCII码基础上又制定了一系列标准来扩展ASCII编码，它们是ISO-8859-1至ISO-8859-15，其中ISO-8859-1涵盖了大多数西欧语言字符，所以应用得最广泛。ISO-8859-1仍然是单字节编码，它总共能表示256个字符。 GB2312如果要处理中文的话，一个字节显然还是不够用，所以，中国制定了GB2312编码，用来把中文编进去。GB2312是双字节编码，总的编码范围是A1~F7，其中A1~A9是符号区，总共包含682个符号；B0~F7是汉字区，包含6763个汉字。 GBKGBK全称是《汉字内码扩展规范》，是国家技术监督局为Windows 95所制定的新的汉字内码规范，它的出现是为了扩展GB2312，并加入更多的汉字。它的编码范围是8140~FEFE（去掉XX7F），总共有23940个码位，它能表示21003个汉字，它的编码是和GB2312兼容的，也就是说用GB2312编码的汉字可以用GBK来解码，并且不会有乱码。 UTF-16说到UTF-16必须提到Unicode（Universal Code 统一码），全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，如此，假如各国都按照各国各自的标准来设计编码，在某些多语言混用的场景下，就会不可避免地出现编码冲突。为了解决这一问题，ISO提出了Unicode标准，它试图将世界上所有语言都统一到一套编码里。而实际上Unicode仅仅只是一个规范，它使用0~65535之间的数字来表示所有字符，其中0~127这128个数字表示的字符与ASCII完全一样。至于要把0~65535这些数字以怎样的形式转换为01串保存到计算机中，Unicode并未声明其具体的实现方式，于是就出现了UTF（Unicode Transformation Format），包括：UTF-16和UTF-8。 UTF-16具体定义了Unicode字符在计算机中的存取方法，它用两个字节来表示Unicode的转化格式，采用定长的表示方法，即不论什么字符都用两个字节表示，两个字节就是16个bit，所以叫UTF-16。 UTF-8UTF-16统一采用两个字节来表示一个字符，虽然在表示上非常简单、方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要用两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的情况下，这样会增大网络传输的流量，而且也没有必要。 UTF-8采用一种变长技术，每个编码区域有不同的字码长度。不同的字符可以由1~6个字节组成。 UTF-8有以下编码规则： 如果是1个字节，最高位（第8位）为0，则表示这是1个ASCII字符（00~7F）。可见，所有ASCII编码已经是UTF-8了。 如果是1个字节，以11开头，则连续的1的个数暗示这个字符的字节数，例如;110xxxxx代表它是双字节UTF-8字符的首字节。 如果是1个字节，以10开始，表示它不是首字节，则需要向前查找才能得到当前字符的首字节。 在I/O操作中存在的编码InputStreamReader类可以将I/O操作中读取到的字节流转换为字符流，其部分源代码如下: package java.io; import java.nio.charset.Charset; import java.nio.charset.CharsetDecoder; import sun.nio.cs.StreamDecoder; public class InputStreamReader extends Reader { private final StreamDecoder sd; /** * Creates an InputStreamReader that uses the default charset. * * @param in An InputStream */ public InputStreamReader(InputStream in) { super(in); try { sd = StreamDecoder.forInputStreamReader(in, this, (String)null); // ## check lock object } catch (UnsupportedEncodingException e) { // The default encoding should always be available throw new Error(e); } } /** * Creates an InputStreamReader that uses the named charset. * * @param in * An InputStream * * @param charsetName * The name of a supported * {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;} * * @exception UnsupportedEncodingException * If the named charset is not supported */ public InputStreamReader(InputStream in, String charsetName) throws UnsupportedEncodingException { super(in); if (charsetName == null) throw new NullPointerException(&quot;charsetName&quot;); sd = StreamDecoder.forInputStreamReader(in, this, charsetName); } /** * Creates an InputStreamReader that uses the given charset. &lt;/p&gt; * * @param in An InputStream * @param cs A charset * * @since 1.4 * @spec JSR-51 */ public InputStreamReader(InputStream in, Charset cs) { super(in); if (cs == null) throw new NullPointerException(&quot;charset&quot;); sd = StreamDecoder.forInputStreamReader(in, this, cs); } /** * Creates an InputStreamReader that uses the given charset decoder. &lt;/p&gt; * * @param in An InputStream * @param dec A charset decoder * * @since 1.4 * @spec JSR-51 */ public InputStreamReader(InputStream in, CharsetDecoder dec) { super(in); if (dec == null) throw new NullPointerException(&quot;charset decoder&quot;); sd = StreamDecoder.forInputStreamReader(in, this, dec); } } InputStreamReader内部包含一个StreamDecoder实例引用，对具体字节到字符的解码实现，其实是由StreamDecoder来完成的，在StreamDecoder解码过程中必须由用户指定Charset编码格式，若用户未指定Charset，则将使用本地环境中的默认字符集，如在中文环境中将使用GBK编码。 写的情况也类似，OutputStreamWriter委托StreamEncoder将字符编码成字节。 package java.io; import java.nio.charset.Charset; import java.nio.charset.CharsetEncoder; import sun.nio.cs.StreamEncoder; public class OutputStreamWriter extends Writer { private final StreamEncoder se; /** * Creates an OutputStreamWriter that uses the named charset. * * @param out * An OutputStream * * @param charsetName * The name of a supported * {@link java.nio.charset.Charset &lt;/code&gt;charset&lt;code&gt;} * * @exception UnsupportedEncodingException * If the named encoding is not supported */ public OutputStreamWriter(OutputStream out, String charsetName) throws UnsupportedEncodingException { super(out); if (charsetName == null) throw new NullPointerException(&quot;charsetName&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, charsetName); } /** * Creates an OutputStreamWriter that uses the default character encoding. * * @param out An OutputStream */ public OutputStreamWriter(OutputStream out) { super(out); try { se = StreamEncoder.forOutputStreamWriter(out, this, (String)null); } catch (UnsupportedEncodingException e) { throw new Error(e); } } /** * Creates an OutputStreamWriter that uses the given charset. &lt;/p&gt; * * @param out * An OutputStream * * @param cs * A charset * * @since 1.4 * @spec JSR-51 */ public OutputStreamWriter(OutputStream out, Charset cs) { super(out); if (cs == null) throw new NullPointerException(&quot;charset&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, cs); } /** * Creates an OutputStreamWriter that uses the given charset encoder. &lt;/p&gt; * * @param out * An OutputStream * * @param enc * A charset encoder * * @since 1.4 * @spec JSR-51 */ public OutputStreamWriter(OutputStream out, CharsetEncoder enc) { super(out); if (enc == null) throw new NullPointerException(&quot;charset encoder&quot;); se = StreamEncoder.forOutputStreamWriter(out, this, enc); } } 以下是使用InputStreamReader和OutputStreamWriter进行字节流到字符流的一个简单示例。 public static void main(String[] args) throws IOException { String file = &quot;d:/stream.txt&quot;; String charset = &quot;UTF-8&quot;; String string = &quot;这是要保存的中文字符&quot;; FileOutputStream fos = new FileOutputStream(file); OutputStreamWriter osw = new OutputStreamWriter(fos, charset); try { osw.write(string); } finally { osw.close(); } FileInputStream fis = new FileInputStream(file); InputStreamReader isr = new InputStreamReader(fis, charset); StringBuffer sb = new StringBuffer(); char[] buf = new char[64]; int count = 0; try { while ((count = isr.read(buf)) != -1) { sb.append(buf, 0, count); } } finally { isr.close(); } System.out.println(sb.toString()); } 在内存操作中的编码String类提供了转换到字节的方法，也支持将字节转换为字符串的构造函数。 public static void main(String[] args) throws UnsupportedEncodingException { String s=&quot;这是一段中文字符串&quot;; byte[] bytes=s.getBytes(&quot;UTF-8&quot;); String string=new String(bytes,&quot;UTF-8&quot;); } Charset类提供encode()与decode()，分别对应char[]到byte[]的编码和byte[]到char[]的解码。 public static void main(String[] args) { Charset cs = Charset.forName(&quot;UTF-8&quot;); ByteBuffer byteBuffer = cs.encode(&quot;这是要编码的字符串&quot;); CharBuffer charBuffer = cs.decode(byteBuffer); } ByteBuffer提供一种char和byte之间的软转换，它们之间转换不需要编码和解码，只是把一个16bit的char拆分为2个8bit的byte表示，它们的实际值并没有被修改，仅仅是数据的类型做了转换。 public static void main(String[] args) { ByteBuffer heapByteBuffer = ByteBuffer.allocate(1024); ByteBuffer buffer = heapByteBuffer.putChar(&#39;中&#39;); System.out.print(Integer.toBinaryString(buffer.get(0)) + &quot; &quot;); System.out.print(Integer.toBinaryString(buffer.get(1))); } 打印结果：1001110 101101 编码问题（char-encoding-problem）典型示例： public class EncodeTest { static String toHexString(byte[] bytes) { StringBuilder sb = new StringBuilder(&quot;&quot;); if (bytes == null || bytes.length == 0) { return null; } for (int i = 0; i &lt; bytes.length; i++) { int v = bytes[i] &amp; 0xFF; String hv = Integer.toHexString(v); sb.append(hv + &quot; &quot;); } return sb.toString(); } static String toHexString(char[] chars) { StringBuilder sb = new StringBuilder(&quot;&quot;); if (chars == null || chars.length == 0) { return null; } for (int i = 0; i &lt; chars.length; i++) { String hv = Integer.toHexString((int) chars[i]); sb.append(hv + &quot; &quot;); } return sb.toString(); } public static void main(String[] args) { String string = &quot;I am 李&quot;; // Unicode十进制数值为： 73 32 97 109 32 26446 // Unicode十六进制字符串： 49 20 61 6d 20 674e // Unicode二进字符串： 01001001 00100000 01100001 01101101 00100000 0110011101001110 try { byte[] iso8859 = string.getBytes(&quot;ISO-8859-1&quot;); byte[] gb2312 = string.getBytes(&quot;GB2312&quot;); byte[] gbk = string.getBytes(&quot;GBK&quot;); byte[] utf16 = string.getBytes(&quot;UTF-16&quot;); byte[] utf8 = string.getBytes(&quot;UTF-8&quot;); System.out.println(toHexString(string.toCharArray())); // 输出结果：49 20 61 6d 20 674e /** * ISO-8859-1编码会将不支持的字符编码为3f，即&quot;?&quot;字符。 */ System.out.println(toHexString(iso8859)); // 输出结果：49 20 61 6d 20 3f /** * GB2312字符集有一个从char到byte的码表，不同的字符编码就是从这个码表找到与每个字符对应的字节，然后拼装成byte数组。 */ System.out.println(toHexString(gb2312)); // 输出结果：49 20 61 6d 20 c0 ee /** * GBK编码兼容GB2312编码，且GBK包含的汉字字符更多。 */ System.out.println(toHexString(gbk)); // 输出结果：49 20 61 6d 20 c0 ee /** * UTF-16仅将字符的高位与低位进行拆分变成两个字节，特点是编码效率非常高，规则很简单 * 前面用两个字节来保存BYTE_ORDER_MARK值，用来区分是高位字节在前，或者低位字节在前。 */ System.out.println(toHexString(utf16)); // 输出结果：fe ff 0 49 0 20 0 61 0 6d 0 20 67 4e /** * UTF-8编码也不用查表，效率很高，变长存储节省空间。 */ System.out.println(toHexString(utf8)); // 输出结果：49 20 61 6d 20 e6 9d 8e } catch (Exception e) { e.printStackTrace(); } } } 在Java Web中涉及的编解码URL的编解码用户提交一个URL，在这个URL中可能存在中文，因此需要编码。 Apache Tomcat对URL的URI部分进行解码的字符集是在Connector的&lt;Connector URIEncoding=&quot;UTF-8&quot;/&gt;中定义的，如果没有定义，那么将以默认编码ISO-8859-1解析。所以有中文URL时最好把URIEncoding设置成UTF-8编码。 CATALINA_HOME\\conf\\server.xml中修改Connector 配置如下： &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8483&quot; URIEncoding=&quot;UTF-8&quot;/&gt; URL中以Get方式请求的QueryString的解码是在request.getParameter()方法第一次被调用时进行的，解码字符集要么是Header中ContentType定义的Charset，要么是默认的ISO-8859-1，要使用ContentType中定义的编码，就要将Connector的&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;中的useBodyEncodingForURI设置为true，对QueryString使用BodyEncoding解码。 CATALINA_HOME\\conf\\server.xml中修改Connector 配置如下： &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8483&quot; URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt; HTTP Header的编解码当客户端发起一个HTTP请求时，在Header中可能会传递其他参数，如Cookie、redirectPath等，对于这些参数Tomcat默认使用ISO-8859-1解码，并且不能设置成其他的解码格式。因此，如果你设置的Header中含有非ASCII字符，解码中肯定会有乱码。一个简单的解决办法：可以先将这些字符用org.apache.catalina.util.URLEncoder编码，再添加到Header中，使用这些项时再按照相应的字符集解码即可。 POST表单的编解码POST表单提交的参数的解码也是在request.getParameter()方法第一次被调用时发生的，POST表单的参数传递方法与QueryString不同，它是通过HTTP的BODY传递到服务端的。当我们在页面上单击提交按钮时浏览器首先将根据ContentType的Charset编码格式对在表单中填入的参数进行编码，然后提交到服务器端，在服务器端同样也是用ContentType中的字符集进行解码的。所以通过POST表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过request.setCharacterEncoding(charset)来设置。 注意：要在第一次调用request.getParameter()方法之前就设置request.setCharacterEncoding(charset)，否则POST表单提交上来的数据可能出现乱码。 HTTP BODY的编解码当用户请求的资源已经成功获取后，这些内容将通过Response返回给客户端浏览器，这个过程要先经过编码，再到浏览器进行解码。编解码字符集可以通过response.setCharacterEncoding来设置，它将会覆盖request.getCharacterencoding的值，并且通过Header的Content-Type返回客户端，浏览器接收到返回的Socket流时将通过Content-Type的charset来解码。如果返回的HTTP Header中Content-Type没有设置charset，那么浏览器将根据HTML的&lt;meta HTTP-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt;中的charset来解码。如果也没有定义，那么浏览器将使用默认的编码来解码。 访问数据库都是通过客户端JDBC驱动来完成的，用JDBC来存取数据时要和数据的内置编码保持一致，可以通过设置JDBC URL来指定，如MYSQL：url=“jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK”。 在JS中的编码问题外部引入JS文件在一个单独的JS文件中包含字符串输入 的情况，如： &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt; &lt;script src=&quot;script.js&quot; charset=&quot;gbk&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;/html&gt; 如果引入的script.js脚本中有如下代码： document.write(&quot;这是一段中文&quot;); 这时如果script没有设置cahrset，浏览器就会以当前这个页面的默认字符集解析这个JS文件。当script.js文件与当前页面的编码格式不一致时，就会出现乱码。 JS的URL编码在JS中处理URL编码的函数有三个：escape()、encodeURI()和encodeURIComponent()。 escape()这个函数是将ASCII字母、数字、标点符号（* + - . / @ _）之外的其他字符转化成Unicode编码值，并且在编码值前加上“%u”，通过unescape()函数解码，如图所示。 注意：escape()和unescape()已经从ECMAScript V3 标准中删除了，URL的编码可以用encodeURI和encodeURIComponent来代替。 encodeURI()与escap()相比，encodeURI()是真正的JS用来对URL编码的函数，它可以将整个URL中的字符（一些特殊字符除外，如：！ # $ &amp; &#39; ( ) * + , - . / : ; = ? @ _ ~ 0-9 a-z A-Z）进行UTF-8编码，在每个码值前加上“%”，解码通过decodeURI()函数，如图所示。 encodeURIComponent()encodeURIComponent()这个函数比encodeURI()编码还要彻底，它除了对 ! ‘ ( ) * - . _ ~ 0-9 a-z A-Z这几个字符不编码，对其他所有字符都编码。这个函数通常用于将一个URL当作一个参数放在另一个URL中，解码通过decodeURIComponent()函数，如图所示。 Java与JS编解码问题在Java端处理URL编解码有两个类，分别是 java.net.URLEncoder和java.net.URLDecoder。这两个类可以将所有“%”加UTF-8码值用UFT-8解码，从而得到原始字符。Java端的URLEncoder和URLDecoder与前端JS对应的是encodeURIComponent和decodeURIComponent。 注意：可以用encodeURIComponent两次编码，如encodeURIComponent(encodeURIComponent(str))，这样在Java端通过request.getParameter()用GBK解码后取得的就是UTF-8编码的字符串，如果Java端需要使用这个字符串，则再用UTF-8解码一次；如果是将这个结果直接通过JS输出到前端，那么这个UTF-8字符串可以直接在前端正常显示。 其他需要编码的地方XML文件可以通过设置头来指定编码格式： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; Velocity模板设置编码的格式如下： services.VelocityService.input.encoding=UTF-8 JSP设置编码的格式如下： &lt;%@page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,字符编码","slug":"Java-字符编码","permalink":"/tags/Java-字符编码/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"元注解详解","slug":"Java核心基础之--元注解详解","date":"2020-06-06T09:23:10.000Z","updated":"2023-04-30T10:21:41.350Z","comments":true,"path":"2020/06/06/Java核心基础之--元注解详解/","link":"","permalink":"/2020/06/06/Java核心基础之--元注解详解/","excerpt":"","text":"Annotation(注解)从JDK 1.5开始, Java增加了对元数据(MetaData)的支持，也就是 Annotation(注解)。 注解其实就是代码里的特殊标记，它用于替代配置文件：传统方式通过配置文件告诉类如何运行，有了注解技术后，开发人员可以通过注解告诉类如何运行。在Java技术里注解的典型应用是：可以通过反射技术去得到类里面的注解，以决定怎么去运行类。 注解可以标记在包、类、属性、方法，方法参数以及局部变量上，且同一个地方可以同时标记多个注解。 // 抑制编译期的未指定泛型、未使用和过时警告 @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unused&quot;, &quot;deprecation&quot; }) // 重写 @Override meta-annotation（元注解） 除了直接使用JDK 定义好的注解，我们还可以自定义注解，在JDK 1.5中提供了4个标准的用来对注解类型进行注解的注解类，我们称之为 meta-annotation（元注解），他们分别是： @Target @Retention @Documented @Inherited 我们可以使用这4个元注解来对我们自定义的注解类型进行注解，接下来，我们挨个对这4个元注解的作用进行介绍。 @Target注解Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。 Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。 public enum ElementType { TYPE, // 类、接口、枚举类 FIELD, // 成员变量（包括：枚举常量） METHOD, // 成员方法 PARAMETER, // 方法参数 CONSTRUCTOR, // 构造方法 LOCAL_VARIABLE, // 局部变量 ANNOTATION_TYPE, // 注解类 PACKAGE, // 可用于修饰：包 TYPE_PARAMETER, // 类型参数，JDK 1.8 新增 TYPE_USE // 使用类型的任何地方，JDK 1.8 新增 } @Retention注解Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。 Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。 public enum RetentionPolicy { SOURCE, // 源文件保留 CLASS, // 编译期保留，默认值 RUNTIME // 运行期保留，可通过反射去获取注解信息 } 为了验证应用了这三种策略的注解类有何区别，分别使用三种策略各定义一个注解类做测试。 @Retention(RetentionPolicy.SOURCE) public @interface SourcePolicy { } @Retention(RetentionPolicy.CLASS) public @interface ClassPolicy { } @Retention(RetentionPolicy.RUNTIME) public @interface RuntimePolicy { } 用定义好的三个注解类分别去注解一个方法。 public class RetentionTest { @SourcePolicy public void sourcePolicy() { } @ClassPolicy public void classPolicy() { } @RuntimePolicy public void runtimePolicy() { } } 如图所示，通过执行 javap -verbose RetentionTest 命令获取到的RetentionTest 的 class 字节码内容如下。 { public retention.RetentionTest(); flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V 4: return LineNumberTable: line 3: 0 public void sourcePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 7: 0 public void classPolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 11: 0 RuntimeInvisibleAnnotations: 0: #11() public void runtimePolicy(); flags: ACC_PUBLIC Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 15: 0 RuntimeVisibleAnnotations: 0: #14() } 从 RetentionTest 的字节码内容我们可以得出以下两点结论： 编译器并没有记录下 sourcePolicy() 方法的注解信息； 编译器分别使用了 RuntimeInvisibleAnnotations 和 RuntimeVisibleAnnotations 属性去记录了classPolicy()方法 和 runtimePolicy()方法 的注解信息； @Documented注解Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。 为了验证Documented注解的作用到底是什么，我们创建一个带有 @Documented 的自定义注解类。 import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Documented @Target({ElementType.TYPE,ElementType.METHOD}) public @interface MyDocumentedtAnnotation { public String value() default &quot;这是@Documented注解为文档添加的注释&quot;; } 再创建一个 MyDocumentedTest 类。 @MyDocumentedtAnnotation public class MyDocumentedTest { @Override @MyDocumentedtAnnotation public String toString() { return this.toString(); } } 接下来，使用以下命令为 MyDocumentedTest 类生成帮助文档。 命令执行完成之后，会在当前目录下生成一个 doc 文件夹，其内包含以下文件。 查看 index.html 帮助文档，可以发现在类和方法上都保留了 MyDocumentedtAnnotation 注解信息。 修改 MyDocumentedtAnnotation 注解类，去掉上面的 @Documented 注解。 import java.lang.annotation.ElementType; import java.lang.annotation.Target; @Target({ElementType.TYPE,ElementType.METHOD}) public @interface MyDocumentedtAnnotation { public String value() default &quot;这是@Documented注解为文档添加的注释&quot;; } 重新生成帮助文档，此时类和方法上的 MyDocumentedtAnnotation 注解信息都不见了。 @Inherited注解Inherited注解的作用是：使被它修饰的注解具有继承性（如果某个类使用了被@Inherited修饰的注解，则其子类将自动具有该注解）。 接下来我们使用代码来进行测试，首先创建一个被@Inherited修饰的注解类MyInheritedAnnotation。 import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Inherited @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface MyInheritedAnnotation { public String name() default &quot;pengjunlee&quot;; } 创建一个带有 MyInheritedAnnotation 注解的父类和一个无任何注解的子类。 @MyInheritedAnnotation(name=&quot;parent&quot;) public class Parent { } public class Child extends Parent{ public static void main(String[] args) { Class&lt;Child&gt; child=Child.class; MyInheritedAnnotation annotation = child.getAnnotation(MyInheritedAnnotation.class); System.out.println(annotation.name()); } } 运行程序，打印结果如下： parent 注解应用举例首先自定义一个注解类。 package com.pengjunlee; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @Inherited public @interface MyAnnotation { public String name() default &quot;pengjunlee&quot;; } 在 AnnotationTest 中使用反射获取注解信息。 package com.pengjunlee; import java.lang.annotation.Annotation; import java.lang.reflect.Method; @MyAnnotation(name = &quot;name of type&quot;) public class AnnotationTest { @MyAnnotation(name = &quot;name of method&quot;) public String hello() { return &quot;hello&quot;; } public static void main(String[] args) throws NoSuchMethodException, SecurityException { Class&lt;AnnotationTest&gt; annotationTest = AnnotationTest.class; // 获取类上的所有注解 Annotation[] annotations = annotationTest.getAnnotations(); for (Annotation annotation : annotations) { // 获取注解的全类名 System.out.println(annotation.annotationType().getName()); } // 获取 hello() 方法 Method method = annotationTest.getMethod(&quot;hello&quot;, new Class[] {}); // hello() 方法上是否有 MyAnnotation 注解 if (method.isAnnotationPresent(MyAnnotation.class)) { // 获得注解 MyAnnotation annotation = method.getAnnotation(MyAnnotation.class); // 获取注解的内容 System.out.println(annotation.name()); } } } 运行程序，打印结果如下： com.pengjunlee.MyAnnotationname of method","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,元注解,Annotation","slug":"Java-元注解-Annotation","permalink":"/tags/Java-元注解-Annotation/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"为图片添加水印","slug":"Java核心基础之--为图片添加水印","date":"2020-06-06T09:22:10.000Z","updated":"2023-04-30T10:21:41.346Z","comments":true,"path":"2020/06/06/Java核心基础之--为图片添加水印/","link":"","permalink":"/2020/06/06/Java核心基础之--为图片添加水印/","excerpt":"","text":"在实际项目开发过程中经常会需要给图片添加上水印，俗话说的好：“好记性不如烂笔头“，在此对其实现方法做下笔记。 package com.pengjunlee.watermark; import java.awt.AlphaComposite; import java.awt.Color; import java.awt.Font; import java.awt.Graphics2D; import java.awt.Image; import java.awt.RenderingHints; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.logging.Level; import java.util.logging.Logger; import javax.imageio.ImageIO; import com.sun.image.codec.jpeg.JPEGCodec; import com.sun.image.codec.jpeg.JPEGImageEncoder; /** * 为图片添加水印 * * @author pengjunlee * */ public class WaterMarkUtils { private static final Logger logger = Logger.getLogger(&quot;watermark&quot;); // 水印透明度 private static Float ALPHA_NONE = 0.5f; // 水印文字字体 private static Font FONT_SONG = new Font(&quot;宋体&quot;, Font.BOLD, 28); // 水印文字颜色 private static Color COLOR_BLACK = Color.BLACK; /** * 为图片添加文本水印 * * @param srcImgPath * 源图片路径 * @param targetImgPath * 目标图片路径 * @param text * 水印文字 * @param font * 水印文字字体 * @param color * 水印文字颜色 * @param alpha * 水印透明度 * @param degree * 水印旋转角度 */ public static void addTextWaterMark(String srcImgPath, String targetImgPath, String text, Font font, Color color, Float alpha, Integer degree) { if (isEmptyStr(srcImgPath) || isEmptyStr(targetImgPath)) { logger.log(Level.WARNING, &quot;invalid watermark file path parameters...&quot;); return; } File srcImgFile = new File(srcImgPath); File targetImgFile = new File(targetImgPath); addTextWaterMark(srcImgFile, targetImgFile, text, font, color, alpha, degree); } /** * 为图片添加文本水印 * * @param srcImgFile * 源图片文件 * @param targetImgFile * 目标图片文件 * @param text * 水印文字 * @param font * 水印文字字体 * @param color * 水印文字颜色 * @param alpha * 水印透明度 * @param degree * 水印旋转角度 */ public static void addTextWaterMark(File srcImgFile, File targetImgFile, String text, Font font, Color color, Float alpha, Integer degree) { if (!isFileReadable(srcImgFile) || null == targetImgFile) { logger.log(Level.WARNING, &quot;invalid watermark file parameters...&quot;); return; } File targetParentFile = targetImgFile.getParentFile(); if (!targetParentFile.exists()) { targetParentFile.mkdirs(); } FileOutputStream outImgStream = null; try { Image srcImg = ImageIO.read(srcImgFile); // 读取图片 int srcImgWidth = srcImg.getWidth(null); // 图片宽度 int srcImgHeight = srcImg.getHeight(null); // 图片高度 BufferedImage bufferedImg = new BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = bufferedImg.createGraphics(); // 开启文本着色抗锯齿 g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON); // 控制显示文本的质量 g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_OFF); // 控制着色技术 g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED); g.drawImage(srcImg, 0, 0, srcImgWidth, srcImgHeight, null); // 设置边白 // g.setColor(Color.WHITE); // g.fillRect(0, srcImgHeight - 30, srcImgWidth, srcImgHeight); // 设置水印旋转角度 if (null != degree) { g.rotate(Math.toRadians(degree), (double) bufferedImg.getWidth() / 2, (double) bufferedImg.getHeight() / 2); } // 设置水印文字颜色 g.setColor(null == color ? COLOR_BLACK : color); // 设置水印透明度 g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, null == alpha ? ALPHA_NONE : alpha)); // 设置水印文字字体 if (null == font) { font = FONT_SONG; } g.setFont(font); // 设置水印的坐标 int x = srcImgWidth - getTextWidth(text, g) - 10; int y = srcImgHeight - 10; // 绘制水印 g.drawString(text, x, y); g.dispose(); outImgStream = new FileOutputStream(targetImgFile); // ImageIO.write(bufferedImg, &quot;jpg&quot;, outImgStream); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(outImgStream); encoder.encode(bufferedImg); outImgStream.flush(); outImgStream.close(); logger.log(Level.INFO, &quot;add text watermark success...&quot;); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } finally { if (null != outImgStream) { try { outImgStream.close(); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } } } } /** * 为图片添加文本水印 * * @param srcImgStream * @param targetImgStream * @param text * 水印文字 * @param font * 水印文字字体 * @param color * 水印文字颜色 * @param alpha * 水印透明度 * @param degree * 水印旋转角度 */ public static void addTextWaterMark(InputStream srcImgStream, OutputStream targetImgStream, String text, Font font, Color color, Float alpha, Integer degree) { if (null == srcImgStream || null == targetImgStream) { logger.log(Level.WARNING, &quot;invalid watermark file parameters...&quot;); return; } try { Image srcImg = ImageIO.read(srcImgStream); // 文件转化为图片 int srcImgWidth = srcImg.getWidth(null); // 图片宽度 int srcImgHeight = srcImg.getHeight(null); // 图片高度 BufferedImage bufferedImg = new BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = bufferedImg.createGraphics(); // 开启文本着色抗锯齿 g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON); // 控制显示文本的质量 g.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_OFF); // 控制着色技术 g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED); g.drawImage(srcImg, 0, 0, srcImgWidth, srcImgHeight, null); // 设置边白 // g.setColor(Color.WHITE); // g.fillRect(0, srcImgHeight - 30, srcImgWidth, srcImgHeight); // 设置水印旋转角度 if (null != degree) { g.rotate(Math.toRadians(degree), (double) bufferedImg.getWidth() / 2, (double) bufferedImg.getHeight() / 2); } // 设置水印文字颜色 g.setColor(null == color ? COLOR_BLACK : color); // 设置水印透明度 g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, null == alpha ? ALPHA_NONE : alpha)); // 设置水印文字字体 if (null == font) { font = FONT_SONG; } g.setFont(font); // 设置水印的坐标 int x = srcImgWidth - getTextWidth(text, g) - 10; int y = srcImgHeight - 10; // 绘制水印 g.drawString(text, x, y); g.dispose(); ImageIO.write(bufferedImg, &quot;png&quot;, targetImgStream); targetImgStream.flush(); targetImgStream.close(); logger.log(Level.INFO, &quot;add text watermark success...&quot;); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } finally { if (null != targetImgStream) { try { targetImgStream.close(); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } } } } /** * 为图片添加图片水印 * * @param srcImgPath * 源图片路径 * @param waterImgPath * 水印图片路径 * @param targetImgPath * 目标图片路径 * @param x * 水印x坐标 * @param y * 水印y坐标 * @param alpha * 水印透明度 * @param degree * 水印旋转角度 */ public static void addImageWaterMark(String srcImgPath, String waterImgPath, String targetImgPath, int x, int y, Float alpha, Integer degree) { if (isEmptyStr(srcImgPath) || isEmptyStr(waterImgPath) || isEmptyStr(targetImgPath)) { logger.log(Level.WARNING, &quot;invalid watermark file path parameters...&quot;); return; } File srcImgFile = new File(srcImgPath); File waterImgFile = new File(waterImgPath); File targetImgFile = new File(targetImgPath); addImageWaterMark(srcImgFile, waterImgFile, targetImgFile, x, y, alpha, degree); } /** * 为图片添加图片水印 * * @param srcImgFile * 源图片文件 * @param waterImgFile * 水印图片文件 * @param targetImgFile * 目标图片文件 * @param x * 水印x坐标 * @param y * 水印y坐标 * @param alpha * 水印透明度 * @param degree * 水印旋转角度 */ public static void addImageWaterMark(File srcImgFile, File waterImgFile, File targetImgFile, int x, int y, Float alpha, Integer degree) { if (!isFileReadable(srcImgFile) || !isFileReadable(srcImgFile) || null == targetImgFile) { logger.log(Level.WARNING, &quot;invalid watermark file parameters...&quot;); return; } File targetParentFile = targetImgFile.getParentFile(); if (!targetParentFile.exists()) { targetParentFile.mkdirs(); } FileOutputStream outImgStream = null; try { Image srcImg = ImageIO.read(srcImgFile); // 读取图片 int srcImgWidth = srcImg.getWidth(null); // 图片宽度 int srcImgHeight = srcImg.getHeight(null); // 图片高度 BufferedImage bufferedImg = new BufferedImage(srcImgWidth, srcImgHeight, BufferedImage.TYPE_INT_RGB); Graphics2D g = bufferedImg.createGraphics(); // 开启图形着色抗锯齿 g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); // 控制颜色着色的方式 g.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY); // 控制如何处理抖动 g.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE); // 控制内插方式 g.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC); // 控制着色技术 g.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_SPEED); // 绘制目标图片 g.drawImage(srcImg, 0, 0, srcImgWidth, srcImgHeight, null); // 设置水印旋转角度 if (null != degree) { g.rotate(Math.toRadians(degree), (double) bufferedImg.getWidth() / 2, (double) bufferedImg.getHeight() / 2); } // 绘制水印图片 Image targetImg = ImageIO.read(waterImgFile); // SRC、DST、SRC_IN、DST_IN、SRC_OUT、DST_OUT（交集保留其一） / CLEAR（交集都不保留） // SRC_OVER、DST_OVER、SRC_ATOP、DST_ATOP（交集一个在上）/ XOR（差集） g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, null == alpha ? ALPHA_NONE : alpha)); g.drawImage(targetImg, x, y, null); g.dispose(); outImgStream = new FileOutputStream(targetImgFile); // ImageIO.write(bufferedImg, &quot;jpg&quot;, outImgStream); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(outImgStream); encoder.encode(bufferedImg); outImgStream.flush(); outImgStream.close(); logger.log(Level.INFO, &quot;add text watermark success...&quot;); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } finally { if (null != outImgStream) { try { outImgStream.close(); } catch (IOException e) { logger.log(Level.SEVERE, e.getMessage()); } } } } /** * 判断是否为空字符串 * * @param str * @return */ private static boolean isEmptyStr(String str) { return str == null || str.length() == 0; } /** * 判断文件是否可读 * * @param file * @return */ private static boolean isFileReadable(File file) { return file != null &amp;&amp; file.exists() &amp;&amp; file.isFile() &amp;&amp; file.canRead(); } /** * 获取文本在图片当前字体下的宽度 * * @param text * @param g * @return */ public static int getTextWidth(String text, Graphics2D g) { return g.getFontMetrics(g.getFont()).charsWidth(text.toCharArray(), 0, text.length()); } public static void main(String[] args) { addTextWaterMark(&quot;D:/src/Yao1.jpg&quot;, &quot;D:/src/target/Yao1.jpg&quot;, &quot;作者：pengjunlee&quot;, new Font(&quot;微软雅黑&quot;, Font.BOLD, 25), Color.white, null, null); addImageWaterMark(&quot;D:/src/Yao2.jpg&quot;, &quot;D:/src/watermark.png&quot;, &quot;D:/src/target/Yao2.jpg&quot;, 300, 60, 1f, null); } } 程序执行后的结果，左侧为原图，右侧为添加水印后的图片。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,水印","slug":"Java-水印","permalink":"/tags/Java-水印/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用Quartz进行作业任务调度","slug":"Java核心基础之--使用Quartz进行作业任务调度","date":"2020-06-06T09:21:10.000Z","updated":"2023-04-30T10:21:41.348Z","comments":true,"path":"2020/06/06/Java核心基础之--使用Quartz进行作业任务调度/","link":"","permalink":"/2020/06/06/Java核心基础之--使用Quartz进行作业任务调度/","excerpt":"","text":"Quartz是一个完全由java编写的开源作业调度框架，为在Java应用程序中进行作业调度提供了简单却强大的机制。 Quartz允许开发人员根据时间间隔（或天数）来调度作业。它实现了作业和触发器的多对多关系，还能把多个作业与不同的触发器关联。整合了 Quartz 的应用程序可以重用来自不同事件的作业，还可以为一个事件组合多个作业。 由 James House 创建并最初于2001年春天被加入sourceforge工程。之后归入OpenSymphony开源组织(2010年11月份关闭)。Terracotta公司在2009年收购了著名的Java开源缓存项目Ehcache以及Java任务调度项目Quartz。 官网下载地址：http://www.quartz-scheduler.org/downloads/ 1、设置开始时间import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class MyJob implements Job { @Override public void execute(JobExecutionContext arg0) throws JobExecutionException { System.out.println(&quot;执行定时任务:MyJob.execute()...，当前时间：&quot;+System.currentTimeMillis()); } } public static void testStartAt() throws SchedulerException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); Date runTime = DateBuilder.evenSecondDate(new Date()); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName1&quot;, &quot;jobGroup1&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName1&quot;, &quot;triggerGroup1&quot;).startAt(runTime) .build(); sched.scheduleJob(job, trigger); sched.start(); } 2、设置结束时间public static void testEndAt() throws SchedulerException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); Date runTime = DateBuilder.evenSecondDate(new Date()); Date endTime = DateBuilder.evenMinuteDate(new Date()); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName2&quot;, &quot;jobGroup2&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName2&quot;, &quot;triggerGroup2&quot;).startAt(runTime) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()) .endAt(endTime).build(); sched.scheduleJob(job, trigger); sched.start(); } 3、简单触发器SimpleScheduleBuilder.simpleSchedule() 可以设置作业执行的时间间隔和重复执行的次数。 public static void testSimJob() throws SchedulerException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName3&quot;, &quot;jobGroup3&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName3&quot;, &quot;triggerGroup3&quot;) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(1).repeatForever()).build(); sched.scheduleJob(job, trigger); sched.start(); } 4、Cron触发器CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;) 使用Unix cron表达式对作业执行周期进行设置。 public static void testCronJob() throws SchedulerException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName4&quot;, &quot;jobGroup4&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName4&quot;, &quot;triggerGroup4&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); sched.scheduleJob(job, trigger); sched.start(); } 5、作业监听器import org.quartz.JobDataMap; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.quartz.JobKey; import org.quartz.JobListener; public class MyJobListener implements JobListener { @Override public String getName() { return &quot;MyJobListener&quot;; } /** * (1) 任务执行之前执行 Called by the Scheduler when a JobDetail is about to be * executed (an associated Trigger has occurred). */ @Override public void jobToBeExecuted(JobExecutionContext context) { System.out.println(&quot;MyJobListener.jobToBeExecuted()&quot;); // 获取usingJobData中传入的数据 JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(&quot;jobSays&quot;); int currentYear = dataMap.getInt(&quot;currentYear&quot;); System.err.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot;, and currentYear is: &quot; + currentYear); } /** * (2) * 这个方法正常情况下不执行,但是如果当TriggerListener中的vetoJobExecution方法返回true时,那么执行这个方法. * 需要注意的是 如果方法(2)执行 那么(1),(3)这个俩个方法不会执行,因为任务被终止了嘛. Called by the Scheduler * when a JobDetail was about to be executed (an associated Trigger has * occurred), but a TriggerListener vetoed it&#39;s execution. */ @Override public void jobExecutionVetoed(JobExecutionContext context) { System.out.println(&quot;MyJobListener.jobExecutionVetoed()&quot;); } /** * (3) 任务执行完成后执行,jobException如果它不为空则说明任务在执行过程中出现了异常 Called by the Scheduler * after a JobDetail has been executed, and be for the associated Trigger&#39;s * triggered(xx) method has been called. */ @Override public void jobWasExecuted(JobExecutionContext context, JobExecutionException jobException) { System.out.println(&quot;MyJobListener.jobWasExecuted()&quot;); // 获取usingJobData中传入的数据 JobKey key = context.getJobDetail().getKey(); JobDataMap dataMap = context.getJobDetail().getJobDataMap(); String jobSays = dataMap.getString(&quot;jobSays&quot;); int currentYear = dataMap.getInt(&quot;currentYear&quot;); System.out.println(&quot;Instance &quot; + key + &quot; of DumbJob says: &quot; + jobSays + &quot; and current year is &quot; + currentYear); } } public static void testJobListener() throws SchedulerException { JobKey jobKey = new JobKey(&quot;jobName5&quot;, &quot;jobGroup5&quot;); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(jobKey).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName5&quot;, &quot;triggerGroup5&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); Scheduler scheduler = new StdSchedulerFactory().getScheduler(); // Listener attached to jobKey // scheduler.getListenerManager().addJobListener(new MyJobListener(), // KeyMatcher.keyEquals(jobKey)); // Listener attached to group scheduler.getListenerManager().addJobListener(new MyJobListener(), GroupMatcher.jobGroupEquals(&quot;jobGroup5&quot;)); scheduler.start(); scheduler.scheduleJob(job, trigger); } 6、启动多个作业import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; public class YourJob implements Job { @Override public void execute(JobExecutionContext arg0) throws JobExecutionException { System.out.println(&quot;执行定时任务:YourJob.execute()...，当前时间：&quot; + System.currentTimeMillis()); } } public static void testMultiJobs() throws SchedulerException { JobKey jobKeyA = new JobKey(&quot;jobName6A&quot;, &quot;jobGroup6&quot;); JobDetail jobA = JobBuilder.newJob(MyJob.class).withIdentity(jobKeyA).build(); JobKey jobKeyB = new JobKey(&quot;jobName6B&quot;, &quot;jobGroup6&quot;); JobDetail jobB = JobBuilder.newJob(YourJob.class).withIdentity(jobKeyB).build(); Trigger trigger1 = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName6A&quot;, &quot;triggerGroup6&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); Trigger trigger2 = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName6B&quot;, &quot;triggerGroup6&quot;) .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/5 * * * * ?&quot;)).build(); Scheduler scheduler = new StdSchedulerFactory().getScheduler(); scheduler.start(); scheduler.scheduleJob(jobA, trigger1); scheduler.scheduleJob(jobB, trigger2); } 7、查看所有作业@SuppressWarnings(&quot;unchecked&quot;) public static void testQueryJobs() throws SchedulerException { Scheduler scheduler = new StdSchedulerFactory().getScheduler(); for (String groupName : scheduler.getJobGroupNames()) { for (JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))) { String jobName = jobKey.getName(); String jobGroup = jobKey.getGroup(); List&lt;Trigger&gt; triggers = (List&lt;Trigger&gt;) scheduler.getTriggersOfJob(jobKey); Date nextFireTime = triggers.get(0).getNextFireTime(); System.out.println(&quot;[jobName] : &quot; + jobName + &quot; [groupName] : &quot; + jobGroup + &quot; - &quot; + nextFireTime); } } } 8、手动触发作业public static void testTriggerJob() throws SchedulerException, InterruptedException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); Date runTime = DateBuilder.evenSecondDate(new Date()); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName8&quot;, &quot;jobGroup8&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName8&quot;, &quot;triggerGroup8&quot;).startAt(runTime) .build(); sched.scheduleJob(job, trigger); sched.start(); // 手动触发两次 sched.triggerJob(new JobKey(&quot;jobName8&quot;, &quot;jobGroup8&quot;)); sched.triggerJob(new JobKey(&quot;jobName8&quot;, &quot;jobGroup8&quot;)); } 9、传递参数public static void testJobData() throws SchedulerException { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); Date runTime = DateBuilder.evenSecondDate(new Date()); JobDetail job = JobBuilder.newJob(MyJob.class).withIdentity(&quot;jobName9&quot;, &quot;jobGroup9&quot;) .usingJobData(&quot;jobSays&quot;, &quot;Hello Quartz!&quot;).usingJobData(&quot;currentYear&quot;, 2017).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName9&quot;, &quot;triggerGroup9&quot;).startAt(runTime) .build(); sched.scheduleJob(job, trigger); sched.start(); sched.getListenerManager().addJobListener(new MyJobListener(), GroupMatcher.jobGroupEquals(&quot;jobGroup9&quot;)); } 10、取消/删除作业public static void testCancelJob(Scheduler sched) throws SchedulerException { // removes the given trigger sched.unscheduleJob(new TriggerKey(&quot;triggerName10&quot;, &quot;triggerGroup10&quot;)); // removes all triggers to the given job sched.deleteJob(new JobKey(&quot;jobName10&quot;, &quot;jobGroup10&quot;)); } 11、作业出错时自动再执行import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.quartz.JobKey; public class ErrorJob implements Job { private int count = 0; @Override public void execute(JobExecutionContext context) throws JobExecutionException { JobKey jobKey = context.getJobDetail().getKey(); try { int zero = 0; @SuppressWarnings(&quot;unused&quot;) int calculation = 1 / zero; } catch (Exception e) { System.out.println(&quot;Instance &quot; + jobKey + &quot;执行出错了!!!&quot;); JobExecutionException e2 = new JobExecutionException(e); // allow 5 retries if ((++count) &gt;= 5) { // make sure it doesn&#39;t run again e2.setUnscheduleAllTriggers(true); } else { // fire it again e2.setRefireImmediately(true); } throw e2; } } } public static void testJobRetry() throws SchedulerException { try { SchedulerFactory sf = new StdSchedulerFactory(); Scheduler sched = sf.getScheduler(); Date runTime = DateBuilder.evenSecondDate(new Date()); JobDetail job = JobBuilder.newJob(ErrorJob.class).withIdentity(&quot;jobName11&quot;, &quot;jobGroup11&quot;).build(); Trigger trigger = TriggerBuilder.newTrigger().withIdentity(&quot;triggerName11&quot;, &quot;triggerGroup11&quot;) .startAt(runTime).build(); sched.scheduleJob(job, trigger); sched.start(); } catch (JobExecutionException e) { } } 12、JWatch - A Quartz MonitorJWatch官网地址：http://code.google.com/p/jwatch/ 13、CronMaker - Cron表达式生成器CronMaker网址：http://www.cronmaker.com/ 14、相关资源下载JWatch管理工具：http://download.csdn.net/download/pengjunlee/10145202 Quartz中文API：http://download.csdn.net/download/pengjunlee/10142840 本文项目源码：http://download.csdn.net/download/pengjunlee/10142832 Quartz英文API：http://download.csdn.net/download/pengjunlee/10142674","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Quartz","slug":"Java-Quartz","permalink":"/tags/Java-Quartz/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用org.json.JSONObject处理Json数据","slug":"Java核心基础之--使用org.json.JSONObject处理Json数据","date":"2020-06-06T09:20:10.000Z","updated":"2023-04-30T10:21:41.350Z","comments":true,"path":"2020/06/06/Java核心基础之--使用org.json.JSONObject处理Json数据/","link":"","permalink":"/2020/06/06/Java核心基础之--使用org.json.JSONObject处理Json数据/","excerpt":"","text":"引入org.json依赖在 maven 项目中使用 org.json ，需引入依赖： &lt;!-- 引入org.json所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20160810&lt;/version&gt; &lt;/dependency&gt; 构建JSONObject直接构建可以直接使用 new 关键字实例化一个JSONObject对象，然后调用它的 put() 方法对其字段值进行设置。 范例： JSONObject jsonObj = new JSONObject(); jsonObj.put(&quot;female&quot;, true); jsonObj.put(&quot;hobbies&quot;, Arrays.asList(new String[] { &quot;yoga&quot;, &quot;swimming&quot; })); jsonObj.put(&quot;discount&quot;, 9.5); jsonObj.put(&quot;age&quot;, &quot;26&quot;); jsonObj.put(&quot;features&quot;, new HashMap&lt;String, Integer&gt;() { private static final long serialVersionUID = 1L; { put(&quot;height&quot;, 175); put(&quot;weight&quot;, 70); } }); System.out.println(jsonObj); 结果： { &quot;features&quot;: { &quot;weight&quot;: 70, &quot;height&quot;: 175 }, &quot;hobbies&quot;: [&quot;yoga&quot;, &quot;swimming&quot;], &quot;discount&quot;: 9.5, &quot;female&quot;: true, &quot;age&quot;: 26 } 使用Map构建范例： Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;female&quot;, true); map.put(&quot;hobbies&quot;, Arrays.asList(new String[] { &quot;yoga&quot;, &quot;swimming&quot; })); map.put(&quot;discount&quot;, 9.5); map.put(&quot;age&quot;, &quot;26&quot;); map.put(&quot;features&quot;, new HashMap&lt;String, Integer&gt;() { private static final long serialVersionUID = 1L; { put(&quot;height&quot;, 175); put(&quot;weight&quot;, 70); } }); JSONObject jsonObj = new JSONObject(map); System.out.println(jsonObj); 程序执行结果与上例相同。 使用JavaBean构建范例： import java.util.Map; public class UserInfo { private Boolean female; private String[] hobbies; private Double discount; private Integer age; private Map&lt;String, Integer&gt; features; public Boolean getFemale() { return female; } public void setFemale(Boolean female) { this.female = female; } public String[] getHobbies() { return hobbies; } public void setHobbies(String[] hobbies) { this.hobbies = hobbies; } public Double getDiscount() { return discount; } public void setDiscount(Double discount) { this.discount = discount; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Map&lt;String, Integer&gt; getFeatures() { return features; } public void setFeatures(Map&lt;String, Integer&gt; features) { this.features = features; } } UserInfo userInfo = new UserInfo(); userInfo.setFemale(true); userInfo.setHobbies(new String[] { &quot;yoga&quot;, &quot;swimming&quot; }); userInfo.setDiscount(9.5); userInfo.setAge(26); userInfo.setFeatures(new HashMap&lt;String, Integer&gt;() { private static final long serialVersionUID = 1L; { put(&quot;height&quot;, 175); put(&quot;weight&quot;, 70); } }); JSONObject jsonObj = new JSONObject(userInfo); System.out.println(jsonObj); 程序执行结果与上例相同。 解析JSONObjectJSONObject为每一种数据类型都提供了一个getXXX(key)方法，例如：获取字符串类型的字段值就使用getString()方法，获取数组类型的字段值就使用getJSONArray()方法。 范例： // 获取基本类型数据 System.out.println(&quot;Female: &quot; + jsonObj.getBoolean(&quot;female&quot;)); System.out.println(&quot;Discount: &quot; + jsonObj.getDouble(&quot;discount&quot;)); System.out.println(&quot;Age: &quot; + jsonObj.getLong(&quot;age&quot;)); // 获取JSONObject类型数据 JSONObject features = jsonObj.getJSONObject(&quot;features&quot;); String[] names = JSONObject.getNames(features); System.out.println(&quot;Features: &quot;); for (int i = 0; i &lt; names.length; i++) { System.out.println(&quot;\\t&quot;+features.get(names[i])); } // 获取数组类型数据 JSONArray hobbies = jsonObj.getJSONArray(&quot;hobbies&quot;); System.out.println(&quot;Hobbies: &quot;); for (int i = 0; i &lt; hobbies.length(); i++) { System.out.println(&quot;\\t&quot;+hobbies.get(i)); } 结果： Female: true Discount: 9.5 Age: 26 Features: 70 175 Hobbies: yoga swimming","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,json,JSONObject","slug":"Java-json-JSONObject","permalink":"/tags/Java-json-JSONObject/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用net.sf.json遍历Json数组","slug":"Java核心基础之--使用net.sf.json遍历Json数组","date":"2020-06-06T09:19:10.000Z","updated":"2023-04-30T10:21:41.349Z","comments":true,"path":"2020/06/06/Java核心基础之--使用net.sf.json遍历Json数组/","link":"","permalink":"/2020/06/06/Java核心基础之--使用net.sf.json遍历Json数组/","excerpt":"","text":"使用net.sf.json遍历Json数组import org.junit.Test; import java.util.Iterator; import net.sf.json.JSONArray; import net.sf.json.JSONObject; public class JsonArrayTest { @SuppressWarnings(&quot;unchecked&quot;) @Test public void test1() { String arrStr = &quot;[{key:&#39;a&#39;,value:&#39;1&#39;},{key:&#39;b&#39;,value:&#39;2&#39;},{key:&#39;c&#39;,value:&#39;3&#39;}]&quot;; JSONArray jsonArray = JSONArray.fromObject(arrStr); for (int i = 0; i &lt; jsonArray.size(); i++) { JSONObject jsonObj = jsonArray.getJSONObject(i); Iterator&lt;String&gt; iterator = jsonObj.keys(); while (iterator.hasNext()) { String key = iterator.next(); System.out.println(key + &quot;:&quot; + jsonObj.getString(key) + &quot; &quot;); } } } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,json","slug":"Java-json","permalink":"/tags/Java-json/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用lombok消除冗余代码","slug":"Java核心基础之--使用lombok消除冗余代码","date":"2020-06-06T09:18:10.000Z","updated":"2023-04-30T10:21:41.349Z","comments":true,"path":"2020/06/06/Java核心基础之--使用lombok消除冗余代码/","link":"","permalink":"/2020/06/06/Java核心基础之--使用lombok消除冗余代码/","excerpt":"","text":"转载自：lombok的使用和原理 一、项目背景在写Java程序的时候经常会遇到如下情形： 新建了一个Class类，然后在其中设置了几个字段，最后还需要花费很多时间来建立getter和setter方法。 lombok项目的产生就是为了省去我们手动创建getter和setter方法的麻烦，它能够在我们编译源码的时候自动帮我们生成getter和setter方法。即它最终能够达到的效果是：在源码中没有getter和setter方法，但是在编译生成的字节码文件中有getter和setter方法。 比如源码文件： import java.io.Serializable; import lombok.Data; @Data public class BasicClusterInfo implements Serializable { private static final long serialVersionUID = 3478135817352393604L; private String hbaseKey; private int receiverCount; } 以下是编译上述源码文件得到的字节码文件，对其反编译得到的结果 public class BasicClusterInfo extends java.lang.Object implements java.io.Serializable{ public BasicClusterInfo(); public java.lang.String getHbaseKey(); public int getReceiverCount(); public void setHbaseKey(java.lang.String); public void setReceiverCount(int); public boolean equals(java.lang.Object); public boolean canEqual(java.lang.Object); public int hashCode(); public java.lang.String toString(); } 二、eclipse安装lombok为IDE安装lombok插件非常简单，以eclipse环境为例，其安装过程分为以下几个步骤： 1) 下载lombok.jar包 lombok的官网地址：https://projectlombok.org/ lombok的下载地址：https://projectlombok.org/download.html lombok项目的Github地址：https://github.com/rzwitserloot/lombok 2) 运行lombok.jar 在windows命令行中输入以下命令： java -jar D:\\software\\lombok.jar 其中 D:\\software\\lombok.jar 这是windows下lombok.jar所在的位置， 数秒后将弹出以下对话框，以指定eclipse的安装路径。 3) 确认完eclipse的安装路径后，点击 install/update 按钮，即可完成安装。 4) 安装完成之后，请确认eclipse安装路径下是否多了一个lombok.jar包，并且其配置文件eclipse.ini中是否添加了如下内容: -javaagent:lombok.jar-Xbootclasspath/a:lombok.jar 那么恭喜你已经安装成功，否则将缺少的部分添加到相应的位置即可 。 5)重启eclipse。 三、项目中使用lombok在项目中使用lombok的方法很简单，分为四个步骤： 在需要自动生成getter和setter方法的类上，加上@Data注解。 在编译类路径中加入lombok.jar包，若是maven工程，引入相关依赖即可。 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 使用支持lombok的编译工具编译源代码（关于支持lombok的编译工具，见“五、支持lombok的编译工具”）。 编译得到的字节码文件中自动生成了getter和setter方法。 四、原理分析接下来对lombok的工作原理进行分析，以Oracle的javac编译工具为例。 自从Java 6起，javac就支持JSR 269 Pluggable Annotation Processing API规范，只要程序实现了该API，就能在javac运行的时候得到调用。 举例来说，现在有一个实现了JSR 269 API的程序A,那么使用javac编译源码的时候具体流程如下： javac对源代码进行分析，生成一棵抽象语法树(AST)。 运行过程中调用实现了”JSR 269 API”的A程序。 此时A程序就可以完成它自己的逻辑，包括修改第一步骤得到的抽象语法树(AST)。 javac使用修改后的抽象语法树(AST)生成字节码文件。 详细的流程图如下： 五、支持lombok的编译工具 由“四、原理分析”可知，Oracle javac直接支持lombok。 常用的项目管理工具Maven所使用的java编译工具来源于配置的第三方工具，如果我们配置这个第三方工具为Oracle javac的话，那么Maven也就直接支持lombok了。 Intellij Idea配置的编译工具为Oracle javac的话，也就直接支持lombok了。 Eclipse中使用的不是Oracle javac这个编译工具，而是自己实现的Eclipse Compiler for Java (ECJ).要想使ECJ支持lombok，得进行设置，具体是在Eclipse程序目录中的eclipse.ini文件中添加如下两行设置： -javaagent:[lombok.jar所在路径] -Xbootclasspath/a:[lombok.jar所在路径] 六、常用lombok注解lombok 提供的注解不多，可以参考官方视频的讲解和官方文档。 Lombok 注解在线帮助文档：http://projectlombok.org/features/index 下面是几个比较常用的 lombok 注解： @Data ：注解在类上；提供类所有属性的 getting 和 setting 方法，此外还提供了equals、canEqual、hashCode、toString 方法 @Setter：注解在属性上；为属性提供 setting 方法 @Getter：注解在属性上；为属性提供 getting 方法 @Log4j ：注解在类上；为类提供一个 属性名为log 的 log4j 日志对象 @NoArgsConstructor：注解在类上；为类提供一个无参的构造方法 @AllArgsConstructor：注解在类上；为类提供一个全参的构造方法 七、其他问题现在使用Intellij Idea作为Java项目的IDE，配置Oracle javac作为编译工具。 现在有一个A类，其中有一些字段，没有创建它们的setter和getter方法，使用了lombok的@Data注解，另外有一个B类，它调用了A类实例的相应字段的setter和getter方法。 编译A类和B类所在的项目，并不会报错，因为最终生成的A类字节码文件中存在相应字段的setter和getter方法。但是，IDE发现B类源代码中所使用的A类实例的setter和getter方法在A类源代码中找不到定义，IDE会认为这是错误。 要解决以上这个不是真正错误的错误，可以下载安装Intellij Idea中的”Lombok plugin”。 八、lombok的罪恶使用lombok虽然能够省去手动创建setter和getter方法的麻烦，但是却大大降低了源代码文件的可读性和完整性，降低了阅读源代码的舒适度。 参考文献[1] http://stackoverflow.com/questions/6107197/how-does-lombok-work[2] https://projectlombok.org/download.html[3] http://stackoverflow.com/questions/3061654/what-is-the-difference-between-javac-and-the-eclipse-compiler[4] http://www.ibm.com/developerworks/library/j-lombok/[5] http://notatube.blogspot.com/2010/12/project-lombok-creating-custom.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,lombok","slug":"Java-lombok","permalink":"/tags/Java-lombok/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用HttpURLConnection请求webservice接口","slug":"Java核心基础之--使用HttpURLConnection请求webservice接口","date":"2020-06-06T09:17:10.000Z","updated":"2023-04-30T10:21:41.348Z","comments":true,"path":"2020/06/06/Java核心基础之--使用HttpURLConnection请求webservice接口/","link":"","permalink":"/2020/06/06/Java核心基础之--使用HttpURLConnection请求webservice接口/","excerpt":"","text":"本文以获取天气预报webservice接口为例，使用·HttpURLConnection·通过发送SOAP消息格式内容来请求webservice接口。 天气预报接口地址：http://www.webxml.com.cn/WebServices/WeatherWebService.asmx?wsdl import java.io.BufferedReader; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; public class HttpUtil { public static String sendSoapPost(String url, String xml, String contentType, String soapAction) { String urlString = url; HttpURLConnection httpConn = null; OutputStream out = null; String returnXml = &quot;&quot;; try { httpConn = (HttpURLConnection) new URL(urlString).openConnection(); httpConn.setRequestProperty(&quot;Content-Type&quot;, contentType); if (null != soapAction) { httpConn.setRequestProperty(&quot;SOAPAction&quot;, soapAction); } httpConn.setRequestMethod(&quot;POST&quot;); httpConn.setDoOutput(true); httpConn.setDoInput(true); httpConn.connect(); out = httpConn.getOutputStream(); // 获取输出流对象 httpConn.getOutputStream().write(xml.getBytes(&quot;UTF-8&quot;)); // 将要提交服务器的SOAP请求字符流写入输出流 out.flush(); out.close(); int code = httpConn.getResponseCode(); // 用来获取服务器响应状态 String tempString = null; StringBuffer sb1 = new StringBuffer(); if (code == HttpURLConnection.HTTP_OK) { BufferedReader reader = new BufferedReader( new InputStreamReader(httpConn.getInputStream(), &quot;UTF-8&quot;)); while ((tempString = reader.readLine()) != null) { sb1.append(tempString); } if (null != reader) { reader.close(); } } else { BufferedReader reader = new BufferedReader( new InputStreamReader(httpConn.getErrorStream(), &quot;UTF-8&quot;)); // 一次读入一行，直到读入null为文件结束 while ((tempString = reader.readLine()) != null) { sb1.append(tempString); } if (null != reader) { reader.close(); } } // 响应报文 returnXml = sb1.toString(); } catch (Exception e) { e.printStackTrace(); } return returnXml; } public static void main(String[] args) { String url = &quot;http://www.webxml.com.cn/WebServices/WeatherWebService.asmx&quot;; StringBuilder sb = new StringBuilder(&quot;&quot;); sb.append( &quot;&lt;soapenv:Envelope xmlns:soapenv=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot; &quot;) .append(&quot;xmlns:web=\\&quot;http://WebXml.com.cn/\\&quot;&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&quot;) .append(&quot;&lt;web:getSupportProvince/&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;&quot;); /* * sb.append( * &quot;&lt;soapenv:Envelope xmlns:soapenv=\\&quot;http://schemas.xmlsoap.org/soap/envelope/\\&quot; &quot; * ) .append( * &quot;xmlns:web=\\&quot;http://WebXml.com.cn/\\&quot;&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;web:getSupportCity&gt;&quot; * ) .append( * &quot;&lt;web:byProvinceName&gt;河北&lt;/web:byProvinceName&gt;&lt;/web:getSupportCity&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt;&quot; * ); */ String dataXml = sb.toString(); String contentType = &quot;text/xml; charset=utf-8&quot;; String soapAction = &quot;http://WebXml.com.cn/getSupportProvince&quot;; // String soapAction = // &quot;\\&quot;document/http://pengjunnlee.com/CustomUI:GetWeatherById\\&quot;&quot;; String resultXml = HttpUtil.sendSoapPost(url, dataXml, contentType, soapAction); System.out.println(resultXml); } } 执行程序，控制台打印结果。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;soap:Body&gt;&lt;getSupportProvinceResponse xmlns=&quot;http://WebXml.com.cn/&quot;&gt;&lt;getSupportProvinceResult&gt;&lt;string&gt;直辖市&lt;/string&gt;&lt;string&gt;特别行政区&lt;/string&gt;&lt;string&gt;黑龙江&lt;/string&gt;&lt;string&gt;吉林&lt;/string&gt;&lt;string&gt;辽宁&lt;/string&gt;&lt;string&gt;内蒙古&lt;/string&gt;&lt;string&gt;河北&lt;/string&gt;&lt;string&gt;河南&lt;/string&gt;&lt;string&gt;山东&lt;/string&gt;&lt;string&gt;山西&lt;/string&gt;&lt;string&gt;江苏&lt;/string&gt;&lt;string&gt;安徽&lt;/string&gt;&lt;string&gt;陕西&lt;/string&gt;&lt;string&gt;宁夏&lt;/string&gt;&lt;string&gt;甘肃&lt;/string&gt;&lt;string&gt;青海&lt;/string&gt;&lt;string&gt;湖北&lt;/string&gt;&lt;string&gt;湖南&lt;/string&gt;&lt;string&gt;浙江&lt;/string&gt;&lt;string&gt;江西&lt;/string&gt;&lt;string&gt;福建&lt;/string&gt;&lt;string&gt;贵州&lt;/string&gt;&lt;string&gt;四川&lt;/string&gt;&lt;string&gt;广东&lt;/string&gt;&lt;string&gt;广西&lt;/string&gt;&lt;string&gt;云南&lt;/string&gt;&lt;string&gt;海南&lt;/string&gt;&lt;string&gt;新疆&lt;/string&gt;&lt;string&gt;西藏&lt;/string&gt;&lt;string&gt;台湾&lt;/string&gt;&lt;string&gt;亚洲&lt;/string&gt;&lt;string&gt;欧洲&lt;/string&gt;&lt;string&gt;非洲&lt;/string&gt;&lt;string&gt;北美洲&lt;/string&gt;&lt;string&gt;南美洲&lt;/string&gt;&lt;string&gt;大洋洲&lt;/string&gt;&lt;/getSupportProvinceResult&gt;&lt;/getSupportProvinceResponse&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,HttpURLConnection,webservice","slug":"Java-HttpURLConnection-webservice","permalink":"/tags/Java-HttpURLConnection-webservice/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用HttpClient发送请求","slug":"Java核心基础之--使用HttpClient发送请求","date":"2020-06-06T09:16:10.000Z","updated":"2023-04-30T10:21:41.348Z","comments":true,"path":"2020/06/06/Java核心基础之--使用HttpClient发送请求/","link":"","permalink":"/2020/06/06/Java核心基础之--使用HttpClient发送请求/","excerpt":"","text":"简介HTTP 协议可能是现在 Internet上使用得最多、最重要的协议了，越来越多的 Java 应用程序需要直接通过 HTTP 协议来访问网络资源。 在 JDK 的 java.net 包中已经提供了访问 HTTP 协议的基本功能，我们可以使用该包中的 URLConnection 类来发送GET和POST请求，但是对于大部分应用程序来说，JDK 库本身提供的功能还不够丰富和灵活。 HttpClient 是 Apache Jakarta Common 下的子项目，用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。 现在 HttpClient 最新版本为 HttpClient 4.5 (GA) （2015-09-11），下载地址：http://hc.apache.org/downloads.cgi 。 HttpClient 提供了以下主要的功能： 实现了所有 HTTP 的方法（GET,POST,PUT,HEAD 等） 支持自动转向 支持 HTTPS 协议 支持代理服务器等 使用方法使用 HttpClient 发送一个HTTP请求一般需要以下 四 个步骤： 创建 HttpClient 的实例。 创建请求方法的实例，并指定请求URL，如果需要发送GET请求，创建HttpGet对象；如果需要发送POST请求，创建HttpPost对象。 调用创建好的 HttpClient 实例的HttpClient.execute(HttpUriRequest request) 方法来执行请求方法，该方法会返回一个封装了服务器响应信息的HttpResponse对象。 释放连接，无论执行方法是否成功，都必须释放连接。 封装工具类import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.KeyManagementException; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate; import java.util.ArrayList; import java.util.List; import javax.net.ssl.SSLContext; import org.apache.http.Header; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.HttpStatus; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.config.RequestConfig; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.conn.ssl.SSLConnectionSocketFactory; import org.apache.http.conn.ssl.TrustStrategy; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicHeader; import org.apache.http.message.BasicNameValuePair; import org.apache.http.ssl.SSLContextBuilder; import org.apache.http.util.EntityUtils; import org.apache.log4j.Logger; /** * Http请求工具类 * * @author pengjunlee */ public class HttpUtil { private static Logger log = Logger.getLogger(HttpUtil.class); /** * 发送GET请求 * @param isHttps 是否https * @param url 请求地址 * @return 响应结果 */ public static String get(boolean isHttps, String url) { CloseableHttpClient httpClient = null; try { if (!isHttps) { httpClient = HttpClients.createDefault(); } else { httpClient = createSSLInsecureClient(); } HttpGet httpget = new HttpGet(url); // HttpGet设置请求头的两种种方式 // httpget.addHeader(new BasicHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)); // httpget.addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;); Header[] heads = httpget.getAllHeaders(); for (int i = 0; i &lt; heads.length; i++) { System.out.println(heads[i].getName() + &quot;--&gt;&quot; + heads[i].getValue()); } CloseableHttpResponse response = httpClient.execute(httpget); // 判断状态行 if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { HttpEntity entity = response.getEntity(); if (entity != null) { String out = EntityUtils.toString(entity, &quot;UTF-8&quot;); return out; } } } catch (ClientProtocolException e) { e.printStackTrace(); return null; } catch (IOException e) { e.printStackTrace(); return null; } finally { try { if (null != httpClient) { httpClient.close(); } } catch (IOException e) { log.error(&quot;httpClient.close()异常&quot;); } } return null; } /** * 发送POST请求 * @param isHttps 是否https * @param url 请求地址 * @param data 请求实体内容 * @param contentType 请求实体内容的类型 * @return 响应结果 */ public static String post(boolean isHttps, String url, String data, String contentType) { CloseableHttpClient httpClient = null; try { if (!isHttps) { httpClient = HttpClients.createDefault(); } else { httpClient = createSSLInsecureClient(); } HttpPost httpPost = new HttpPost(url); // HttpPost设置请求头的两种种方式 //httpPost.addHeader(new BasicHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;)); //httpPost.addHeader(&quot;Connection&quot;, &quot;Keep-Alive&quot;); // UrlEncodedFormEntity处理键值对格式请求参数 //List&lt;BasicNameValuePair&gt; list = new ArrayList&lt;BasicNameValuePair&gt;(); //new UrlEncodedFormEntity(list, &quot;UTF-8&quot;); if (null != data) { // StringEntity处理任意格式字符串请求参数 StringEntity stringEntity = new StringEntity(data, &quot;UTF-8&quot;); stringEntity.setContentEncoding(&quot;UTF-8&quot;); if (null != contentType) { stringEntity.setContentType(contentType); } else { stringEntity.setContentType(&quot;application/json&quot;); } httpPost.setEntity(stringEntity); } // 设置请求和传输超时时间 RequestConfig requestConfig = RequestConfig.custom().setSocketTimeout(2000).setConnectTimeout(2000).build(); httpPost.setConfig(requestConfig); HttpResponse response = httpClient.execute(httpPost); if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { HttpEntity entity = response.getEntity(); if (entity != null) { String out = EntityUtils.toString(entity, &quot;UTF-8&quot;); return out; } } } catch (UnsupportedEncodingException e) { log.error(e); } catch (ClientProtocolException e) { e.printStackTrace(); log.error(&quot;连接超时：&quot; + url); } catch (IOException e) { e.printStackTrace(); log.error(&quot;IO异常:&quot; + url); } finally { try { if (null != httpClient) { httpClient.close(); } } catch (IOException e) { log.error(&quot;httpClient.close()异常&quot;); } } return null; } /** * Https请求对象，信任所有证书 * * @return CloseableHttpClient */ public static CloseableHttpClient createSSLInsecureClient() { try { SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustStrategy() { // 信任所有 public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException { return true; } }).build(); SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslContext); return HttpClients.custom().setSSLSocketFactory(sslsf).build(); } catch (KeyManagementException e) { e.printStackTrace(); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyStoreException e) { e.printStackTrace(); } return HttpClients.createDefault(); } public static void main(String[] args) { String restu = get(true, &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=wx169c72abdb70cdab&amp;secret=55a4b77eda664e183881e5ed9cce189a&quot;); System.out.println(restu); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,HttpClient","slug":"Java-HttpClient","permalink":"/tags/Java-HttpClient/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用Gson处理Json数据","slug":"Java核心基础之--使用Gson处理Json数据","date":"2020-06-06T09:15:10.000Z","updated":"2023-04-30T10:21:41.347Z","comments":true,"path":"2020/06/06/Java核心基础之--使用Gson处理Json数据/","link":"","permalink":"/2020/06/06/Java核心基础之--使用Gson处理Json数据/","excerpt":"","text":"Gson简介Gson（又称Google Json）是Google公司发布的一个开放源代码的Java库，用于序列化Java对象为JSON字符串，或反序列化JSON字符串成Java对象。 目前，在Java中处理JSON数据的类库中有以下三个比较流行：FastJSON、Gson和Jackson。与FastJSON和Jackson相比，Gson虽然在性能方面略显不足，但在功能上，它无疑是三者之中功能最强大的（使用Gson我们可以更加灵活地配置对象的哪些字段需要序列化）。 Gson的用法Gson.jar的MVN下载地址：http://mvnrepository.com/artifact/com.google.code.gson/gson 在Gson类库中有一个Gson类，这个Gson类提供了两个方法：toJson() 和 fromJson()，我们主要就是调用这两个方法来分别实现Java对象的序列化和JSON字符串的反序列化。 下面我们通过几个简单的代码示例来对Gson类的常用方法做一个简单介绍。 首先，创建两个JavaBean类：Student和Teacher，来充当需要被转换的Java对象。 import java.io.Serializable; import java.util.Date; import com.google.gson.annotations.Expose; import com.google.gson.annotations.SerializedName; import com.google.gson.annotations.Since; import com.google.gson.annotations.Until; public class Student implements Serializable { private static final long serialVersionUID = 6L; @SerializedName(&quot;number&quot;) @Expose(serialize = true, deserialize = true) private int id; @Expose(serialize = true, deserialize = true) private String name; @Expose(serialize = true, deserialize = true) private int age; @Expose(serialize = true, deserialize = true) private Gender gender; @Until(1.1) private Date enrollmentDate; @Since(1.8) private Date graduationDate; public Student(int id, String name, int age) { super(); this.id = id; this.name = name; this.age = age; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Gender getGender() { return gender; } public Date getEnrollmentDate() { return enrollmentDate; } public void setEnrollmentDate(Date enrollmentDate) { this.enrollmentDate = enrollmentDate; } public Date getGraduationDate() { return graduationDate; } public void setGraduationDate(Date graduationDate) { this.graduationDate = graduationDate; } public void setGender(Gender gender) { this.gender = gender; } public String toString() { return &quot;{number:&quot; + this.id + &quot;,name:&quot; + this.name + &quot;,age:&quot; + this.age + (null == this.gender ? &quot;&quot; : &quot;,gender:&quot;+this.gender+&quot;,&quot;) + &quot;}&quot;; } } import java.util.List; import com.google.gson.annotations.SerializedName; public class Teacher { @SerializedName(&quot;teacherId&quot;) private int id; private String name; private List&lt;Student&gt; students; public Teacher(int id, String name, List&lt;Student&gt; students) { super(); this.id = id; this.name = name; this.students = students; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;Student&gt; getStudents() { return students; } public void setStudents(List&lt;Student&gt; students) { this.students = students; } public String toString() { return &quot;{teacherId:&quot; + this.id + &quot;,name:&quot; + this.name + &quot;,students:&quot; + this.students + &quot;}&quot;; } } 其中，Gender（性別）是一个枚举类，定义如下。 public enum Gender { MALE/* 男 */, FEMALE/* 女 */ } 在使用Gson前需要先创建一个Gson对象，有以下两种创建方式： private static final Gson gson1 = new Gson(); //方式一 private static final Gson gson2 = new GsonBuilder().create(); //方式二 使用方式一：创建的Gson对象一般多用在那些不需要对序列化的字段进行详细配置的情况； 使用方式二：创建的Gson对象能够根据字段的类型、字段名称、版本、注解等信息去决定哪些字段需要进行序列化和反序列化，同时还能实现许多其他的个性化配置功能，配置方法详见GsonTest。 以下是GsonTest测试类的完整代码。 import java.util.ArrayList; import java.util.Date; import java.util.HashMap; import java.util.LinkedHashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import org.junit.Test; import com.google.gson.FieldNamingPolicy; import com.google.gson.Gson; import com.google.gson.GsonBuilder; import com.google.gson.reflect.TypeToken; public class GsonTest { private static final Gson gson1 = new Gson(); private static final Gson gson2 = new GsonBuilder() // 美化输出结果 .setPrettyPrinting() // 设置日期格式 .setDateFormat(&quot;yyyy年MM月dd日-HH时mm分ss秒&quot;) // 为Student类注册StudentTypeAdapter,定制序列化和反序列化规则 .registerTypeAdapter(Student.class, new StudentTypeAdapter()) // 设置字段的命名规则，对使用@SerializedName注解的字段无效 .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE) // 设置排除策略 .setExclusionStrategies(new MyExclusionStrategy(Gender.class)) // 仅序列化和反序列化带有@Expose注解的字段 // 注解格式：@Expose (serialize = false, deserialize = false) // .excludeFieldsWithoutExposeAnnotation() // 序列化空值，默认空值不会序列化 // .serializeNulls() // 开启版本控制，与@Until、@Since注解配合使用 .setVersion(1.7) // 启用对Map中复杂对象的序列化支持 .enableComplexMapKeySerialization().create(); private static final Gson gson3 = new GsonBuilder() // 美化输出结果 .setPrettyPrinting() // 设置日期格式 .setDateFormat(&quot;yyyy年MM月dd日-HH时mm分ss秒&quot;).registerTypeAdapter(Gender.class, new GenderSerializer()) // 仅序列化和反序列化带有@Expose注解的字段 // 注解格式：@Expose (serialize = false, deserialize = false) .excludeFieldsWithoutExposeAnnotation().create(); @Test public void testGson1() { Student user1 = new Student(9527, &quot;瓦力&quot;, 16); Student user2 = new Student(89757, &quot;雪莉&quot;, 14); // 将对象转换为json字符串 String userStr = gson1.toJson(user1); System.out.println(userStr); List&lt;Student&gt; userList = new ArrayList&lt;Student&gt;(); userList.add(user1); userList.add(user2); // 将对象集合转换为json字符串 String listStr = gson1.toJson(userList); System.out.println(listStr); Teacher teacher = new Teacher(200802, &quot;潮歌&quot;, userList); // 将对象转换为json字符串 String jsonStr = gson1.toJson(teacher); System.out.println(jsonStr); // 将json字符串还原为对象 Student user = gson1.fromJson(userStr, Student.class); System.out.println(user); // 将json字符串还原为对象集合 List&lt;Student&gt; users = gson1.fromJson(listStr, new TypeToken&lt;List&lt;Student&gt;&gt;() { }.getType()); System.out.println(users); } @Test public void testGson2() { Student user1 = new Student(9527, &quot;瓦力&quot;, 16); Student user2 = new Student(89757, &quot;雪莉&quot;, 14); user1.setEnrollmentDate(new Date()); user1.setGraduationDate(new Date()); // 将对象转换为json字符串 String userStr = gson2.toJson(user1); System.out.println(userStr); List&lt;Student&gt; userList = new ArrayList&lt;Student&gt;(); userList.add(user1); userList.add(user2); // 将对象集合转换为json字符串 String listStr = gson2.toJson(userList); System.out.println(listStr); // 为保证对象序列化时的顺序，此处使用LinkedHashMap Map&lt;String, Student&gt; map = new LinkedHashMap&lt;String, Student&gt;(); map.put(user1.getName(), user1); map.put(user2.getName(), user2); // 将对象Map转换为json字符串 String mapStr = gson2.toJson(map); System.out.println(mapStr); Map&lt;String, Student&gt; retMap = gson2.fromJson(mapStr, new TypeToken&lt;Map&lt;String, Student&gt;&gt;() { }.getType()); for (Entry&lt;String, Student&gt; entry : retMap.entrySet()) { System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); } } @Test public void testGson3() { Student user1 = new Student(9527, &quot;瓦力&quot;, 16); Student user2 = new Student(89757, &quot;雪莉&quot;, 14); user1.setGender(Gender.MALE); user2.setGender(Gender.FEMALE); // 将对象转换为json字符串 String userStr = gson3.toJson(user1); System.out.println(userStr); List&lt;Student&gt; userList = new ArrayList&lt;Student&gt;(); userList.add(user1); userList.add(user2); // 将对象集合转换为json字符串 String listStr = gson3.toJson(userList); System.out.println(listStr); Map&lt;String, Student&gt; map = new HashMap&lt;String, Student&gt;(); map.put(user1.getName(), user1); map.put(user2.getName(), user2); // 将对象Map转换为json字符串 String mapStr = gson3.toJson(map); System.out.println(mapStr); Map&lt;String, Student&gt; retMap = gson3.fromJson(mapStr, new TypeToken&lt;Map&lt;String, Student&gt;&gt;() { }.getType()); for (Entry&lt;String, Student&gt; entry : retMap.entrySet()) { System.out.println(entry.getKey() + &quot;:&quot; + entry.getValue()); } } } 其中StudentTypeAdapter用来自定义Student对象的序列化和反序列化过程。 import java.io.IOException; import java.util.regex.Matcher; import java.util.regex.Pattern; import com.google.gson.TypeAdapter; import com.google.gson.stream.JsonReader; import com.google.gson.stream.JsonToken; import com.google.gson.stream.JsonWriter; public class StudentTypeAdapter extends TypeAdapter&lt;Student&gt; { private static Pattern pattern = Pattern.compile(&quot;:{1}([^\\\\{]*?)(,{1}|\\\\}{1})&quot;); @Override public Student read(JsonReader reader) throws IOException { if (reader.peek() == JsonToken.NULL) { reader.nextNull(); return null; } String jsonStr = reader.nextString(); Matcher m = pattern.matcher(jsonStr); String[] arr = new String[3]; int i = 0; while (m.find()) { arr[i++] = m.group(1); } Student student = new Student(Integer.parseInt(arr[0]), arr[1], Integer.parseInt(arr[2])); return student; } @Override public void write(JsonWriter writer, Student student) throws IOException { if (null == student) { writer.nullValue(); return; } String jsonStr = &quot;{student:{number:&quot; + student.getId() + &quot;,name:&quot; + student.getName() + &quot;,age:&quot; + student.getAge() + &quot;}}&quot;; writer.value(jsonStr); } } MyExclusionStrategy通过shouldSkipClass()和shouldSkipField()两个方法来指定某个类或者字段是否需要被序列化或者反序列化。 import com.google.gson.ExclusionStrategy; import com.google.gson.FieldAttributes; public class MyExclusionStrategy implements ExclusionStrategy { private Class&lt;?&gt; excludedClass; public MyExclusionStrategy(Class&lt;?&gt; clazz) { this.excludedClass = clazz; } @Override public boolean shouldSkipClass(Class&lt;?&gt; clazz) { return excludedClass.equals(clazz); } @Override public boolean shouldSkipField(FieldAttributes f) { return f.getName().equalsIgnoreCase(&quot;age&quot;); } } GenderSerializer通过GenderSerializer()和deserialize()两个方法来对Gender枚举类型的序列化和反序列化过程进行设置。 import java.lang.reflect.Type; import com.google.gson.JsonDeserializationContext; import com.google.gson.JsonDeserializer; import com.google.gson.JsonElement; import com.google.gson.JsonParseException; import com.google.gson.JsonPrimitive; import com.google.gson.JsonSerializationContext; import com.google.gson.JsonSerializer; public class GenderSerializer implements JsonSerializer&lt;Gender&gt;, JsonDeserializer&lt;Gender&gt; { @Override public JsonElement serialize(Gender gender, Type genderType, JsonSerializationContext context) { if (null == gender) { return new JsonPrimitive(&quot;&quot;); } return new JsonPrimitive(gender.equals(Gender.MALE) ? &quot;男&quot; : &quot;女&quot;); } @Override public Gender deserialize(JsonElement gender, Type genderType, JsonDeserializationContext context) throws JsonParseException { if (&quot;男&quot;.equals(gender.getAsString())) { return Gender.MALE; } else if (&quot;女&quot;.equals(gender.getAsString())) { return Gender.FEMALE; } else { return null; } } } testGson1()的执行结果： {&quot;number&quot;:9527,&quot;name&quot;:&quot;瓦力&quot;,&quot;age&quot;:16} [{&quot;number&quot;:9527,&quot;name&quot;:&quot;瓦力&quot;,&quot;age&quot;:16},{&quot;number&quot;:89757,&quot;name&quot;:&quot;雪莉&quot;,&quot;age&quot;:14}] {&quot;teacherId&quot;:200802,&quot;name&quot;:&quot;潮歌&quot;,&quot;students&quot;:[{&quot;number&quot;:9527,&quot;name&quot;:&quot;瓦力&quot;,&quot;age&quot;:16},{&quot;number&quot;:89757,&quot;name&quot;:&quot;雪莉&quot;,&quot;age&quot;:14}]} {number:9527,name:瓦力,age:16} [{number:9527,name:瓦力,age:16}, {number:89757,name:雪莉,age:14}] testGson2()的执行结果： &quot;{student:{number:9527,name:瓦力,age:16}}&quot; [ &quot;{student:{number:9527,name:瓦力,age:16}}&quot;, &quot;{student:{number:89757,name:雪莉,age:14}}&quot; ] { &quot;瓦力&quot;: &quot;{student:{number:9527,name:瓦力,age:16}}&quot;, &quot;雪莉&quot;: &quot;{student:{number:89757,name:雪莉,age:14}}&quot; } 瓦力:{number:9527,name:瓦力,age:16} 雪莉:{number:89757,name:雪莉,age:14} testGson3()的执行结果： { &quot;number&quot;: 9527, &quot;name&quot;: &quot;瓦力&quot;, &quot;age&quot;: 16, &quot;gender&quot;: &quot;男&quot; } [ { &quot;number&quot;: 9527, &quot;name&quot;: &quot;瓦力&quot;, &quot;age&quot;: 16, &quot;gender&quot;: &quot;男&quot; }, { &quot;number&quot;: 89757, &quot;name&quot;: &quot;雪莉&quot;, &quot;age&quot;: 14, &quot;gender&quot;: &quot;女&quot; } ] { &quot;雪莉&quot;: { &quot;number&quot;: 89757, &quot;name&quot;: &quot;雪莉&quot;, &quot;age&quot;: 14, &quot;gender&quot;: &quot;女&quot; }, &quot;瓦力&quot;: { &quot;number&quot;: 9527, &quot;name&quot;: &quot;瓦力&quot;, &quot;age&quot;: 16, &quot;gender&quot;: &quot;男&quot; } } 雪莉:{number:89757,name:雪莉,age:14,gender:FEMALE,} 瓦力:{number:9527,name:瓦力,age:16,gender:MALE,}","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Gson,Json","slug":"Java-Gson-Json","permalink":"/tags/Java-Gson-Json/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"使用Dom4j解析XML","slug":"Java核心基础之--使用Dom4j解析XML","date":"2020-06-06T09:14:10.000Z","updated":"2023-04-30T10:21:41.347Z","comments":true,"path":"2020/06/06/Java核心基础之--使用Dom4j解析XML/","link":"","permalink":"/2020/06/06/Java核心基础之--使用Dom4j解析XML/","excerpt":"","text":"一、Dom4j简介dom4j是一个Java的XML API，是jdom的升级品，用来读写XML文件的。dom4j是一个十分优秀的JavaXML API，具有性能优异、功能强大和极其易使用的特点，它的性能超过sun公司官方的dom技术，同时它也是一个开放源代码的软件，可以在SourceForge上找到它。在IBM developerWorks上面还可以找到一篇文章，对主流的Java XML API进行的性能、功能和易用性的评测，所以可以知道dom4j无论在哪个方面都是非常出色的。如今可以看到越来越多的Java软件都在使用dom4j来读写XML，特别值得一提的是连Sun的JAXM也在用dom4j。这已经是必须使用的jar包， Hibernate也用它来读写配置文件。 二、文件下载官网地址：http://www.dom4j.org/dom4j-1.6.1/ 三、在Java中使用Dom4j解析XML创建Document对象在DOM4j中，Document对象就代表了整个XML文档，其内部将XML的数据信息以Dom4j树的形式进行储存。 我们可以通过以下三种方式来获得Document对象： // 读取XML文件,获得document对象 SAXReader saxReader = new SAXReader(); Document document1 = saxReader.read(new File(&quot;D:\\\\dom4j\\\\dom.xml&quot;)); // 解析XML形式的字符串,得到document对象. String xmlText = &quot;&lt;response&gt;&lt;result&gt;1&lt;/result&gt;&lt;desc&gt;保存成功&lt;/desc&gt;&lt;/response&gt;&quot;; Document document2 = DocumentHelper.parseText(xmlText); //主动创建document对象 Document document3 =DocumentHelper.createDocument(DocumentHelper.createElement(&quot;root&quot;).addAttribute(&quot;id&quot;, &quot;1&quot;)); System.out.println(document3.getRootElement().attributeValue(&quot;id&quot;)); //打印结果：1 操作节点对象在DOM4j中，使用Element对象来表示Dom4j树中的各个节点，Element对象可以包含有属性、文本内容、命名空间、子节点等内容。 我们通过以对一个名为“dom.xml”的XML文件的操作为例，来对DOM4j节点操作的常用方法进行简要示范，该“dom.xml”的内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;response&gt; &lt;result&gt;1&lt;/result&gt; &lt;errorDesc&gt;无错误信息&lt;/errorDesc&gt; &lt;errorCode&gt;E000&lt;/errorCode&gt; &lt;assignIds&gt; &lt;assignId&gt;TEST106608821&lt;/assignId&gt; &lt;assignId&gt;TEST106608822&lt;/assignId&gt; &lt;assignId&gt;TEST106608823&lt;/assignId&gt; &lt;/assignIds&gt; &lt;/response&gt; 通过Java代码来操作DOM4j的节点对象，其完整代码如下。 import java.io.FileOutputStream; import java.io.IOException; import java.io.OutputStreamWriter; import java.util.Iterator; import java.util.List; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import org.dom4j.io.XMLWriter; public class HelloDom4j { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws DocumentException, IOException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(&quot;D:\\\\dom4j\\\\dom.xml&quot;); // 获取Document对象的根节点 Element root = document.getRootElement(); System.out.println(root.getName()); // 取得根节点下的&quot;assignIds&quot;子节点 Element assignIds = root.element(&quot;assignIds&quot;); System.out.println(assignIds.getName()); // 取得&quot;assignIds&quot;节点下所有名为&quot;assignId&quot;的子节点，并进行遍历 List&lt;Element&gt; elements = assignIds.elements(&quot;assignId&quot;); Iterator&lt;Element&gt; it = elements.iterator(); while (it.hasNext()) { Element element = it.next(); // 打印节点的文本内容 System.out.println(element.getText()); } // 在&quot;assignIds&quot;节点下再添加一个&quot;assignId&quot;子节点 Element element = assignIds.addElement(&quot;assignId&quot;); // 设置新节点的文本内容 element.setText(&quot;TEST106608824&quot;); // 删除&quot;assignIds&quot;节点下第一个名为&quot;assignId&quot;的子节点 Element firstAssingId = assignIds.element(&quot;assignId&quot;); assignIds.remove(firstAssingId); // 添加一个CDATA节点 Element cddataElement = root.addElement(&quot;content&quot;); cddataElement.addCDATA(&quot;我是CDATA的内容!&quot;); // 将Document对象内容保存到XML文件 XMLWriter xmlWriter = new XMLWriter(new OutputStreamWriter(new FileOutputStream(&quot;D:\\\\dom4j\\\\dom4j_dom.xml&quot;), &quot;UTF-8&quot;)); xmlWriter.write(document); xmlWriter.close(); } } 程序执行完毕之后，在计算机“D:\\dom4j”目录下会自动创建一个名为“dom4j_dom.xml”的XML文件，其内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;response&gt; &lt;result&gt;1&lt;/result&gt; &lt;errorDesc&gt;无错误信息&lt;/errorDesc&gt; &lt;errorCode&gt;E000&lt;/errorCode&gt; &lt;assignIds&gt; &lt;assignId&gt;TEST106608822&lt;/assignId&gt; &lt;assignId&gt;TEST106608823&lt;/assignId&gt; &lt;assignId&gt;TEST106608824&lt;/assignId&gt; &lt;/assignIds&gt; &lt;content&gt;&lt;![CDATA[我是CDATA的内容!]]&gt;&lt;/content&gt; &lt;/response&gt; 操作节点对象的属性我们还是通过对一个XML文件的实际操作为例，来对DOM4j节点对象的属性操作的常用方法进行简要示范。在计算机“D:\\dom4j”目录下有一个名为“attribute.xml”的XML文件，其内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;Request service=&#39;OrderSearchService&#39; lang=&#39;zh-CN&#39;&gt; &lt;Head name=&#39;head&#39;&gt;Hello Dom4j&lt;/Head&gt; &lt;Body name=&#39;body&#39; class=&quot;content&quot;&gt; &lt;OrderSearch name=&#39;orderSearch&#39; orderid=&#39;2019586321&#39;/&gt; &lt;/Body&gt; &lt;/Request&gt; 通过Java代码来操作DOM4j节点对象的属性，其完整代码如下。 import java.io.FileWriter; import java.io.IOException; import java.util.Iterator; import org.dom4j.Attribute; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import org.dom4j.io.XMLWriter; public class HelloDom4j { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) throws DocumentException, IOException { SAXReader saxReader = new SAXReader(); Document document = saxReader.read(&quot;D:\\\\dom4j\\\\attribute.xml&quot;); // 获取根节点 Element root = document.getRootElement(); System.out.println(root.getName()); // 打印结果：Request // 获取根节点的&quot;service&quot;属性 Attribute attribute = root.attribute(&quot;service&quot;); // 获取并打印属性的值 System.out.println(attribute.getText()); // 打印结果：OrderSearchService System.out.println(attribute.getData()); // 打印结果：OrderSearchService System.out.println(attribute.getValue()); // 打印结果：OrderSearchService // 删除根节点的&quot;lang&quot;属性 Attribute lang = root.attribute(&quot;lang&quot;); System.out.println(lang.getData()); // 打印结果：zh-CN root.remove(attribute); // 为根节点添加&quot;id&quot;属性，并设置值为&quot;request&quot; root.addAttribute(&quot;id&quot;, &quot;request&quot;); // 获取&quot;Head&quot;节点 Element head = root.element(&quot;Head&quot;); // 修改&quot;Head&quot;节点的&quot;name&quot;属性值为&quot;dom4j&quot; Attribute nameAttr = head.attribute(&quot;name&quot;); System.out.println(nameAttr.getData());// 打印结果：head nameAttr.setValue(&quot;dom4j&quot;); System.out.println(nameAttr.getData());// 打印结果：dom4j // 获取&quot;OrderSearch&quot;节点 Element orderSearch = root.element(&quot;Body&quot;).element(&quot;OrderSearch&quot;); // 遍历&quot;OrderSearch&quot;节点的所有属性 Iterator&lt;Attribute&gt; it = orderSearch.attributeIterator(); while (it.hasNext()) { Attribute attr = it.next(); System.out.println(attr.getText()); // 打印结果：orderSearch 2019586321 } // 将Document对象内容保存到XML文件 XMLWriter xmlWriter = new XMLWriter(new FileWriter(&quot;D:\\\\dom4j\\\\dom4j_attribute.xml&quot;)); xmlWriter.write(document); xmlWriter.close(); } } 程序执行完毕之后，在计算机“D:\\dom4j”目录下会自动创建一个名为“dom4j_attribute.xml”的XML文件，其内容如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;Request lang=&quot;zh-CN&quot; id=&quot;request&quot;&gt; &lt;Head name=&quot;dom4j&quot;&gt;Hello Dom4j&lt;/Head&gt; &lt;Body name=&quot;body&quot; class=&quot;content&quot;&gt; &lt;OrderSearch name=&quot;orderSearch&quot; orderid=&quot;2019586321&quot;/&gt; &lt;/Body&gt; &lt;/Request&gt; 保存Document对象到XML文件// 无需设置字符集编码 XMLWriter xmlWriter = new XMLWriter(new FileWriter(&quot;D:\\\\dom4j\\\\dom4j_attribute.xml&quot;)); xmlWriter.write(document); xmlWriter.close(); // 需要设置字符集编码 OutputFormat format=OutputFormat.createPrettyPrint(); //createPrettyPrint()自动缩进,createCompactFormat()自动压缩 format.setEncoding(&quot;UTF-8&quot;); XMLWriter xmlWriter = new XMLWriter(new FileWriter(&quot;D:\\\\dom4j\\\\dom4j_attribute.xml&quot;),format); xmlWriter.write(document); xmlWriter.close(); 字符串与XML转换我们继续以前例中的“attribute.xml”文件为例，对其进行转换示范。 import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.DocumentHelper; import org.dom4j.Element; import org.dom4j.io.SAXReader; public class HelloDom4j { public static void main(String[] args) throws DocumentException { // 将XML转换为字符串 SAXReader saxReader = new SAXReader(); Document document = saxReader.read(&quot;D:\\\\dom4j\\\\attribute.xml&quot;); String documentStr = document.asXML(); System.out.println(documentStr); /* * 打印结果： * &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; * &lt;Request service=&quot;OrderSearchService&quot; lang=&quot;zh-CN&quot;&gt; * &lt;Head name=&quot;head&quot;&gt;Hello Dom4j&lt;/Head&gt; * &lt;Body name=&quot;body&quot; class=&quot;content&quot;&gt; * &lt;OrderSearch name=&quot;orderSearch&quot; orderid=&quot;2019586321&quot;/&gt; * &lt;/Body&gt; * &lt;/Request&gt; */ Element root = document.getRootElement(); String rootStr = root.asXML(); System.out.println(rootStr); /* * 打印结果： * &lt;Request service=&quot;OrderSearchService&quot; lang=&quot;zh-CN&quot;&gt; * &lt;Head name=&quot;head&quot;&gt;Hello Dom4j&lt;/Head&gt; * &lt;Body name=&quot;body&quot; class=&quot;content&quot;&gt; * &lt;OrderSearch name=&quot;orderSearch&quot; orderid=&quot;2019586321&quot;/&gt; * &lt;/Body&gt; * &lt;/Request&gt; */ // 将字符串转换为XML String xmlStr = &quot;&lt;Head name=&#39;head&#39;&gt;Hello Dom4j&lt;/Head&gt;&quot;; Document xmlDoc = DocumentHelper.parseText(xmlStr); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Dom4j,XML","slug":"Java-Dom4j-XML","permalink":"/tags/Java-Dom4j-XML/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--清空整个文件夹（目录）","slug":"Java核心基础之--清空整个文件夹（目录）","date":"2020-06-06T09:13:10.000Z","updated":"2023-04-30T10:21:41.353Z","comments":true,"path":"2020/06/06/Java核心基础之--清空整个文件夹（目录）/","link":"","permalink":"/2020/06/06/Java核心基础之--清空整个文件夹（目录）/","excerpt":"","text":"目标：清空整个文件夹 条件：file类、递归方法 备注：在Java中，如果想要删除一个文件夹，那么必须确保该文件下已被清空代码 package May.Eighth.File; import java.io.File; /** * 删除文件和目录（文件夹） * @author Jia * */ public class DeleteFileAndDirectory { public static void main(String[] args) { //调用delete方法 new DeleteFileAndDirectory().delete(&quot;E:/Javatest/test&quot;); System.out.println(&quot;该文件夹已清空完毕&quot;); } // 创建目录（文件夹）删除的方法 public void delete(String path) { // 为传进来的路径参数创建一个文件对象 File file = new File(path); // 如果目标路径是一个文件，那么直接调用delete方法删除即可 // file.delete(); // 如果是一个目录，那么必须把该目录下的所有文件和子目录全部删除，才能删除该目标目录，这里要用到递归函数 // 创建一个files数组，用来存放目标目录下所有的文件和目录的file对象 File[] files = new File[50]; // 将目标目录下所有的file对象存入files数组中 files = file.listFiles(); // 循环遍历files数组 for(File temp : files){. // 判断该temp对象是否为文件对象 if (temp.isFile()) { temp.delete(); } // 判断该temp对象是否为目录对象 if (temp.isDirectory()) { // 将该temp目录的路径给delete方法（自己），达到递归的目的 delete(temp.getAbsolutePath()); // 确保该temp目录下已被清空后，删除该temp目录 temp.delete(); } } } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,清空,文件夹","slug":"Java-清空-文件夹","permalink":"/tags/Java-清空-文件夹/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--项目路径的获取","slug":"Java核心基础之--项目路径的获取","date":"2020-06-06T09:12:10.000Z","updated":"2023-04-30T10:21:41.354Z","comments":true,"path":"2020/06/06/Java核心基础之--项目路径的获取/","link":"","permalink":"/2020/06/06/Java核心基础之--项目路径的获取/","excerpt":"","text":"一、相对路径的获得说明:相对路径(即不写明到底相对谁)均可通过以下方式获得（不论是一般的java项目还是web项目） String relativelyPath=System.getProperty(&quot;user.dir&quot;); 上述相对路径中，java项目中的文件是相对于项目的根目录；web项目中的文件路径视不同的web服务器不同而不同（tomcat是相对于 tomcat安装目录\\bin）。 二、类加载目录的获得类加载目录即当运行某一类时获得其装载目录。 1.1) 通用的方法一(不论是一般的java项目还是web项目,先定位到能看到包路径的第一级目录) InputStream is=TestAction.class.getClassLoader().getResourceAsStream(&quot;test.txt&quot;); (test.txt文件的路径为项目名\\src\\test.txt;类TestAction所在包的第一级目录位于src目录下)，上式中将TestAction，test.txt替换成对应成相应的类名和文件名字即可。 1.2) 通用方法二(此方法和1.1中的方法类似,不同的是此方法必须以’/‘开头,参考http://riddickbryant.iteye.com/blog/436693) InputStream is=Test1.class.getResourceAsStream(&quot;/test.txt&quot;); (test.txt文件的路径为项目名\\src\\test.txt,类Test1所在包的第一级目录位于src目录下) 三、web项目根目录的获得(发布之后)1 从servlet出发可建立一个servlet在其的init方法中写入如下语句 ServletContext s1=this.getServletContext(); String temp=s1.getRealPath(&quot;/&quot;); (关键) 结果形如：D:\\工具\\Tomcat-6.0\\webapps\\002_ext\\ (002_ext为项目名字) 如果是调用了s1.getRealPath(&quot;&quot;)则输出D:\\工具\\Tomcat-6.0\\webapps\\002_ext(少了一个”\\”) 2 从httpServletRequest出发String cp11111=request.getSession().getServletContext().getRealPath(&quot;/&quot;); 结果形如:D:\\工具\\Tomcat-6.0\\webapps\\002_ext\\ 四、classpath的获取(在Eclipse中为获得src或者classes目录的路径)方法一Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath() eg: String t=Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath(); System.out.println(&quot;t---&quot;+t); 输出:t---/E:/order/002_ext/WebRoot/WEB-INF/classes/ 方法二JdomParse.class.getClassLoader().getResource(&quot;&quot;).getPath() // JdomParse为src某一个包中的类,下同 eg: String p1=JdomParse.class.getClassLoader().getResource(&quot;&quot;).getPath(); System.out.println(&quot;JdomParse.class.getClassLoader().getResource--&quot;+p1); 输出: JdomParse.class.getClassLoader().getResource--/E:/order/002_ext/WebRoot/WEB-INF/classes/ 另外,如果想把文件放在某一包中,则可以 通过以下方式获得到文件(先定位到该包的最后一级目录) String p2=JdomParse.class.getResource(&quot;&quot;).getPath(); System.out.println(&quot;JdomParse.class.getResource---&quot;+p2); 输出: JdomParse.class.getResource---/E:/order/002_ext/WebRoot/WEB-INF/classes/jdom/ (JdomParse为src目录下jdom包中的类) 五、属性文件的读取方法一InputStream in = lnew BufferedInputStream( new FileInputStream(name)); Properties p = new Properties(); p.load(in); 注意路径的问题,做执行之后就可以调用p.getProperty(&quot;name&quot;)得到对应属性的值 方法二Locale locale = Locale.getDefault(); ResourceBundle localResource = ResourceBundle.getBundle(&quot;test/propertiesTest&quot;, locale); String value = localResource.getString(&quot;test&quot;); System.out.println(&quot;ResourceBundle: &quot; + value); 工程src目录下propertiesTest.properties(名字后缀必须为properties)文件内容如下:test=hello word","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,路径","slug":"Java-路径","permalink":"/tags/Java-路径/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--利用ShutdownHook释放系统资源","slug":"Java核心基础之--利用ShutdownHook释放系统资源","date":"2020-06-06T09:11:10.000Z","updated":"2023-04-30T10:21:41.350Z","comments":true,"path":"2020/06/06/Java核心基础之--利用ShutdownHook释放系统资源/","link":"","permalink":"/2020/06/06/Java核心基础之--利用ShutdownHook释放系统资源/","excerpt":"","text":"参考书籍：《Java特种兵（上册）》 当发生 System.exit(int status) 时，希望在系统退出前，执行一点任务来做一些资源方面的回收操作，ShutdownHook 可以达到这个目的，它利用 hook 的思路来实现，有些时候也把它叫作“钩子”。 假如在系统中通过 Runtime.getRuntime().exec(String command) 或 new ProcessBuilder(List&lt;String&gt; command) 启动了子进程（Process），这个子进程一直在运行中，在当前进程退出时，子进程未必会退出，但此时业务上希望将它退出，就可以利用 ShutdownHook 。例如下面这个测试样例： public class ShutdownHookTest { public static void main(String[] args) { Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() { public void run() { System.out.println(&quot;执行ShutdownHook钩子操作，释放系统资源...&quot;); } })); Runtime.getRuntime().removeShutdownHook(new Thread()); System.exit(1); System.out.println(&quot;主进程结束...&quot;); } } 执行结果： 主进程结束...执行ShutdownHook钩子操作，释放系统资源... 注意：传入参数是通过 new Thread() 创建的线程对象，在Java进程调用 exit() 时，会调用该线程对象的 start()方法将其运行起来，所以不要手工先启动了。另外，这种回调线程就不要设定为死循环程序，否则就无法退出了。 ShutdownHook执行原理java.lang包下有一个Shutdown 类，提供了一个 Runnable[] hooks 数组，数组的长度为10，也就是最多定义10个hook（这与程序写入多少个线程回调没有关系），提供 add() 方法来注册新的 hook 对象。 // The system shutdown hooks are registered with a predefined slot. // The list of shutdown hooks is as follows: // (0) Console restore hook // (1) Application hooks // (2) DeleteOnExit hook private static final int MAX_SYSTEM_HOOKS = 10; private static final Runnable[] hooks = new Runnable[MAX_SYSTEM_HOOKS]; /* Add a new shutdown hook. Checks the shutdown state and the hook itself, * but does not do any security checks. */ static void add(int slot, Runnable hook) { synchronized (lock) { if (state &gt; RUNNING) throw new IllegalStateException(&quot;Shutdown in progress&quot;); if (hooks[slot] != null) throw new InternalError(&quot;Shutdown hook at slot &quot; + slot + &quot; already registered&quot;); hooks[slot] = hook; } } 在java.lang.ApplicationShutdownHooks 的 static 匿名块中，通过 add() 方法注册了一个hook ，在 run() 方法内部运行内部的静态方法 runHooks() ，它内部用一个 IdentityHashMap 来存放 hook 信息，可以通过 add() 方法来添加，而程序中定义的回调线程都放在了这里，它自身用 hook 的形式存在于 hooks 列表当中。 package java.lang; import java.util.*; /* * Class to track and run user level shutdown hooks registered through * &lt;tt&gt;{@link Runtime#addShutdownHook Runtime.addShutdownHook}&lt;/tt&gt;. * * @see java.lang.Runtime#addShutdownHook * @see java.lang.Runtime#removeShutdownHook */ class ApplicationShutdownHooks { static { Shutdown.add(1 /* shutdown hook invocation order */, new Runnable() { public void run() { runHooks(); } }); } /* The set of registered hooks */ private static IdentityHashMap&lt;Thread, Thread&gt; hooks = new IdentityHashMap&lt;Thread, Thread&gt;(); private void ApplicationShutdownHooks() {} /* Add a new shutdown hook. Checks the shutdown state and the hook itself, * but does not do any security checks. */ static synchronized void add(Thread hook) { if(hooks == null) throw new IllegalStateException(&quot;Shutdown in progress&quot;); if (hook.isAlive()) throw new IllegalArgumentException(&quot;Hook already running&quot;); if (hooks.containsKey(hook)) throw new IllegalArgumentException(&quot;Hook previously registered&quot;); hooks.put(hook, hook); } /* Remove a previously-registered hook. Like the add method, this method * does not do any security checks. */ static synchronized boolean remove(Thread hook) { if(hooks == null) throw new IllegalStateException(&quot;Shutdown in progress&quot;); if (hook == null) throw new NullPointerException(); return hooks.remove(hook) != null; } /* Iterates over all application hooks creating a new thread for each * to run in. Hooks are run concurrently and this method waits for * them to finish. */ static void runHooks() { Collection&lt;Thread&gt; threads; synchronized(ApplicationShutdownHooks.class) { threads = hooks.keySet(); hooks = null; } for (Thread hook : threads) { hook.start(); } for (Thread hook : threads) { try { hook.join(); } catch (InterruptedException x) { } } } } 当调用 Runtime.getRuntime().addShutdownHook(Thread hook)方法时，会间接调用 ApplicationShutdownHooks.add(Thread hook)将线程放到IdentityHashMap 中，Runtime.getRuntime().removeShutdownHook(Thread)用于删除一个钩子线程。 public void addShutdownHook(Thread hook) { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;)); } ApplicationShutdownHooks.add(hook); } public boolean removeShutdownHook(Thread hook) { SecurityManager sm = System.getSecurityManager(); if (sm != null) { sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;)); } return ApplicationShutdownHooks.remove(hook); } 当调用 System.exit(int status)方法时，会间接调用 Shutdown.exit(int status)方法，再调用sequence()--&gt;runHooks() 方法。 /* Invoked by Runtime.exit, which does all the security checks. * Also invoked by handlers for system-provided termination events, * which should pass a nonzero status code. */ static void exit(int status) { boolean runMoreFinalizers = false; synchronized (lock) { if (status != 0) runFinalizersOnExit = false; switch (state) { case RUNNING: /* Initiate shutdown */ state = HOOKS; break; case HOOKS: /* Stall and halt */ break; case FINALIZERS: if (status != 0) { /* Halt immediately on nonzero status */ halt(status); } else { /* Compatibility with old behavior: * Run more finalizers and then halt */ runMoreFinalizers = runFinalizersOnExit; } break; } } if (runMoreFinalizers) { runAllFinalizers(); halt(status); } synchronized (Shutdown.class) { /* Synchronize on the class object, causing any other thread * that attempts to initiate shutdown to stall indefinitely */ sequence(); halt(status); } } /* The actual shutdown sequence is defined here. * * If it weren&#39;t for runFinalizersOnExit, this would be simple -- we&#39;d just * run the hooks and then halt. Instead we need to keep track of whether * we&#39;re running hooks or finalizers. In the latter case a finalizer could * invoke exit(1) to cause immediate termination, while in the former case * any further invocations of exit(n), for any n, simply stall. Note that * if on-exit finalizers are enabled they&#39;re run iff the shutdown is * initiated by an exit(0); they&#39;re never run on exit(n) for n != 0 or in * response to SIGINT, SIGTERM, etc. */ private static void sequence() { synchronized (lock) { /* Guard against the possibility of a daemon thread invoking exit * after DestroyJavaVM initiates the shutdown sequence */ if (state != HOOKS) return; } runHooks(); boolean rfoe; synchronized (lock) { state = FINALIZERS; rfoe = runFinalizersOnExit; } if (rfoe) runAllFinalizers(); } /* Run all registered shutdown hooks */ private static void runHooks() { /* We needn&#39;t bother acquiring the lock just to read the hooks field, * since the hooks can&#39;t be modified once shutdown is in progress */ for (Runnable hook : hooks) { try { if (hook != null) hook.run(); } catch(Throwable t) { if (t instanceof ThreadDeath) { ThreadDeath td = (ThreadDeath)t; throw td; } } } } 循环中的一个hook对象就是由 ApplicationShutdownHooks 的匿名块定义的，因此会调用 ApplicationShutdownHooks 类的 run() 方法，再调用它的runHooks()方法，这个 runHooks()方法内容如下。 /* Iterates over all application hooks creating a new thread for each * to run in. Hooks are run concurrently and this method waits for * them to finish. */ static void runHooks() { Collection&lt;Thread&gt; threads; synchronized(ApplicationShutdownHooks.class) { threads = hooks.keySet(); hooks = null; } for (Thread hook : threads) { hook.start(); } for (Thread hook : threads) { try { hook.join(); } catch (InterruptedException x) { } } } 从这个方法中取出所有的Thread ，然后将线程启动起来，最后通过 join() 方法等待各个线程结束的动作，换句话说，在进程关闭前，对多个回调任务的处理方式是每个任务单独有一个线程处理，而不是所有的任务在一个线程中串行处理。 ShutdownHook适用场景 程序正常退出 使用System.exit() 终端使用Ctrl+C触发的中断 系统关闭 OutOfMemory宕机 使用Kill pid命令干掉进程（注：在使用kill -9 pid时，是不会被调用的）","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,ShutdownHook","slug":"Java-ShutdownHook","permalink":"/tags/Java-ShutdownHook/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--获取HttpServletRequest请求Body","slug":"Java核心基础之--获取HttpServletRequest请求Body","date":"2020-06-06T09:10:10.000Z","updated":"2023-04-30T10:21:41.353Z","comments":true,"path":"2020/06/06/Java核心基础之--获取HttpServletRequest请求Body/","link":"","permalink":"/2020/06/06/Java核心基础之--获取HttpServletRequest请求Body/","excerpt":"","text":"在实际开发过程中，经常需要从 HttpServletRequest 中读取HTTP请求的body内容，俗话说的好”好记性不如烂笔头“，特在此将其读取方法记录一下。 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import javax.servlet.ServletInputStream; import javax.servlet.http.HttpServletRequest; public class HttpServletRequestReader { // 字符串读取 // 方法一 public static String ReadAsChars(HttpServletRequest request) { BufferedReader br = null; StringBuilder sb = new StringBuilder(&quot;&quot;); try { br = request.getReader(); String str; while ((str = br.readLine()) != null) { sb.append(str); } br.close(); } catch (IOException e) { e.printStackTrace(); } finally { if (null != br) { try { br.close(); } catch (IOException e) { e.printStackTrace(); } } } return sb.toString(); } // 方法二 public static void ReadAsChars2(HttpServletRequest request) { InputStream is = null; try { is = request.getInputStream(); StringBuilder sb = new StringBuilder(); byte[] b = new byte[4096]; for (int n; (n = is.read(b)) != -1;) { sb.append(new String(b, 0, n)); } } catch (IOException e) { e.printStackTrace(); } finally { if (null != is) { try { is.close(); } catch (IOException e) { e.printStackTrace(); } } } } // 二进制读取 public static byte[] readAsBytes(HttpServletRequest request) { int len = request.getContentLength(); byte[] buffer = new byte[len]; ServletInputStream in = null; try { in = request.getInputStream(); in.read(buffer, 0, len); in.close(); } catch (IOException e) { e.printStackTrace(); } finally { if (null != in) { try { in.close(); } catch (IOException e) { e.printStackTrace(); } } } return buffer; } } 注意：HttpServletRequest 请求中的 body 内容仅能调用 request.getInputStream()， request.getReader()和request.getParameter(“key”) 方法读取一次，重复读取会报 java.io.IOException: Stream closed 异常。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,HttpServletRequest,Body","slug":"Java-HttpServletRequest-Body","permalink":"/tags/Java-HttpServletRequest-Body/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--二进制文件与十六进制字符串转化","slug":"Java核心基础之--二进制文件与十六进制字符串转化","date":"2020-06-06T09:09:10.000Z","updated":"2023-04-30T10:21:41.346Z","comments":true,"path":"2020/06/06/Java核心基础之--二进制文件与十六进制字符串转化/","link":"","permalink":"/2020/06/06/Java核心基础之--二进制文件与十六进制字符串转化/","excerpt":"","text":"本工具类主要用来将二进制文件读取并转换成十六进制字符串，并提供了将十六进制字符串还原为二进制文件的方法。 import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; import org.apache.log4j.Logger; public class HexStringUtils { private static final Logger logger = Logger.getLogger(HexStringUtils.class); private static final char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; }; private static final String hexString = &quot;0123456789ABCDEF&quot;; public static String toHexString(String filePath) throws FileNotFoundException, IOException { if (isEmptyStr(filePath)) { logger.error(&quot;invalid filePath parameter...&quot;); } return toHexString(new File(filePath)); } public static String toHexString(File file) throws FileNotFoundException, IOException { if (null == file || !file.exists() || file.isDirectory()) { logger.error(&quot;invalid file parameter...&quot;); } return toHexString(new FileInputStream(file)); } public static String toHexString(InputStream inputStream) throws IOException { byte[] bytes = inputStream2ByteArray(inputStream); return toHexString(bytes); } private static byte[] inputStream2ByteArray(InputStream in) throws IOException { ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] buffer = new byte[1024 * 4]; int n = 0; while ((n = in.read(buffer)) != -1) { out.write(buffer, 0, n); } return out.toByteArray(); } /* * Converts a byte array to hex string */ private static String toHexString(byte[] bytes) { StringBuffer buf = new StringBuffer(); int len = bytes.length; for (int i = 0; i &lt; len; i++) { byte2hex(bytes[i], buf); } return buf.toString(); } /* * Converts a byte to hex digit and writes to the supplied buffer */ private static void byte2hex(byte b, StringBuffer buf) { int high = ((b &amp; 0xf0) &gt;&gt; 4); int low = (b &amp; 0x0f); buf.append(hexChars[high]); buf.append(hexChars[low]); } /* * Converts a hex string to byte array */ private static byte[] convert2bytes(String stringOfHex) { if (isEmptyStr(stringOfHex)) { logger.error(&quot;invalid hex string parameter...&quot;); return null; } stringOfHex = stringOfHex.trim().toUpperCase(); if (stringOfHex.length() % 2 == 1) return null; int length = stringOfHex.length() / 2; byte[] bytes = new byte[length]; char[] charArray = stringOfHex.toCharArray(); for (int i = 0; i &lt; length; i++) { int pos = i * 2; bytes[i] = (byte) (charToByte(charArray[pos]) &lt;&lt; 4 | charToByte(charArray[pos + 1])); } return bytes; } /* * Converts a character to byte */ private static byte charToByte(char c) { return (byte) hexString.indexOf(c); } /* * Converts a byte array to file */ @SuppressWarnings(&quot;resource&quot;) public static void writeBytes2File(String filePath, byte[] bytes) throws IOException { File outputFile = new File(filePath); File parentFile = outputFile.getParentFile(); if (!parentFile.exists()) { parentFile.mkdirs(); } ByteBuffer bb = ByteBuffer.wrap(bytes); FileChannel fc = new FileOutputStream(outputFile).getChannel(); fc.write(bb); fc.close(); } /* * Determine whether a string is empty */ private static boolean isEmptyStr(String str) { return str == null || str.length() == 0; } public static void main(String[] args) throws FileNotFoundException, IOException { // 获取字体文件3D.TTF的16进制字符串 String filePath = &quot;D:/3D.TTF&quot;; long start = System.currentTimeMillis(); String hexStr = toHexString(filePath); System.out.println(hexStr); long end = System.currentTimeMillis(); System.out.println(end - start); // 将3D.TTF的16进制字符串还原为二进制文件 String newFilePath = &quot;D:/3D副本.TTF&quot;; start = System.currentTimeMillis(); byte[] bytes = convert2bytes(hexStr); writeBytes2File(newFilePath, bytes); end = System.currentTimeMillis(); System.out.println(end - start); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,二进制,十六进制","slug":"Java-二进制-十六进制","permalink":"/tags/Java-二进制-十六进制/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--数组初始化填充","slug":"Java核心基础之--数组初始化填充","date":"2020-06-06T09:08:10.000Z","updated":"2023-04-30T10:21:41.352Z","comments":true,"path":"2020/06/06/Java核心基础之--数组初始化填充/","link":"","permalink":"/2020/06/06/Java核心基础之--数组初始化填充/","excerpt":"","text":"对数组进行初始化填充import java.util.Arrays; public class ArrayFilling { public static void main(String[] args) { int[] scoreArr = new int[8]; // 创建一个大小为8的数组 Arrays.fill(scoreArr, 0); // 将数组使用数字 0 进行填充 for (int i = 0; i &lt; scoreArr.length; i++) { System.out.print(scoreArr[i] + &quot; &quot;); } System.out.print(&quot;&quot;); Arrays.fill(scoreArr, 2, 6, 1);// 将索引从 2 到 6 使用数字 1 进行填充 for (int i = 0; i &lt; scoreArr.length; i++) { System.out.print(scoreArr[i] + &quot; &quot;); } } } 打印结果： 0 0 0 0 0 0 0 00 0 1 1 1 1 0 0","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,数组,初始化","slug":"Java-数组-初始化","permalink":"/tags/Java-数组-初始化/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--打包 FatJar方法小结","slug":"Java核心基础之--打包 FatJar方法小结","date":"2020-06-06T09:07:10.000Z","updated":"2023-04-30T10:21:41.351Z","comments":true,"path":"2020/06/06/Java核心基础之--打包 FatJar方法小结/","link":"","permalink":"/2020/06/06/Java核心基础之--打包 FatJar方法小结/","excerpt":"","text":"转载自：https://yq.aliyun.com/articles/630208?utm_content=m_1000014409 在函数计算(Aliyun FC)中发布一个 Java 函数，往往需要将函数打包成一个 all-in-one 的 zip 包或者 jar 包。Java 中这种打包 all-in-one 的技术常称之为 Fatjar 技术。本文小结一下 Java 里打包 FatJar 的若干种方法。 什么是FatJarFatJar 又称作 uber-Jar，是包含所有依赖的 Jar 包。 Jar 包中嵌入了除 java 虚拟机以外的所有依赖。我们知道 Java 的依赖分为两种， 零散的 .class 文件和把多个 .class 文件以 zip 格式打包而成 jar 文件。FatJar 是一个 all-in-one Jar 包。FatJar 技术可以让那些用于最终发布的 Jar 便于部署和运行。 三种打包方法我们知道 .java 源码文件会被编译器编译成字节码.class 文件。Java 虚拟机执行的是 .class 文件。一个 java 程序可以有很多个 .class 文件。这些 .class 文件可以由 java 虚拟机的类装载器运行期装载到内存里。java 虚拟机可以从某个目录装载所有的 .class 文件，但是这些零散的.class 文件并不便于分发。所有 java 支持把零散的.class 文件打包成 zip 格式的 .jar 文件，并且虚拟机的类装载器支持直接装载 .jar 文件。 一个正常的 java 程序会有若干个.class 文件和所依赖的第三方库的 jar 文件组成。 非遮蔽方法（Unshaded）非遮蔽是相对于遮蔽而说的，可以理解为一种朴素的办法。解压所有 jar 文件，再重新打包成一个新的单独的 jar 文件。 借助 Maven Assembly Plugin 或 Gradle Java plugin 都可以轻松实现非遮蔽方法的打包。 Maven Assembly PluginMaven Assembly Plugin 是一个打包聚合插件，其主要功能是把项目的编译输出协同依赖，模块，文档和其他文件打包成一个独立的发布包。使用描述符（descriptor）来配置需要打包的物料组合。并预定义了常用的描述符，可供直接使用。 预定义描述符如下： bin 只打包编译结果，并包含 README, LICENSE 和 NOTICE 文件，输出文件格式为 tar.gz, tar.bz2 和 zip。 jar-with-dependencies 打包编译结果，并带上所有的依赖，如果依赖的是 jar 包，jar 包会被解压开，平铺到最终的 uber-jar 里去。输出格式为 jar。 src 打包源码文件。输出格式为 tar.gz, tar.bz2 和 zip。 project 打包整个项目，除了部署输出目录 target 以外的所有文件和目录都会被打包。输出格式为 tar.gz, tar.bz2 和 zip。 除了预定义的描述符，用户也可以指定描述符，以满足不同的打包需求。 打包成 uber-jar，需要使用预定义的 jar-with-dependencies 描述符： 在 pom.xml 中加入如下配置： &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;CHOOSE LATEST VERSION HERE&lt;/version&gt; &lt;configuration&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;assemble-all&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;single&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; Gradle Java plugingradle 下打包一个非遮蔽的 jar 包，有不少插件可以用，但是由于 gradle 自身的灵活性，可以直接用 groove 的 dsl 实现。 apply plugin: &#39;java&#39; jar { from { (configurations.runtime).collect { it.isDirectory() ? it : zipTree(it) } } } 注意：非遮蔽方法会把所有的 jar 包里的文件都解压到一个目录里，然后在打包同一个 fatjar 中。对于复杂应用很可能会碰到同名类相互覆盖问题。 遮蔽方法（Shaded）遮蔽方法会把依赖包里的类路径进行修改到某个子路径下，这样可以一定程度上避免同名类相互覆盖的问题。最终发布的 jar 也不会带入传递依赖冲突问题给下游。 Maven Shade Plugin在 pom.xml 中加入如下配置 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- put your configurations here --&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;shade&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; Gradle Shadow pluginGradle shadow plugin 使用非常简单，简单声明插件后就可以生效。 plugins { id &#39;com.github.johnrengelman.shadow&#39; version &#39;2.0.4&#39; id &#39;java&#39; } shadowJar { include &#39;*.jar&#39; include &#39;*.properties&#39; exclude &#39;a2.properties&#39; } 注意：遮蔽方法依赖修改 class 的字节码，更新依赖文件的包路径达到规避同名同包类冲突的问题，但是改名也会带来其他问题，比如代码中使用 Class.forName 或 ClassLoader.loadClass 装载的类，Shade Plugin 是感知不到的。同名文件覆盖问题也没法杜绝，比如 META-INF/services/javax.script.ScriptEngineFactory不属于类文件，但是被覆盖后会出现问题。 嵌套方法（Jar of Jars）还是一种办法就是在 jar 包里嵌套其他 jar，这个方法可以彻底避免解压同名覆盖的问题，但是这个方法不被 JVM 原生支持，因为 JDK 提供的 ClassLoader 仅支持装载嵌套 jar 包的 class 文件。所以这种方法需要自定义 ClassLoader 以支持嵌套 jar。 Onejar Maven PluginOne-JAR 就是一个基于上面嵌套 jar 实现的工具。onejar-maven-plugin 是社区基于 onejar 实现的 maven 插件。 &lt;plugin&gt; &lt;groupId&gt;com.jolira&lt;/groupId&gt; &lt;artifactId&gt;onejar-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.4&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;one-jar&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; Spring boot pluginOne-JAR 有点年久失修，好久没有维护了，Spring Boot 提供的 Maven Plugin 也可以打包 Fatjar，支持非遮蔽和嵌套的混合模式，并且支持 maven 和 gradle 。 &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;layout&gt;ZIP&lt;/layout&gt; &lt;requiresUnpack&gt; &lt;dependency&gt; &lt;groupId&gt;org.jruby&lt;/groupId&gt; &lt;artifactId&gt;jruby-complete&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/requiresUnpack&gt; &lt;/configuration&gt; &lt;/plugin&gt; plugins { id &#39;org.springframework.boot&#39; version &#39;2.0.4.RELEASE&#39; } bootJar { requiresUnpack &#39;**/jruby-complete-*.jar&#39; } requiresUnpack 参数可以定制那些 jar 不希望被解压，采用嵌套的方式打包到 Fatjar 内部。 其打包后的内部结构为： example.jar | +-META-INF | +-MANIFEST.MF +-org | +-springframework | +-boot | +-loader | +-&lt;spring boot loader classes&gt; +-BOOT-INF +-classes | +-mycompany | +-project | +-YourClasses.class +-lib +-dependency1.jar +-dependency2.jar 应用的类文件被放置到 BOOT-INF/classes 目录，依赖包被放置到 BOOT-INF/lib 目录。 查看 META-INF/MANIFEST.MF 文件，其内容为： Main-Class: org.springframework.boot.loader.JarLauncher Start-Class: com.mycompany.project.MyApplication 启动类是固定的 org.springframework.boot.loader.JarLauncher，应用程序的入口类需要配置成 Start-Class。这样做的目的主要是为了支持嵌套 jar 包的类装载，替换掉默认的 ClassLoader。 注意：但是函数计算 Java Runtime 需要的 jar 包是一种打包结构，在服务端运行时会解压开，./lib 目录加到 classpath 中，单不会调用 Main-Class。所以自定义 ClassLoader 是不生效的，所以不要使用嵌套 jar 结构，除非在入口函数指定重新定义 ClassLoader 或者 classpath 以支持 BOOT-INF/classes 和 BOOT-INF/lib 这样的定制化的类路径。 小结 单从 Fatjar 的角度看， Spring boot maven/gradle 做得最精致。但是 jar 包内部的自定义路径解压开以后和函数计算是不兼容的。所以如果用于函数计算打包，建议使用 Unshaded 或者 Shared 的打包方式，但是需要自己注意文件覆盖问题。 参考阅读https://imagej.net/Uber-JARhttps://softwareengineering.stackexchange.com/questions/297276/what-is-a-shaded-java-dependencyhttps://docs.spring.io/spring-boot/docs/current/reference/html/executable-jar.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,打包,FatJar","slug":"Java-打包-FatJar","permalink":"/tags/Java-打包-FatJar/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--本地方法","slug":"Java核心基础之--本地方法","date":"2020-06-06T09:06:10.000Z","updated":"2023-04-30T10:21:41.352Z","comments":true,"path":"2020/06/06/Java核心基础之--本地方法/","link":"","permalink":"/2020/06/06/Java核心基础之--本地方法/","excerpt":"","text":"一. 什么是本地方法简单地讲，一个本地方法（Native Method）就是一个Java调用非java代码的接口。 一个本地方法是这样一个java方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。 &quot;A native method is a Java method whose implementation is provided by non-java code.&quot; 在定义一个本地方法时，并不提供实现体（有些像定义一个java interface），因为其实现体是由非java语言在外面实现的。下面给了一个示例： public class IHaveNatives { native public void Native1( int x ) ; native static public long Native2() ; native synchronized private float Native3( Object o ) ; native void Native4( int[] ary ) throws Exception ; } 这些方法的声明描述了一些非java语音声明的方法在java代码里看起来像什么样子。 标识符native可以与所有其它的java标识符连用，但是abstract除外。这是合理的，因为native暗示这些方法是有实现体的，只不过这些实现体是非java的，但是abstract却显然的指明这些方法无实现体。native与其它java标识符连用时，其意义同非本地方法并无差别，比如native static表明这个方法可以在不产生类的实例时直接调用，这非常方便，比如当你想用一个本地方法去调用一个C的类库时。上面的第三个方法用到了native synchronized，JVM在进入这个方法的实现体之前会执行同步锁机制（就像java的多线程）。 一个本地方法可以返回任何java类型，包括非基本类型，而且同样可以进行异常控制。这些方法的实现体可以制一个异常并且将其抛出，这一点与java的方法非常相似。当一个本地方法接收到一些非基本类型时如Object或一个整型数组时，这个方法可以访问这非些基本型的内部，但是这将使这个native方法依赖于你所访问的java类的实现。有一点要牢牢记住：我们可以在一个本地方法的本地实现中访问所有的java特性，但是这要依赖于你所访问的java特性的实现，而且这样做远远不如在java语言中使用那些特性方便和容易。 本地方法的存在并不会对其他类调用这些本地方法产生任何影响，实际上调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM将控制调用本地方法的所有细节。需要注意当我们将一个本地方法声明为final的情况。用java实现的方法体在被编译时可能会因为内联而产生效率上的提升。但是一个native final方法是否也能获得这样的好处却是值得怀疑的，但是这只是一个代码优化方面的问题，对功能实现没有影响。 如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用java语言重写这个方法（这个似乎看起来有些奇怪），同样的如果一个本地方法被fianl标识，它被继承后不能被重写。 本地方法非常有用，因为它有效地扩充了jvm.事实上，我们所写的java代码已经用到了本地方法，在sun的java的并发（多线程）的机制实现中，许多与操作系统的接触点都用到了本地方法，这使得java程序能够超越java运行时的界限。有了本地方法，java程序可以做任何应用层次的任务。 二.为什么要使用本地方法java使用起来非常方便，然而有些层次的任务用java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与java环境外交互有时java应用需要与java外面的环境交互。这是本地方法存在的主要原因，你可以想想java需要与一些底层系统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解java应用之外的繁琐的细节。 与操作系统交互JVM支持着java语言本身和运行时库，它是java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎 样，它毕竟不是一个完整的系统，它经常依赖于一些底层（underneath在下面的）系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的，还有，如果我们要使用一些java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun’s JavaSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 三.JVM怎样使本地方法跑起来我们知道，当一个类第一次被使用到时，这个类的字节码会被加载到内存，并且只会加载一次。在这个被加载的字节码的入口维持着一个该类所有方法描述符的list，这些方法描述符包含这样一些信息：方法代码存于何处，它有哪些参数，方法的描述符（public之类）等等。 如果一个方法描述符内有native，这个描述符块将有一个指向该方法的实现的指针。这些实现在一些DLL文件内，但是它们会被操作系统加载到java程序的地址空间。当一个带有本地方法的类被加载时，其相关的DLL并未被加载，因此指向方法实现的指针并不会被设置。当本地方法被调用之前，这些DLL才会被加载，这是通过调用java.system.loadLibrary()实现的。 最后需要提示的是，使用本地方法是有开销的，它丧失了java的很多好处。如果别无选择，我们可以选择使用本地方法。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,本地方法,native","slug":"Java-本地方法-native","permalink":"/tags/Java-本地方法-native/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Zip压缩工具类（一）","slug":"Java核心基础之--Zip压缩工具类（一）","date":"2020-06-06T09:05:10.000Z","updated":"2023-04-30T10:21:41.344Z","comments":true,"path":"2020/06/06/Java核心基础之--Zip压缩工具类（一）/","link":"","permalink":"/2020/06/06/Java核心基础之--Zip压缩工具类（一）/","excerpt":"","text":"在Java项目中需要对文件夹的内容进行Zip压缩，参考了网上的代码并修复了里面的一些问题，例如：中文乱码、媒体文件解压后损坏。 所使用的Jar包：ant-*.*.*.jar 和 log4j-*.*.*.jar 。 ZipUtil工具类源码import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import org.apache.log4j.Logger; import org.apache.tools.zip.ZipEntry; import org.apache.tools.zip.ZipFile; import org.apache.tools.zip.ZipOutputStream; /* * ZIP压缩工具类 */ public class ZipUtil { private static final Logger logger = Logger.getLogger(ZipUtil.class); /** * 打包指定目录下所有文件，包括子文件夹 * * @param sourceFolder * 要打包的文件目录 * @param targetFolder * 生成的压缩文件存放目录 * @param zipFileName * 生成的压缩文件名 * @param encoding * 压缩时采用的编码格式 * @throws IOException */ public static void zipFolder(String sourceFolder, String targetFolder, String zipFileName, String encoding) { if (isEmptyStr(sourceFolder) || isEmptyStr(targetFolder) || isEmptyStr(zipFileName)) { logger.error(&quot;invalid compress parameters...&quot;); return; } sourceFolder = formatFilePath(sourceFolder); targetFolder = formatFilePath(targetFolder); List&lt;String&gt; fileList = generatefileList(sourceFolder); zipfileList(fileList, sourceFolder, targetFolder, zipFileName, encoding); } /** * 打包指定的文件。要打包的文件在文件列表中指定 * * @param fileList * 要打包的文件列表，这些文件是相对路径 * @param sourceFolder * 要打包的文件所在目录的绝对路径 * @param targetFolder * 生成的压缩文件存放的目录 * @param zipFileName * 生成的压缩文件名 * @param encoding * 压缩时采用的编码格式 * @throws IOException */ public static void zipfileList(List&lt;String&gt; fileList, String sourceFolder, String targetFolder, String zipFileName, String encoding) { if (fileList == null || fileList.isEmpty()) { logger.error(&quot;no files to be zip. fileList is null or empty...&quot;); return; } if (isEmptyStr(targetFolder) || isEmptyStr(zipFileName)) { logger.error(&quot;targetFolder and zipFileName are unspecified...&quot;); return; } sourceFolder = formatFilePath(sourceFolder); targetFolder = formatFilePath(targetFolder); if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } File outputDir = new File(targetFolder); if (!outputDir.exists()) { outputDir.mkdirs(); } byte[] buffer = new byte[1024 * 1024]; String outputFullFileName = (targetFolder + &quot;/&quot; + zipFileName); ZipOutputStream zos = null; try { zos = new ZipOutputStream(new FileOutputStream(outputFullFileName)); zos.setEncoding(encoding); logger.info(&quot;Output to Zip : &quot; + outputFullFileName); for (String file : fileList) { if (isEmptyStr(file)) { continue; } logger.info(&quot;File Added : &quot; + file); ZipEntry ze = new ZipEntry(file); // 这里用的是相对路径 zos.putNextEntry(ze); FileInputStream in = new FileInputStream(sourceFolder + &quot;/&quot; + file); // 这里是绝对路径 int len; while ((len = in.read(buffer)) &gt; 0) { zos.write(buffer, 0, len); } in.close(); } zos.closeEntry(); logger.info(&quot;Compress Done!!!&quot;); } catch (IOException e) { logger.error(&quot;Compress Wrong!!!&quot;); } finally { // remember close it if (null != zos) { try { zos.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } /** * 获取指定目录下的文件列表，包含子文件夹下的文件，忽略空文件夹 * * @param fileFolder * 文件或目录 * @return 目录下的文件列表 */ public static List&lt;String&gt; generatefileList(String fileFolder) { List&lt;String&gt; fileList = null; if (!isEmptyStr(fileFolder)) { fileFolder = formatFilePath(fileFolder); fileList = new ArrayList&lt;String&gt;(); File node = new File(fileFolder); generateFileListHelper(fileFolder, node, fileList); } return fileList; } private static void generateFileListHelper(String sourceFolder, File node, List&lt;String&gt; fileList) { // add file only if (node.isFile()) { String absoluteFile = node.getAbsoluteFile().toString(); String filepath = generateZipEntry(sourceFolder, absoluteFile); fileList.add(filepath); } if (node.isDirectory()) { String[] subNodes = node.list(); for (String subNode : subNodes) { File subFile = new File(node, subNode); generateFileListHelper(sourceFolder, subFile, fileList); } } } /** * 格式化被压缩文件的路径,删除文件的sourceFolder路径 例如： d:\\ziptest\\tmpty.txt --&gt; tmpty.txt * d:\\ziptest\\sub\\t.xls --&gt; sub\\t.xls * * @param file * 被压缩文件，这里是绝对路径 * @return 格式化后的文件路径，这里是与sourceFolder的相对路径 */ private static String generateZipEntry(String sourceFolder, String file) { logger.debug(&quot;sourceFolder=&quot; + sourceFolder); logger.debug(&quot;file=&quot; + file); String formattedPath = file.substring(sourceFolder.length() + 1); formattedPath = formatFilePath(formattedPath); logger.debug(&quot;formattedPath=&quot; + formattedPath); return formattedPath; } /** * 将文件路径中的分隔符&quot;\\&quot;转换成&quot;/&quot;,并去掉最后的分隔符（如果有） * * @param filePath * 文件路径 * @return 格式化后的文件路径 */ public static String formatFilePath(String filePath) { if (filePath != null &amp;&amp; filePath.length() != 0) { filePath = filePath.replaceAll(&quot;\\\\\\\\&quot;, &quot;/&quot;); } if (filePath.endsWith(&quot;/&quot;)) { filePath = filePath.substring(0, filePath.length() - 1); } return filePath; } private static boolean isEmptyStr(String str) { return str == null || str.length() == 0; } /** * 解压zip文件，支持子文件夹和中文 * * @param zipFileFullName * 要解压的zip文件，这里是绝对路径 * @param targetFolder * 解压到指定目录。这里是绝对路径，为空则默认解压到压缩文件所在目录 * @param encoding * 解压时采用的编码格式 */ @SuppressWarnings(&quot;rawtypes&quot;) public static void unzip(String zipFileFullName, String targetFolder, String encoding) { if (zipFileFullName == null || zipFileFullName.length() == 0) { return; } if (!zipFileFullName.endsWith(&quot;.zip&quot;)) { logger.error(zipFileFullName + &quot; is not a zip file...&quot;); return; } if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } // 将文件路径中的分隔符&quot;\\&quot;转换成&quot;/&quot; zipFileFullName = zipFileFullName.replaceAll(&quot;\\\\\\\\&quot;, &quot;/&quot;); // 获取压缩文件所在目录 String zipFolder = zipFileFullName.replaceAll(&quot;/[^/]+\\\\.zip&quot;, &quot;&quot;); if (targetFolder == null || targetFolder.length() == 0) { targetFolder = zipFolder; } targetFolder = targetFolder.replaceAll(&quot;\\\\\\\\&quot;, &quot;/&quot;); File targetFolderFile = new File(targetFolder); if (!targetFolderFile.exists()) { targetFolderFile.mkdirs(); } OutputStream outStream = null; InputStream inStream = null; try { ZipFile zip = new ZipFile(zipFileFullName, encoding); Enumeration zipFileEntries = zip.getEntries(); while (zipFileEntries.hasMoreElements()) { ZipEntry entry = (ZipEntry) zipFileEntries.nextElement(); String entryName = entry.getName(); logger.debug(&quot;Extracting,entryName=&quot; + entryName); int lastSlashPos = entryName.lastIndexOf(&quot;/&quot;); /* * 用本程序中ZipUtil.zipFolder或者ZipUtil.zipfileList生成的zip文件， * 如果有子文件夹，entry.getName()会直接得到子文件夹中的文件而略过子文件夹 * 所以这里需要先生成文件所在的各级子文件夹目录 */ if (lastSlashPos != -1) { String folderStr = targetFolder + &quot;/&quot; + entryName.substring(0, lastSlashPos); File folder = new File(folderStr); if (!folder.exists()) { folder.mkdirs(); } } if (!entryName.endsWith(&quot;/&quot;)) { File outFile = new File(targetFolder + &quot;/&quot; + entryName); outStream = new BufferedOutputStream(new FileOutputStream( outFile)); byte[] buffer = new byte[1024 * 1024]; inStream = new BufferedInputStream( zip.getInputStream(entry)); int len; while ((len = inStream.read(buffer)) &gt; 0) { outStream.write(buffer, 0, len); } outStream.flush(); } } } catch (Exception e) { logger.error(&quot;errors occur when decompressing...&quot;); e.printStackTrace(); } finally { if (null != outStream) { try { outStream.close(); } catch (IOException e) { logger.error(e.getMessage()); } } if (null != inStream) { try { inStream.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } public static void main(String[] argv) { String sourceFolder = &quot;D:\\\\sourceFolder&quot;;// 要打包压缩的文件夹 String targetFolder = &quot;D:\\\\targetFolder&quot;; String outputFileName = &quot;test.zip&quot;; zipFolder(sourceFolder, targetFolder, outputFileName, &quot;GB2312&quot;); String zipFileFullName = &quot;D:\\\\targetFolder\\\\test.zip&quot;; unzip(zipFileFullName, &quot;D:\\\\test&quot;, &quot;GB2312&quot;); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Zip","slug":"Java-Zip","permalink":"/tags/Java-Zip/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Zip压缩工具类（三）","slug":"Java核心基础之--Zip压缩工具类（三）","date":"2020-06-06T09:04:10.000Z","updated":"2023-04-30T10:21:41.344Z","comments":true,"path":"2020/06/06/Java核心基础之--Zip压缩工具类（三）/","link":"","permalink":"/2020/06/06/Java核心基础之--Zip压缩工具类（三）/","excerpt":"","text":"在Java项目中需要对文件夹的内容进行Zip压缩，参考了网上的代码并修复了里面的一些问题，例如：中文乱码、媒体文件解压后损坏。 所使用的Jar包：ant-*.*.*.jar 和 log4j-*.*.*.jar 。 ZipUtil工具类源码import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.Enumeration; import org.apache.log4j.Logger; import org.apache.tools.zip.ZipEntry; import org.apache.tools.zip.ZipFile; import org.apache.tools.zip.ZipOutputStream; public class ZipUtil { private static final Logger logger = Logger.getLogger(ZipUtil.class); /** * 由于压缩方法是静态方法，无须创建工具类实例，故将构造方法声明为私有 */ private ZipUtil() { } /** * 压缩文件或目录 * * @param srcPath * 要压缩的源文件或目录 * @param destPath * 生成的压缩文件全名，这里是绝对路径 * @param encoding * 压缩时采用的编码格式 */ public static void zip(String srcPath, String destPath, String encoding){ if (isEmptyStr(srcPath) || isEmptyStr(destPath)) { logger.error(&quot;invalid zip parameters...&quot;); return; } if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } zip(new File(srcPath), new File(destPath), encoding); } /** * 压缩文件或目录 * * @param srcFile * 目录或者单个文件 * @param destFile * 压缩后的ZIP文件 * @param encoding * 压缩时采用的编码格式 */ public static void zip(File srcFile, File destFile, String encoding) { File parentFile = destFile.getParentFile(); if (!parentFile.exists()) { parentFile.mkdirs(); } ZipOutputStream out = null; try { out = new ZipOutputStream(new FileOutputStream(destFile)); out.setEncoding(encoding); zip(srcFile, out); } catch (Exception e) { logger.error(e.getMessage()); } finally { if (null != out) { try { out.close();// 记得关闭资源 } catch (IOException e) { logger.error(e.getMessage()); } } } } /** * 压缩文件或目录 * * @param srcFile * 目录或者单个文件 * @param out * 压缩文件输出流 */ public static void zip(File srcFile, ZipOutputStream out) { zip(srcFile, out, &quot;&quot;); } /** * 压缩文件或目录 * * @param srcFile * 目录或者单个文件 * @param out * 压缩文件输出流 * @param curPaht * 正在压缩的当前文件与srcPath的相对路径 */ public static void zip(File srcFile, ZipOutputStream out, String curPaht) { if (srcFile.isDirectory()) { File[] files = srcFile.listFiles(); if (files != null &amp;&amp; files.length &gt; 0) { for (File file : files) { String name = srcFile.getName(); if (!&quot;&quot;.equals(curPaht)) { name = curPaht + File.separator + name; } ZipUtil.zip(file, out, name); } } } else { doZip(srcFile, out, curPaht); } } /** * 压缩文件 * * @param file * 要压缩的文件 * @param out * 压缩文件输出流 * @param curPath * 正在压缩的当前文件与srcPath的相对路径 */ public static void doZip(File file, ZipOutputStream out, String curPath) { String entryName = null; if (!&quot;&quot;.equals(curPath)) { entryName = curPath + File.separator + file.getName(); } else { entryName = file.getName(); } ZipEntry entry = new ZipEntry(entryName); FileInputStream fis = null; try { out.putNextEntry(entry); fis = new FileInputStream(file); int len = 0; byte[] buffer = new byte[1024]; while ((len = fis.read(buffer)) &gt; 0) { out.write(buffer, 0, len); out.flush(); } out.closeEntry(); } catch (IOException e) { logger.error(e.getMessage()); } finally { if (null != fis) { try { fis.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } /** * 判断是否为空字符串 * * @param str * @return */ private static boolean isEmptyStr(String str) { return str == null || str.length() == 0; } /** * 解压缩 * * @param zipFilePath * 压缩文件路径 * @param outputDirectory * 解压缩后文件存放的目录 * @param encoding * 解压缩时采用的编码格式 */ public static void unzip(String zipFilePath, String outputDirectory,String encoding){ if (isEmptyStr(zipFilePath) || isEmptyStr(outputDirectory)) { logger.error(&quot;invalid unzip parameters...&quot;); return; } if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } ZipFile zipFile=null; try { zipFile = new ZipFile(zipFilePath, encoding); } catch (IOException e) { logger.error(e.getMessage()); } unzip(zipFile, outputDirectory,encoding); } /** * 解压缩 * * @param zipFile * 源压缩文件 * @param outputDirectory * 解压缩后文件存放目录 * @param encoding * 解压缩时采用的编码格式 */ @SuppressWarnings(&quot;rawtypes&quot;) private static void unzip(ZipFile zipFile, String outputDirectory,String encoding) { File outputFile=new File(outputDirectory); if (!outputFile.exists()) { outputFile.mkdirs(); } try { Enumeration zipEntries = zipFile.getEntries(); ZipEntry zipEntry = null; while (zipEntries.hasMoreElements()) { zipEntry = (ZipEntry) zipEntries.nextElement(); String entryName = new String(zipEntry.getName().getBytes( encoding), encoding); InputStream in = null; FileOutputStream out = null; try { if (zipEntry.isDirectory()) { String name = zipEntry.getName(); name = name.substring(0, name.length() - 1); File f = new File(outputDirectory + File.separator + name); f.mkdirs(); } else { int index = entryName.lastIndexOf(&quot;\\\\&quot;); if (index != -1) { File df = new File(outputDirectory + File.separator + entryName.substring(0, index)); df.mkdirs(); } index = entryName.lastIndexOf(&quot;/&quot;); if (index != -1) { File df = new File(outputDirectory + File.separator + entryName.substring(0, index)); df.mkdirs(); } File f = new File(outputDirectory + File.separator + zipEntry.getName()); // f.createNewFile(); in = zipFile.getInputStream(zipEntry); out = new FileOutputStream(f); int len; byte[] buffer = new byte[1024 * 1024]; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } out.flush(); } } catch (IOException e) { logger.error(&quot;解压失败...&quot;); logger.error(e.getMessage()); } finally { if (null != in) { try { in.close(); } catch (IOException e) { logger.error(e.getMessage()); } } if (null != out) { try { out.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } } catch (IOException e) { logger.error(&quot;解压失败...&quot;); logger.error(e.getMessage()); } finally { if (null != zipFile) { try { zipFile.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } public static void main(String[] args) { ZipUtil.zip(&quot;D:\\\\sourceFolder&quot;, &quot;D:\\\\targetFolder\\\\test.zip&quot;, &quot;GBK&quot;); ZipUtil.unzip(&quot;D:\\\\targetFolder\\\\test.zip&quot;, &quot;D:\\\\test&quot;, &quot;GBK&quot;); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Zip","slug":"Java-Zip","permalink":"/tags/Java-Zip/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Zip压缩工具类（二）","slug":"Java核心基础之--Zip压缩工具类（二）","date":"2020-06-06T09:03:10.000Z","updated":"2023-04-30T10:21:41.344Z","comments":true,"path":"2020/06/06/Java核心基础之--Zip压缩工具类（二）/","link":"","permalink":"/2020/06/06/Java核心基础之--Zip压缩工具类（二）/","excerpt":"","text":"在Java项目中需要对文件夹的内容进行Zip压缩，参考了网上的代码并修复了里面的一些问题，例如：中文乱码、目录不存在异常。 所使用的Jar包：ant-*.*.*.jar 和 log4j-*.*.*.jar。 ZipUtil工具类源码import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.Enumeration; import org.apache.log4j.Logger; import org.apache.tools.zip.ZipEntry; import org.apache.tools.zip.ZipFile; import org.apache.tools.zip.ZipOutputStream; public class ZipUtil { private static final Logger logger = Logger.getLogger(ZipUtil.class); /** * 压缩文件或目录 * * @param src * 要压缩的源文件或目录 * @param dest * 生成的压缩文件全名，这里是绝对路径 * @param encoding * 压缩时采用的编码格式 * @throws IOException */ public static void zip(String src, String dest, String encoding) { ZipOutputStream out = null; if (isEmptyStr(src) || isEmptyStr(dest)) { logger.error(&quot;invalid compress parameters...&quot;); return; } if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } try { File outFile = new File(dest); File parentFile = outFile.getParentFile(); if (!parentFile.exists()) { parentFile.mkdirs(); } out = new ZipOutputStream(outFile); out.setEncoding(encoding); File fileOrDirectory = new File(src); if (fileOrDirectory.isFile()) { zipFileOrDirectory(out, fileOrDirectory, &quot;&quot;); } else { File[] entries = fileOrDirectory.listFiles(); for (int i = 0; i &lt; entries.length; i++) { // 递归压缩，更新curPaths zipFileOrDirectory(out, entries[i], &quot;&quot;); } } } catch (IOException e) { logger.error(e.getMessage()); } finally { if (null != out) { try { out.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } private static boolean isEmptyStr(String str) { return str == null || str.length() == 0; } /** * 递归压缩文件或目录 * * @param out * 压缩输出流对象 * @param file * 要压缩的文件或目录对象 * @param curPath * 当前压缩条目的路径，用于指定条目名称的前缀 * @throws IOException */ private static void zipFileOrDirectory(ZipOutputStream out, File file, String curPath) { FileInputStream in = null; try { if (!file.isDirectory()) { // 压缩文件 byte[] buffer = new byte[1024 * 1024]; int len; in = new FileInputStream(file); ZipEntry entry = new ZipEntry(curPath + file.getName()); out.putNextEntry(entry); while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } out.closeEntry(); } else { // 压缩目录 File[] entries = file.listFiles(); for (int i = 0; i &lt; entries.length; i++) { // 递归压缩，更新curPath zipFileOrDirectory(out, entries[i], curPath + file.getName() + &quot;/&quot;); } } } catch (IOException e) { logger.error(e.getMessage()); } finally { if (null != in) { try { in.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } /** * 解压缩 * * @param zipFileName * 源文件 * @param outputDirectory * 解压缩后文件存放的目录 * @throws IOException */ @SuppressWarnings({ &quot;rawtypes&quot; }) public static void unzip(String zipFileName, String outputDirectory, String encoding) { ZipFile zipFile = null; if (isEmptyStr(encoding)) { encoding = &quot;UTF-8&quot;; } try { zipFile = new ZipFile(zipFileName, encoding); Enumeration zipEntries = zipFile.getEntries(); ZipEntry zipEntry = null; File dest = new File(outputDirectory); if (!dest.exists()) { dest.mkdirs(); } while (zipEntries.hasMoreElements()) { zipEntry = (ZipEntry) zipEntries.nextElement(); String entryName = new String(zipEntry.getName().getBytes( encoding), encoding); InputStream in = null; FileOutputStream out = null; try { if (zipEntry.isDirectory()) { String name = zipEntry.getName(); name = name.substring(0, name.length() - 1); File f = new File(outputDirectory + File.separator + name); f.mkdirs(); } else { int index = entryName.lastIndexOf(&quot;\\\\&quot;); if (index != -1) { File df = new File(outputDirectory + File.separator + entryName.substring(0, index)); df.mkdirs(); } index = entryName.lastIndexOf(&quot;/&quot;); if (index != -1) { File df = new File(outputDirectory + File.separator + entryName.substring(0, index)); df.mkdirs(); } File f = new File(outputDirectory + File.separator + zipEntry.getName()); // f.createNewFile(); in = zipFile.getInputStream(zipEntry); out = new FileOutputStream(f); int len; byte[] buffer = new byte[1024 * 1024]; while ((len = in.read(buffer)) != -1) { out.write(buffer, 0, len); } out.flush(); } } catch (IOException e) { logger.error(&quot;解压失败...&quot;); logger.error(e.getMessage()); } finally { if (null != in) { try { in.close(); } catch (IOException e) { logger.error(e.getMessage()); } } if (null != out) { try { out.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } } catch (IOException e) { logger.error(&quot;解压失败...&quot;); logger.error(e.getMessage()); } finally { if (null != zipFile) { try { zipFile.close(); } catch (IOException e) { logger.error(e.getMessage()); } } } } public static void main(String[] args) { ZipUtil.zip(&quot;D:\\\\sourceFolder&quot;, &quot;D:\\\\targetFolder\\\\test.zip&quot;, &quot;GBK&quot;); ZipUtil.unzip(&quot;D:\\\\targetFolder\\\\test.zip&quot;, &quot;D:\\\\test&quot;, &quot;GBK&quot;); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Zip","slug":"Java-Zip","permalink":"/tags/Java-Zip/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--try语句块中的return语句","slug":"Java核心基础之--try语句块中的return语句","date":"2020-06-06T09:02:10.000Z","updated":"2023-04-30T10:21:41.345Z","comments":true,"path":"2020/06/06/Java核心基础之--try语句块中的return语句/","link":"","permalink":"/2020/06/06/Java核心基础之--try语句块中的return语句/","excerpt":"","text":"对于做Java开发的程序员来说，异常捕获似乎已经是再稀松平常不过的事情了。我们都已经清楚的了解到：在try-catch-finally语法结构中无论异常是否发生，finally语句块中的内容都会被执行，所以，我们习惯把一些占用资源较多的对象的释放操作放到finally语句块中来做，例如：关闭数据库连接、关闭文件流。 但当try-catch-finally语句块中包含return语句时，情况就会变得复杂，有以下几种情况值得注意。 情况一：try中有return，catch和finally中没有returnpublic class Test { public static void main(String[] args) { System.out.println(&quot;返回结果 num = &quot; + test()); } private static int test() { int num = 10; try { System.out.println(&quot;进入try语句块&quot;); System.out.println(&quot;try语句块中num = &quot; + num); return num; } catch (Exception e) { System.out.println(&quot;进入catch语句块&quot;); } finally { num += 10; System.out.println(&quot;进入finally语句块&quot;); System.out.println(&quot;finally语句块中num = &quot; + num); } return num; } } 执行结果： 进入try语句块 try语句块中num = 10 进入finally语句块 finally语句块中num = 20 返回结果 num = 10 结果分析： 程序先进入try语句块，在执行return num;语句之前，发现程序后面还有finally语句块，于是，先将要返回的值num=10缓存起来，然后程序跳转到finally语句块执行，在finally语句块中num值被修改为了20，而最终返回的结果却是10，这说明finally语句块执行完毕后，程序直接将之前try语句块缓存的值返回了。 情况二：try和finally中都有returnpublic class Test { public static void main(String[] args) { System.out.println(&quot;返回结果 num = &quot; + test()); } private static int test() { int num = 10; try { System.out.println(&quot;进入try语句块&quot;); System.out.println(&quot;try语句块中num = &quot; + num); return num; } catch (Exception e) { System.out.println(&quot;进入catch语句块&quot;); } finally { num += 10; System.out.println(&quot;进入finally语句块&quot;); System.out.println(&quot;finally语句块中num = &quot; + num); return num; } } } 执行结果： 进入try语句块 try语句块中num = 10 进入finally语句块 finally语句块中num = 20 返回结果 num = 20 结果分析： try语句块的执行过程与情景一相同，所不同的是finally语句块中的return num;直接将finally语句块中的num值返回了。 注：SUN官方并不推荐在finally语句块中写return语句，否则，会提示警告：finally block does not complete normally。 情况三：将情景一中的返回值类型改为引用类型public class Test { public static void main(String[] args) { System.out.println(&quot;返回结果Num.num = &quot; + test().num); } private static Num test() { Num num = new Num(); try { System.out.println(&quot;进入try语句块&quot;); System.out.println(&quot;try语句块中Num.num = &quot; + num.num); return num; } catch (Exception e) { System.out.println(&quot;进入catch语句块&quot;); } finally { num.num += 10; System.out.println(&quot;进入finally语句块&quot;); System.out.println(&quot;finally语句块中Num.num = &quot; + num.num); } return num; } } class Num { public int num = 10; } 执行结果： 进入try语句块 try语句块中Num.num = 10 进入finally语句块 finally语句块中Num.num = 20 返回结果Num.num = 20 结果分析： try语句块的执行过程与情景一类似，只是此时缓存的是一个Num引用类型对象，finally语句块中的num.num += 10;修改了Num对象的num值，并作为最终的结果返回。 结论当try-catch-finally语句块中包含return语句时，有以下几点结论： 如果finally中有return语句，finally中的return语句会”覆盖“掉try中的return语句，直接将finally中的值作为结果返回。 如果finally中没有return语句，也没有改变要返回的结果值，则执行完finally中的语句后，会接着执行try中的return语句，返回try之前保留的结果值。 如果finally中没有return语句，但是改变了要返回的结果值，这里有点类似与引用传递和值传递的区别，分以下两种情况： 如果返回值是基本数据类型或字符串，try中的return语句依然会返回进入finally块之前保留的结果值。 如果返回值是引用数据类型，try中的return语句返回的就是在finally中改变后的该对象的值。 参考文章http://blog.sina.com.cn/s/blog_6aefe42501018wmw.html http://blog.csdn.net/ns_code/article/details/17485221","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Stack","slug":"Java-Stack","permalink":"/tags/Java-Stack/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Thread","slug":"Java核心基础之--Thread","date":"2020-06-06T09:01:10.000Z","updated":"2023-04-30T10:21:41.344Z","comments":true,"path":"2020/06/06/Java核心基础之--Thread/","link":"","permalink":"/2020/06/06/Java核心基础之--Thread/","excerpt":"","text":"一、什么是线程？线程是一个程序的多个执行路径，执行调度的单位，依托于进程而存在。 线程不仅可以共享进程的内存，而且还拥有一个属于自己的内存空间，这段内存空间也叫做线程栈，是在建立线程时由系统分配的，主要用来保存线程内部所使用的数据，如线程执行函数中所定义的变量。 注意：Java中的多线程是一种抢占机制而不是分时机制。抢占机制指的是有多个线程处于可运行状态，但是只允许一个线程在运行，他们通过竞争的方式抢占CPU。 二、线程的创建在Java中可以通过以下两种方式定义线程： 继承java.lang.Thread类 。 实现java.lang.Runnable接口。 继承java.lang.Thread类/** * 通过继承java.lang.Thread类来定义线程 */ public class MyThread extends Thread { private boolean flag = true; public MyThread(String threadName) { super(threadName); } @Override public void run() { while (flag) { System.out.println(Thread.currentThread().getName() + &quot; Is Running...&quot;); } } public void shutDown() { this.flag = false; } public static void main(String[] args) throws InterruptedException { MyThread myThread = new MyThread(&quot;MyThread&quot;); myThread.start(); Thread.sleep(1000); myThread.shutDown(); } } 实现java.lang.Runnable接口/** * 通过实现Runnable接口来定义线程 */ public class MyThread implements Runnable { private boolean flag = true; @Override public void run() { while (flag) { System.out.println(Thread.currentThread().getName() + &quot; Is Running...&quot;); } } public void shutDown() { this.flag = false; } public static void main(String[] args) throws InterruptedException { MyThread myThread = new MyThread(); Thread thread = new Thread(myThread, &quot;MyThread&quot;); thread.start(); Thread.sleep(1000); myThread.shutDown(); } } 在线程的start()方法被调用后，JVM会自动调用线程的run()方法来执行任务。start()方法结束，线程也就终止了。 注意：推荐使用实现Runnable接口的方式来定义线程，因为Java中的类只支持单继承，你一旦继承了Thread类就不能再继承其他的类了，会大大降低程序的可扩展性和灵活性。 三、线程的状态 四、线程的基本方法和属性1）优先级（priority）每个线程都有一个优先级(用1-10的整数表示,默认优先级是5，高优先级线程的执行优先于低优先级线程。默认一个线程的优先级和创建他的线程优先级相同。 以下是Thread定义的三个与优先级相关的静态常量： MAX_PRIORITY =10NORM_PRIORITY =5MIN_PRIORITY=1 2）Thread.sleep使当前线程休眠（暂停执行）millis毫秒的时间（millis指定的休眠时间是其最小的不执行时间，因为在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级）；sleep()是Thread类的static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用sleep()方法时，线程虽然休眠了，但是对象的机锁并没有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 作用：保持对象锁，让出CPU，调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留一定的执行机会给其他线程； 3）Thread.yield()让出CPU的使用权，让其他同等优先级或更高优先级的线程可以获取到运行机会，线程yield()时也不会释放对象锁。 sleep()和yield()的区别： sleep()方法会给其他线程运行的机会，而不考虑其他线程的优先级，因此会给较低优先级线程一个运行的机会；yield()方法只会给相同优先级或者更高优先级的线程一个运行的机会。 当线程执行了sleep(long millis)方法后，将转到阻塞状态，参数millis指定休眠时间；当线程执行了yield()方法后，将转到就绪状态。 sleep()方法声明抛出InterruptedException异常，而yield()方法没有声明抛出任何异常 。 4）thread.join()线程合并，使用该方法的线程会在此线程执行完毕后才往下继续执行，可使异步线程变为同步线程。 5）object.wait()wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁），其他线程可以访问。执行wait()方法的线程必须拥有当前对象的锁，如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常,所以wait()必须在synchronized block中调用。 wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 6）object.notify()唤醒在当前对象等待池中等待的一个线程/所有线程。notify()/notifyAll()也必须拥有相同对象锁，否则也会抛出IllegalMonitorStateException异常。 7）Synchronized BlockJava中的每一个对象都有唯一的一个内置的锁，每个Synchronized Block或同步的方法只有持有调用该方法被锁定对象的锁的线程才可以访问，否则所属线程阻塞；机锁具有独占性、一旦被一个Thread持有，其他的Thread就不能再拥有（不能访问其他同步方法），方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。 五、线程资源共享示例/** * 车站售票示例 */ public class TicketsThread implements Runnable { // 车票总数 private Integer tickets = 100; private boolean flag = true; private Object object = new Object(); @Override public void run() { while (flag) { /* synchronized (object) { if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;售出第&quot; + tickets + &quot;张车票&quot;); tickets--; } else { System.out.println(Thread.currentThread().getName() + &quot;提醒广大乘客：车票已经售完，停止售票！&quot;); this.flag = false; } }*/ sell(); } } private synchronized void sell(){ if (tickets &gt; 0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;售出第&quot; + tickets + &quot;张车票&quot;); tickets--; } else { System.out.println(Thread.currentThread().getName() + &quot;提醒广大乘客：车票已经售完，停止售票！&quot;); this.flag = false; } } public void shutDown() { this.flag = false; } public static void main(String[] args) { TicketsThread ticketsThread = new TicketsThread(); Thread thread1 = new Thread(ticketsThread, &quot;售票处1&quot;); Thread thread2 = new Thread(ticketsThread, &quot;售票处2&quot;); Thread thread3 = new Thread(ticketsThread, &quot;售票处3&quot;); thread1.start(); thread2.start(); thread3.start(); } } /** * 死锁示例 */ public class DeadThread implements Runnable { private Object obj1 = new Object(); private Object obj2 = new Object(); private boolean flag = true; @Override public void run() { if (flag) { synchronized (obj1) { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (obj2) { } } } else { synchronized (obj2) { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (obj1) { } } } } public static void main(String[] args) throws InterruptedException { DeadThread deadThread = new DeadThread(); Thread thread1 = new Thread(deadThread); Thread thread2 = new Thread(deadThread); thread1.start(); Thread.sleep(100); deadThread.flag = false; thread2.start(); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Stack","slug":"Java-Stack","permalink":"/tags/Java-Stack/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Stack","slug":"Java核心基础之--Stack","date":"2020-06-06T09:00:10.000Z","updated":"2023-04-30T10:21:41.343Z","comments":true,"path":"2020/06/06/Java核心基础之--Stack/","link":"","permalink":"/2020/06/06/Java核心基础之--Stack/","excerpt":"","text":"在Java中Stack类表示后进先出（LIFO）的对象堆栈。栈是一种非常常见的数据结构，它采用典型的先进后出的操作方式完成的。每一个栈都包含一个栈顶，每次出栈是将栈顶的数据取出，如下： Stack通过五个操作对Vector进行扩展，允许将向量视为堆栈。这个五个操作如下： Stack继承Vector，他对Vector进行了简单的扩展： public class Stack&lt;E&gt; extends Vector&lt;E&gt; Stack的实现非常简单，仅有一个构造方法，五个实现方法（从Vector继承而来的方法不算与其中），同时其实现的源码非常简单。 /** * 构造函数 */ public Stack() { } /** * push函数：将元素存入栈顶 */ public E push(E item) { // 将元素存入栈顶。 // addElement()的实现在Vector.java中 addElement(item); return item; } /** * pop函数：返回栈顶元素，并将其从栈中删除 */ public synchronized E pop() { E obj; int len = size(); obj = peek(); // 删除栈顶元素，removeElementAt()的实现在Vector.java中 removeElementAt(len - 1); return obj; } /** * peek函数：返回栈顶元素，不执行删除操作 */ public synchronized E peek() { int len = size(); if (len == 0) throw new EmptyStackException(); // 返回栈顶元素，elementAt()具体实现在Vector.java中 return elementAt(len - 1); } /** * 栈是否为空 */ public boolean empty() { return size() == 0; } /** * 查找“元素o”在栈中的位置：由栈底向栈顶方向数 */ public synchronized int search(Object o) { // 获取元素索引，elementAt()具体实现在Vector.java中 int i = lastIndexOf(o); if (i &gt;= 0) { return size() - i; } return -1; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Stack","slug":"Java-Stack","permalink":"/tags/Java-Stack/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--MD5加密","slug":"Java核心基础之--MD5加密","date":"2020-06-06T08:59:10.000Z","updated":"2023-04-30T10:21:41.342Z","comments":true,"path":"2020/06/06/Java核心基础之--MD5加密/","link":"","permalink":"/2020/06/06/Java核心基础之--MD5加密/","excerpt":"","text":"MD5简介MD5即Message-Digest Algorithm 5（信息-摘要算法第五版），是一种在计算机安全领域被广泛使用的散列函数（又译杂凑算法、摘要算法、哈希算法），用于确保所加密的数据的信息完整性和一致性。将数据（如文本、压缩包等）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串），它常被用来做一致性检验、数字签名、安全性认证等。除了MD5以外，比较有名的同类算法还有sha-1、RIPEMD以及Haval等。 大家都知道，地球上任何人都有自己独一无二的指纹，这常常成为司法机关鉴别罪犯身份最值得信赖的方法；与之类似，MD5可以为任何文件（不管其大小、格式、数量）产生一个同样独一无二的“数字指纹”，一旦有人对该文件做了任何改动，其MD5值也就是对应的“数字指纹”都会发生变化。 我们常常在某些软件下载站点的某软件信息中看到其MD5值，它的作用就在于我们可以在下载该软件后，对下载回来的文件用专门的软件（如Windows MD5 Check等）做一次MD5校验，以确保我们获得的文件与该站点提供的文件为同一文件。 MD5加密算法可以分为16位加密和32加密的，其实所谓的16位的加密算法只是在32位的加密算法中截取了第8位到第24位字符串，总共16位的字符串，故而叫做是16位的MD5加密算法。 MD5算法具有以下特点： 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 强抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 不可解密：根据加密后的md5值，无法逆向得到其原始数据。 在java中使用MD5对字节数组和字符串的MD5加密实现代码如下： // 利用MD5对字节数组进行加密，得到128位的字节数组 public static byte[] encryptByMD5(byte[] input) { byte[] output = null; try { MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); output = md5.digest(input); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } return output; } // 利用MD5对字符串进行加密，得到128位的字节数组 public static byte[] encryptByMD5(String input) { byte[] output = null; try { MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); output = md5.digest(input.getBytes(&quot;utf-8&quot;)); } catch (Exception e) { e.printStackTrace(); } return output; } 在实际使用过程中，我们通常都会将MD5加密后的字节数组转换为字符串进行存储，其代码实现如下。 public static String encryptByMD5(String message) { String output = null; try { // 1 创建一个提供信息摘要算法的对象，初始化为md5算法对象 MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); // 2 将消息转换为byte数组 byte[] input = message.getBytes(&quot;utf-8&quot;); // 3 计算后获得size为16（128位）的字节数组 byte[] buff = md5.digest(input); // 4 把数组每一字节（一个字节占八位）转换成两个16进制字符并连接起来 output = toHexString(buff); } catch (Exception e) { e.printStackTrace(); } return output; } public static String toHexString(byte[] bytes) { StringBuffer buffer = new StringBuffer(); // 把数组每一字节转换成两个16进制的字符，并连接起来 int digital; for (int i = 0; i &lt; bytes.length; i++) { digital = bytes[i]; if (digital &lt; 0) { digital += 256; } if (digital &lt; 16) { buffer.append(&quot;0&quot;); } buffer.append(Integer.toHexString(digital)); } return buffer.toString().toUpperCase(); } toHexString(byte[] bytes)方法的作用是将128位（size=16*8）的字节数组转换为一个长度32的16进制字符串。如果对此方法的实现理解起来有困难，可以参照下面这段代码，两者实现效果相同。 /* * Converts a byte to hex digit and writes to the supplied buffer */ private static void byte2hex(byte b, StringBuffer buf) { char[] hexChars = { &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; }; int high = ((b &amp; 0xf0) &gt;&gt; 4); int low = (b &amp; 0x0f); buf.append(hexChars[high]); buf.append(hexChars[low]); } /* * Converts a byte array to hex string */ private static String toHexString(byte[] block) { StringBuffer buf = new StringBuffer(); int len = block.length; for (int i = 0; i &lt; len; i++) { byte2hex(block[i], buf); } return buf.toString(); } 出于安全考虑，一般情况下我们并不会直接使用MD5加密得到的结果，而是将MD5加密得到的结果使用BASE64再加密一次，得到相应的字符串。 public static String encryptByMD5(String message) { String output = null; try { // 1 创建一个提供信息摘要算法的对象，初始化为md5算法对象 MessageDigest md5 = MessageDigest.getInstance(&quot;MD5&quot;); // 2 将消息转换为byte数组 byte[] input = message.getBytes(&quot;utf-8&quot;); // 3 计算后获得size为16（128位）的字节数组 byte[] buff = md5.digest(input); BASE64Encoder base64en = new BASE64Encoder(); // 4 将MD5加密获得的字节数组使用BASE64进行第二次加密 output = base64en.encode(buff); } catch (Exception e) { e.printStackTrace(); } return output; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,MD5,加密","slug":"Java-MD5-加密","permalink":"/tags/Java-MD5-加密/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--RMI","slug":"Java核心基础之--RMI","date":"2020-06-06T08:59:10.000Z","updated":"2023-04-30T10:21:41.343Z","comments":true,"path":"2020/06/06/Java核心基础之--RMI/","link":"","permalink":"/2020/06/06/Java核心基础之--RMI/","excerpt":"","text":"参考书籍：《Head First Java （中文版）》第二版 Java的远程方法调用 (Remote Method Invocation,RMI)技术，能够帮助我们实现：某一个Java虚拟机上的对象可以调用另一台计算机、另一个Java虚拟机上面的对象的方法，就像调用本地对象的方法一样。 使用RMI时，需要指定协议：JRMP（Java远程消息交换协议JRMP，Java Remote Messaging Protocol）或是IIOP（互联网内部对象请求代理协议，Internet Inter-ORB Protocol）。JRMP是RMI原生的协议，它是为了Java对Java间的远程调用而设计的。另一方面，IIOP是为了CORBA（Common Object Request Broker Architecture）而产生的，它让你能够调用Java对象或其它类型的远程方法。 RMI远程方法调用过程如下图所示： 创建远程服务创建远程服务包含以下5个步骤： 创建远程服务接口远程的服务接口要继承java.rmi.Remote，用来定义客户端可以远程调用的方法，stub和skeleton都要实现此接口。它是个作为服务的多态化类，也就是说，客户端会调用实现此接口的stub，而此stub因为会执行网络和输入/输出工作，所以可能会发生各种问题，客户端必须处理或声明异常来认知这一类风险。并且，远程方法的参数和返回值必须都是primitive基本数据类型或Serializable的。 package rmi; import java.rmi.Remote; import java.rmi.RemoteException; /** * 远程服务接口 */ public interface IRemoteService extends Remote { public String sayHello() throws RemoteException; } 实现远程服务接口这是真正执行的类，它实现了定义在远程服务接口中的方法，它是客户端会调用的对象。为了要成为远程服务对象，这个实现类必须要包含与远程有关的功能。其中最简单的方式就是继承java.rim.server.UnicastRemoteObject，以调用父类的远程功能来处理这些工作。UnicastRemoteObject有个小问题：它的构造函数会抛出RemoteException异常，因此需要为你的实现类声明一个构造函数，并在其中抛出RemoteException异常。 package rmi; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; /** * 远程服务实现 */ public class RemoteServiceImpl extends UnicastRemoteObject implements IRemoteService { // 无需声明RemoteException异常 public String sayHello() { return &quot;Server syas , &#39;Hey&#39;&quot;; } // 父类的构造函数声明了异常，所以你也得在构造函数中声明异常 public RemoteServiceImpl() throws RemoteException { } } 注意：要记得当类被初始化的时候，父类的构造函数一定会被调用，如果父类的构造函数抛出异常，你也得声明你的构造函数会抛出异常。 使用rmic产生stub和skeleton伴随Java Software Development Kit而来的rmic工具会以远程服务的实现类（不是远程服务接口）产生出两个新的类：stub和skeleton。它会按照命名规则在你的远程服务实现类名称后面加上_Stub或_Skel（JDK 1.2以后将只需要_Stub文件）。 执行rmic命令时需要考虑到包目录结构和完整名称，我的所有示例代码的.class文件均放置在D:\\bin\\rmi目录下，RemoteServiceImpl类的完整名称为rmi（包路径）.RemoteServiceImpl。 由于未指定rmic的生成的目标文件的存放位置，所以会将生成的stub文件和skeleton文件放置在RemoteServiceImpl.class文件所在目录(D:\\bin\\rmi)下。 启动RMI registry（执行rmiregistry）rmiregistry就像是电话簿，用户会从此处取得代理（客户端的stub对象），因此需要在远程服务启动前先启动RMI registry。 启动远程服务远程服务实现类定义完成之后还需要使用java.rmi.Naming的bind()方法 来向RMI registry注册服务，当你注册对象时，RMI系统会把stub加到RMI registry中。 package rmi; import java.rmi.Naming; public class Server { public static void main(String[] args) { try { // 创建出远程对象，然后使用静态的Naming.bind()来产生关联 // 所注册的名称会供客户端查询 IRemoteService service = new RemoteServiceImpl(); Naming.bind(&quot;RemoteHello&quot;, service); //Naming.rebind(&quot;Remote Hello&quot;, service); } catch (Exception e) { e.printStackTrace(); } } } 客户端如何取得stub对象？客户端必须取得stub对象，因为客户端必须要调用它的方法，这就得靠RMI registry了。客户端会像查询电话簿一样地搜索，找出上面有相符名称的服务。 RMI会自动将stub解序列化，这就要求客户端在查询服务时一定要有stub类文件，否则将导致stub不能被解序列化。 package rmi; import java.rmi.Naming; public class Client { public static void main(String[] args) { new Client().go(); } public void go() { try { //客户端必须使用与服务相同的类型 //事实上，客户端不需要知道服务实际上的类型 IRemoteService service = (IRemoteService) Naming.lookup(&quot;rmi://127.0.0.1/RemoteHello&quot;); String s = service.sayHello(); System.out.println(s); } catch (Exception e) { e.printStackTrace(); } } } 注意事项：客户端是使用接口来调用stub上的方法，客户端的Java虚拟机必须要有stub类，但客户端不会在程序代码中引用stub类，客户端总是通过接口来操作真正的远程对象。服务器上必须要有stub和skeleton，以及服务于远程的接口，它会需要stub类是因为stub会被代换成连接在RMI registry上真正的服务。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,RMI","slug":"Java-RMI","permalink":"/tags/Java-RMI/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Maven引入org.apache.tools.zip","slug":"Java核心基础之--Maven引入org.apache.tools.zip","date":"2020-06-06T08:58:10.000Z","updated":"2023-04-30T10:21:41.343Z","comments":true,"path":"2020/06/06/Java核心基础之--Maven引入org.apache.tools.zip/","link":"","permalink":"/2020/06/06/Java核心基础之--Maven引入org.apache.tools.zip/","excerpt":"","text":"可以看出 org.apache.tools.zip 是 ant-**.jar 里面的。 所以要引入org.apache.tools.zip，直接maven引入ant即可。 &lt;!-- https://mvnrepository.com/artifact/org.apache.ant/ant --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ant&lt;/groupId&gt; &lt;artifactId&gt;ant&lt;/artifactId&gt; &lt;version&gt;1.10.5&lt;/version&gt; &lt;/dependency&gt;","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,maven","slug":"Java-maven","permalink":"/tags/Java-maven/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--JDK1.8中的日期处理","slug":"Java核心基础之--JDK1.8中的日期处理","date":"2020-06-06T08:57:10.000Z","updated":"2023-04-30T10:21:41.342Z","comments":true,"path":"2020/06/06/Java核心基础之--JDK1.8中的日期处理/","link":"","permalink":"/2020/06/06/Java核心基础之--JDK1.8中的日期处理/","excerpt":"","text":"伴随lambda表达式、streams以及一系列小优化，Java 8 推出了全新的日期时间API，在教程中我们将通过一些简单的实例来学习如何使用新API。Java处理日期、日历和时间的方式一直为社区所诟病，将java.util.Date设定为可变类型，以及SimpleDateFormat的非线程安全使其应用非常受限。Java也意识到需要一个更好的 API来满足社区中已经习惯了使用JodaTime API的人们。全新API的众多好处之一就是，明确了日期时间概念，例如：瞬时（instant）、 长短（duration）、日期、时间、时区和周期。同时继承了Joda库按人类语言和计算机各自解析的时间处理方式。不同于老版本,新API基于ISO标准日历系统，java.time包下的所有类都是不可变类型而且线程安全。下面是新版API中java.time包里的一些关键类： Instant：瞬时实例。 LocalDate：本地日期，不包含具体时间 例如：2014-01-14 可以用来记录生日、纪念日、加盟日等。 LocalTime：本地时间，不包含日期。 LocalDateTime：组合了日期和时间，但不包含时差和时区信息。 ZonedDateTime：最完整的日期时间，包含时区和相对UTC或格林威治的时差。 新API还引入了ZoneOffSet和ZoneId类，使得解决时区问题更为简便。解析、格式化时间的DateTimeFormatter类也全部重新设计。注意，这篇文章是我在一年前Java 8即将发布时写的，以下示例代码中的时间都是那一年的，当运行这些例子时会返回你当前的时间。 使用新库处理日期和时间常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探 索。这对Java 8新日期时间API也不例外。我创建了20个基于任务的实例来学习Java 8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单 日、保费到期日、信用卡过期日等。 1、获取今天的日期Java 8 中的 LocalDate 用于表示当天日期。和java.util.Date不同，它只有日期，不包含时间。当你仅需要表示日期时就用这个类。 LocalDate today = LocalDate.now(); System.out.println(&quot;Today&#39;s Local date : &quot; + today); 输出： Today&#39;s Local date : 2014-01-14 上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的Date类打印出一堆没有格式化的信息。 2、获取年/月/日信息LocalDate类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖java.util.Calendar类了。 LocalDate today = LocalDate.now(); int year = today.getYear(); int month = today.getMonthValue(); int day = today.getDayOfMonth(); System.out.printf(&quot;Year : %d Month : %d day : %d t %n&quot;, year, month, day); 输出： Today&#39;s Local date : 2014-01-14Year : 2014 Month : 1 day : 14 看到了吧，在Java 8 中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前Java是怎么处理年月日信息的吧。 3、处理特定日期在第一个例子里，我们通过静态工厂方法now()非常容易地创建了当天日期，你还可以调用另一个有用的工厂方法LocalDate.of()创建任意日期， 该方法需要传入年、月、日做参数，返回对应的LocalDate实例。这个方法的好处是没再犯老API的设计错误，比如年度起始于1900，月份是从0开 始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。 LocalDate dateOfBirth = LocalDate.of(2010, 01, 14); System.out.println(&quot;Your Date of birth is : &quot; + dateOfBirth); 输出: Output : Your Date of birth is : 2010-01-14 可以看到创建的日期完全符合预期，与你写入的2010年1月14日完全一致。 4、判断两个日期是否相等现实生活中有一类时间处理就是判断两个日期是否相等。你常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定 日期做比较，例如判断这一天是否是假期。下面这个例子会帮助你用Java 8的方式去解决，你肯定已经想到了，LocalDate重载了equal方法，请看下面的例子： LocalDate date1 = LocalDate.of(2014, 01, 14); if(date1.equals(today)){ System.out.printf(&quot;Today %s and date1 %s are same date %n&quot;, today, date1); } 输出： today 2014-01-14 and date1 2014-01-14 are same date 这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比Java老的日期比较方式，你会感到清风拂面。 5、周期性日期判断Java 中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI日或保险缴费日这些周期性事件。如果你在电子商务网站工作，那么一定会有一个模块用来在 圣诞节、感恩节这种节日时向客户发送问候邮件。Java中如何检查这些节日或其它周期性事件呢？答案就是MonthDay类。这个类组合了月份和日，去掉 了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个YearMonth类。这些类也都是不可变并且线程安全的值类型。下面我们通过 MonthDay来检查周期性事件： LocalDate dateOfBirth = LocalDate.of(2010, 01, 14); MonthDay birthday = MonthDay.of(dateOfBirth.getMonth(), dateOfBirth.getDayOfMonth()); MonthDay currentMonthDay = MonthDay.from(today); if(currentMonthDay.equals(birthday)){ System.out.println(&quot;Many Many happy returns of the day !!&quot;); }else{ System.out.println(&quot;Sorry, today is not your birthday&quot;); } 输出： Many Many happy returns of the day !! 只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。你可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。 6、获取当前时间与Java 8获取日期的例子很像，获取时间使用的是LocalTime类，一个只有时间没有日期的LocalDate近亲。可以调用静态工厂方法now()来获取当前时间。默认的格式是hh:mm:ss:nnn。对比一下Java 8之前获取当前时间的方式。 LocalTime time = LocalTime.now(); System.out.println(&quot;local time now : &quot; + time); 输出： local time now : 16:33:33.369 // in hour, minutes, seconds, nano seconds 可以看到当前时间就只包含时间信息，没有日期。 7、在当前时间上增加小时通过增加小时、分、秒来计算将来的时间很常见。Java 8除了不变类型和线程安全的好处之外，还提供了更好的plusHours()方法替换add()，并且是兼容的。注意，这些方法返回一个全新的LocalTime实例，由于其不可变性，返回后一定要用变量赋值。 LocalTime time = LocalTime.now(); LocalTime newTime = time.plusHours(2); // adding two hours System.out.println(&quot;Time after 2 hours : &quot; + newTime); 输出： Time after 2 hours : 18:33:33.369 可以看到，新的时间在当前时间16:33:33.369的基础上增加了2个小时。和旧版Java的增减时间的处理方式对比一下，看看哪种更好。 8、计算一周后的日期和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。LocalDate日期不包含时间信息，它的plus()方法用来增加天、周、月，ChronoUnit类声明了这些时间单位。由于LocalDate也是不变类型，返回后一定要用变量赋值。 LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS); System.out.println(&quot;Today is : &quot; + today); System.out.println(&quot;Date after 1 week : &quot; + nextWeek); 输出： Today is : 2014-01-14Date after 1 week : 2014-01-21 可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看Java 8 API中的ChronoUnit类。 9、计算一年前的日期继续上面的例子，上个例子中我们通过LocalDate的plus()方法增加天数、周数或月数，这个例子我们利用minus()方法计算一年前的日期。 LocalDate previousYear = today.minus(1, ChronoUnit.YEARS); System.out.println(&quot;Date before 1 year : &quot; + previousYear); LocalDate nextYear = today.plus(1, YEARS); System.out.println(&quot;Date after 1 year : &quot; + nextYear); 输出： Date before 1 year : 2013-01-14Date after 1 year : 2015-01-14 例子结果得到了两个日期，一个2013年、一个2015年、分别是2014年的前一年和后一年。 10、使用Clock时钟类Java 8增加了一个Clock时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到System.currentTimeMillis()和TimeZone.getDefault()的地方都可用Clock替换。 // Returns the current time based on your system clock and set to UTC. Clock clock = Clock.systemUTC(); System.out.println(&quot;Clock : &quot; + clock); // Returns time based on system clock zone Clock defaultClock = Clock.systemDefaultZone(); System.out.println(&quot;Clock : &quot; + clock); 输出： Clock : SystemClock[Z]Clock : SystemClock[Z] 还可以针对clock时钟做比较，像下面这个例子： public class MyClass { private Clock clock; // dependency inject ... public void process(LocalDate eventDate) { if (eventDate.isBefore(LocalDate.now(clock)) { ... } } } 这种方式在不同时区下处理日期时会非常管用。 11、比较日期另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在Java 8中，LocalDate类有两类方法isBefore()和isAfter()用于比较日期。调用isBefore()方法时，如果给定日期小于当前日期则返回true。 LocalDate tomorrow = LocalDate.of(2014, 1, 15); if(tommorow.isAfter(today)){ System.out.println(&quot;Tomorrow comes after today&quot;); } LocalDate yesterday = today.minus(1, DAYS); if(yesterday.isBefore(today)){ System.out.println(&quot;Yesterday is day before today&quot;); } 输出： Tomorrow comes after todayYesterday is day before today 在Java 8中比较日期非常方便，不需要使用额外的Calendar类来做这些基础工作了。 12、处理时区Java 8不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如ZoneId来处理特定时区，ZoneDateTime类来表示某时区下的时间。这在Java 8以前都是 GregorianCalendar类来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。 // Date and time with timezone in Java 8 ZoneId america = ZoneId.of(&quot;America/New_York&quot;); LocalDateTime localtDateAndTime = LocalDateTime.now(); ZonedDateTime dateAndTimeInNewYork = ZonedDateTime.of(localtDateAndTime, america ); System.out.println(&quot;Current date and time in a particular timezone : &quot; + dateAndTimeInNewYork); 输出： Current date and time in a particular timezone : 2014-01-14T16:33:33.373-05:00[America/New_York] 和以前使用GMT的方式转换本地时间对比一下。注意，在Java 8以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常： Exception in thread &quot;main&quot; java.time.zone.ZoneRulesException: Unknown time-zone ID: ASIA/Tokyo at java.time.zone.ZoneRulesProvider.getProvider(ZoneRulesProvider.java:272) at java.time.zone.ZoneRulesProvider.getRules(ZoneRulesProvider.java:227) at java.time.ZoneRegion.ofId(ZoneRegion.java:120) at java.time.ZoneId.of(ZoneId.java:403) at java.time.ZoneId.of(ZoneId.java:351) 13、如何表示到期日期答案就是使用YearMonth，与 MonthDay检查重复事件的例子相似，YearMonth是另一个组合类，用于表示信用卡到期日、FD到期日、期货期权到期日等。还可以用这个类得到 当月共有多少天，YearMonth实例的lengthOfMonth()方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。 YearMonth currentYearMonth = YearMonth.now(); System.out.printf(&quot;Days in month year %s: %d%n&quot;, currentYearMonth, currentYearMonth.lengthOfMonth()); YearMonth creditCardExpiry = YearMonth.of(2018, Month.FEBRUARY); System.out.printf(&quot;Your credit card expires on %s %n&quot;, creditCardExpiry); 输出： Days in month year 2014-01: 31Your credit card expires on 2018-02 根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。 14、检查是否是闰年LocalDate类有一个很实用的方法isLeapYear()判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，纯Java逻辑编写的判断闰年的程序。 if(today.isLeapYear()){ System.out.println(&quot;This year is Leap year&quot;); }else { System.out.println(&quot;2014 is not a Leap year&quot;); } 输出： 2014 is not a Leap year 你可以多写几个日期来验证是否是闰年，最好是写JUnit单元测试做判断。 15、求两个日期间隔天数有一个常见日期操作是计算两个日期之间的天数、周数或月数。在Java 8中可以用java.time.Period类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。 LocalDate java8Release = LocalDate.of(2014, Month.MARCH, 14); Period periodToNextJavaRelease = Period.between(today, java8Release); System.out.println(&quot;Months left between today and Java 8 release : &quot; + periodToNextJavaRelease.getMonths() ); 输出： Months left between today and Java 8 release : 2 从上面可以看到现在是一月，Java 8的发布日期是3月，中间相隔两个月。 16、获取时区的时差在Java 8中，ZoneOffset类用来表示时区，举例来说印度与GMT或UTC标准时区相差+05:30，可以通过ZoneOffset.of()静态方法来 获取对应的时区。一旦得到了时差就可以通过传入LocalDateTime和ZoneOffset来创建一个OffSetDateTime对象。 LocalDateTime datetime = LocalDateTime.of(2014, Month.JANUARY, 14, 19, 30); ZoneOffset offset = ZoneOffset.of(&quot;+05:30&quot;); OffsetDateTime date = OffsetDateTime.of(datetime, offset); System.out.println(&quot;Date and Time with timezone offset in Java : &quot; + date); 输出： Date and Time with timezone offset in Java : 2014-01-14T19:30+05:30 现在的时间信息里已经包含了时区信息了。注意：OffSetDateTime是对计算机友好的，ZoneDateTime则对人更友好。 17、获取当前的时间戳如果你还记得Java 8以前是如何获得当前时间戳，那么现在你终于解脱了。Instant类有一个静态工厂方法now()会返回当前的时间戳，如下所示： Instant timestamp = Instant.now(); System.out.println(&quot;What is value of this instant &quot; + timestamp); 输出： What is value of this instant 2014-01-14T08:33:33.379Z 时间戳信息里同时包含了日期和时间，这和java.util.Date很像。实际上Instant类确实等同于 Java 8之前的Date类，你可以使用Date类和Instant类各自的转换方法互相转换，例如：Date.from(Instant) 将Instant转换成java.util.Date，Date.toInstant()则是将Date类转换成Instant类。 18、日期格式化在Java 8以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类SimpleDateFormat也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java 8引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了BASIC_ISO_DATE格式化工具将2014年1月14日格式化成20140114。 String dayAfterTommorrow = &quot;20140116&quot;; LocalDate formatted = LocalDate.parse(dayAfterTommorrow, DateTimeFormatter.BASIC_ISO_DATE); System.out.printf(&quot;Date generated from String %s is %s %n&quot;, dayAfterTommorrow, formatted); 输出： Date generated from String 20140116 is 2014-01-16 很明显的看出得到的日期和给出的日期是同一天，但是格式不同。 19、日期解析上 个例子使用了Java内置的格式化工具去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义 日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用DateTimeFormatter的 ofPattern()静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，M 代表月，m代表分。如果格式不规范会抛出 DateTimeParseException异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。 String goodFriday = &quot;Apr 18 2014&quot;; try { DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;MMM dd yyyy&quot;); LocalDate holiday = LocalDate.parse(goodFriday, formatter); System.out.printf(&quot;Successfully parsed String %s, date is %s%n&quot;, goodFriday, holiday); } catch (DateTimeParseException ex) { System.out.printf(&quot;%s is not parsable!%n&quot;, goodFriday); ex.printStackTrace(); } 输出： Successfully parsed String Apr 18 2014, date is 2014-04-18 日期值与传入的字符串是匹配的，只是格式不同而已。 20、把日期转换成字符串上 两个例子都用到了DateTimeFormatter类，主要是从字符串解析日期。现在我们反过来，把LocalDateTime日期实例转换成特定格式的字符串。这是迄今为止Java日期转字符串最为简单的方式了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建 DateTimeFormatter实例并传入格式，但这回调用的是format()方法，而非parse()方法。这个方法会把传入的日期转化成指定格式的字符串。 LocalDateTime arrivalDate = LocalDateTime.now(); try { DateTimeFormatter format = DateTimeFormatter.ofPattern(&quot;MMM dd yyyy hh:mm a&quot;); String landing = arrivalDate.format(format); System.out.printf(&quot;Arriving at : %s %n&quot;, landing); } catch (DateTimeException ex) { System.out.printf(&quot;%s can&#39;t be formatted!%n&quot;, arrivalDate); ex.printStackTrace(); } 输出： Arriving at : Jan 14 2014 04:33 PM 当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。 Java 8日期时间API的重点通过这些例子，你肯定已经掌握了Java 8日期时间API的新知识点。现在我们来回顾一下这个优雅API的使用要点： 提供了javax.time.ZoneId 获取时区。 提供了LocalDate和LocalTime类。 Java 8 的所有日期和时间API都是不可变类并且线程安全，而现有的Date和Calendar API中的java.util.Date和SimpleDateFormat是非线程安全的。 主包是 java.time,包含了表示日期、时间、时间间隔的一些类。里面有两个子包java.time.format用于格式化， java.time.temporal用于更底层的操作。 时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成（Asia/Tokyo），在加上与格林威治或 UTC的时差。例如：东京的时差是+09:00。 OffsetDateTime类实际上组合了LocalDateTime类和ZoneOffset类。用来表示包含和格林威治或UTC时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。 DateTimeFormatter 类用来格式化和解析时间。与SimpleDateFormat不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。 DateTimeFormatter类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了parse()将字符串解析成日期，如果解析出错会抛出DateTimeParseException。DateTimeFormatter类同时还有format()用来格式化日期，如果出错会抛出DateTimeException异常。 再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。 如何使用Java 8的全新日期时间API就介绍到这了。这些简单的例子对帮助理解新API非常有用。由于这些例子都基于真实任务，你在做Java日期编程时不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java 8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖Joda Time第三方库。新API可以作为处理日期时间操作的标准。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,日期","slug":"Java-日期","permalink":"/tags/Java-日期/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--执行bat和shell&参数处理","slug":"Java核心基础之--执行bat和shell&参数处理","date":"2020-06-06T08:56:10.000Z","updated":"2023-04-30T10:21:41.352Z","comments":true,"path":"2020/06/06/Java核心基础之--执行bat和shell&参数处理/","link":"","permalink":"/2020/06/06/Java核心基础之--执行bat和shell&参数处理/","excerpt":"","text":"之前想着在windows下和linux下调用一些python Scrapy的接口，发现路径问题，传参数问题都挺麻烦，遂改为在bat文件和shell中具体写方法，然后执行他们就好了 1.执行bat脚本(1)传入参数bat处理文件中可引用的参数为%0~%9，%0是指批处理文件的本身，也可以说是一个外部命令；%1~%9是批处理参数，也称形参，例如：新建一个文件test_argv.bat，文件内容如下： @echo off echo param[0] = %0 echo param[1] = %1 echo param[2] = %2 echo param[3] = %3 echo param[4] = %4 echo param[5] = %5 echo ... pause 调用时只需要在执行bat文件后加上参数即可，记得参数间有空格 test_argv.bat 1 game test what 此时输出： param[0] = test_argv.bat param[1] = 1 param[2] = game param[3] = test param[4] = what param[5] = … 请按任意键继续… (2)调用最简单的调用 Runtime.getRuntime().exec(&quot;D:\\\\aaa\\\\remoteDesktop\\\\remoteConnection.bat&quot;); 这样调用是不会有回显的，如果你需要看到返回结果，就需要这样： try { // 执行ping命令 Process process = Runtime.getRuntime().exec(&quot;cmd /c e:&amp;dir&quot;); BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream(), Charset.forName(&quot;GBK&quot;))); String line = null; while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } 注意到了吗，这次的exec函数不是简单的选择bat文件的路径，多了“cmd /c” 这个前缀有以下使用方式： cmd /c dir 是执行完dir命令后关闭命令窗口。 cmd /k dir 是执行完dir命令后不关闭命令窗口。 cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。 cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。 注意：第二个调用方式在bat的输出内容过长时，会卡死！！！T_T 网上的解释说“因为本地进程输入输出缓存有限，你不快点读取的话Process就挂在那了。” 所以需要开一个进程去不断的取数据，具体实现方式见 ：https://blog.csdn.net/aerchi/article/details/7669215 。这个我没有检测，因为我发现，如果bat输出的内容过长时，使用第一种方式，不会卡死，若是想看到输出 可以加前缀cmd /k start，若是想把输出存起来 就加上后缀&gt;&gt; 1.txt，就好了，毕竟还要开线程太繁琐。 2.执行shell文件(1)传入参数shell脚本传入参数与bat基本一致，只不过形参变成了$1,,$2,$3….. 例如，脚本test.sh的内容如下： name=$1 echo &quot;the ${name} are great man!&quot; 执行./test.sh Xiao Ming命令，可以看到自己编写脚本的结果 `the Xiao Ming are great man! (2)调用linux环境果然友好得多，封装好了以下代码，传入shell文件的路径就好了 public static String linuxShellexec(String shellPath) { String result=&quot;&quot;; try { Process ps = Runtime.getRuntime().exec(shellPath); ps.waitFor(); BufferedReader br = new BufferedReader(new InputStreamReader(ps.getInputStream())); StringBuffer sb = new StringBuffer(); String line; while ((line = br.readLine()) != null) { sb.append(line).append(&quot;\\n&quot;); } result = sb.toString(); } catch (Exception e) { e.printStackTrace(); result=&quot;linux下运行完毕&quot;; } return result; } 参考文章https://www.cnblogs.com/happyPawpaw/p/3740903.html https://blog.csdn.net/zyf_balance/article/details/51692065 https://blog.csdn.net/aerchi/article/details/7669215 https://blog.csdn.net/a1010256340/article/details/76187353 https://www.cnblogs.com/abel-hefei/p/7284256.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,bat,shell,参数","slug":"Java-bat-shell-参数","permalink":"/tags/Java-bat-shell-参数/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--float保留多位小数","slug":"Java核心基础之--float保留多位小数","date":"2020-06-06T08:55:10.000Z","updated":"2023-04-30T10:21:41.345Z","comments":true,"path":"2020/06/06/Java核心基础之--float保留多位小数/","link":"","permalink":"/2020/06/06/Java核心基础之--float保留多位小数/","excerpt":"","text":"方法1用Math.round计算,这里返回的数字格式的。 float price=89.89; int itemNum=3; float totalPrice=price*itemNum; float num=(float)(Math.round(totalPrice*100)/100);//如果要求精确4位就*10000然后/10000 方法2用DecimalFormat 返回的是String格式的.该类对十进制进行全面的封装。像%号,千分位，小数精度，科学计算。 float price=1.2; DecimalFormat decimalFormat=new DecimalFormat(&quot;.00&quot;);//构造方法的字符格式这里如果小数不足2位,会以0补足. String p=decimalFomat.format(price);//format 返回的是字符串 个人觉得在前台显示金额方面的还是用第二种方式。理由很简单是字符串格式的。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,float,保留小数","slug":"Java-float-保留小数","permalink":"/tags/Java-float-保留小数/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--IO流","slug":"Java核心基础之--IO流","date":"2020-06-06T08:54:10.000Z","updated":"2023-04-30T10:21:41.341Z","comments":true,"path":"2020/06/06/Java核心基础之--IO流/","link":"","permalink":"/2020/06/06/Java核心基础之--IO流/","excerpt":"","text":"在Java中，对于数据的输入/输出（I/O）操作以“流”（stream）方式进行，数据的来源可以是文件、网络、内存缓存等。 一、JavaIO流的分类J2SDK提供了各种各样的“流”，用以操作不同种类的数据，J2SDK所提供的所有流都位于java.io包内，从不同的角度对这些流进行归类： 按数据流向不同可以分为输入流和输出流。 按处理数据单位不同可以分为字节流和字符流。 按照流类的功能不同可以分为节点流和处理流。 输入流和输出流流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般是站在程序的角度去判断，从数据源读取数据到程序中的是输入流，相反从程序中向外写数据的是输出流。 字节流和字符流 字节流以字节（byte，1byte=8bit）为单位，一个字节一个字节的读写数据。从上图可以看出，所有的字节流均继承自抽象类InputStream/OutputStream。 字符流以字符（Java中，一个字符为2byte=16bit）为单位，一个字符一个字符的读写数据。所有的字符流均继承自抽象类Reader/Writer。 节点流和处理流 节点流为直接与数据源（节点）相连，可以从数据源读写数据的流。 处理流是“连接”在已存在的流（节点流或处理流）之上，可以为程序提供更加强大的读写操作功能的流。 二、InputStream，OutputStream，Reader和WriterInputStream是所有字节输入流的超类，其包含的基本方法如下。 // 从输入流中读取一个字节。并以整数的形式返回（0-255）。 // 如果读取前已经到了输入流的末尾返回-1。 int read() throws IOException; // 从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b中。以整数形式返回实际读取的字节数。 // 如果读取前已经到了输入流的末尾返回-1。 int read(byte[] b) throws IOException; // 读取输入流中len个字节到数组 b中，并将读取的第一个字节存储在元素 b[off] 中，下一个存储在 b[off+1] 中，依次类推。 // 读取的字节数最多等于 len，也可能小于该值。以整数形式返回实际读取的字节数。 // 如果读取前已经到了输入流的末尾返回-1。 int read(byte[] b, int off, int len) throws IOException; // 跳过和丢弃此输入流中数据的 n个字节。返回跳过的实际字节数。 // 如果 n为负数，则不跳过任何字节。 long skip(long n) throws IOException; // 返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。 // 如果到达输入流末尾，则返回 0。 int available() throws IOException; // 关闭此输入流并释放与该流关联的所有系统资源。 void close() throws IOException; // 在此输入流中标记当前的位置。调用reset()方法会根据此标记的位置重新定位此流，以便后续重新读取相同的字节。 // readlimit参数告知此输入流在标记位置失效之前允许读取的字节数。 void mark(int readlimit); // 将此流重新定位到最后一次对此输入流调用 mark()方法时的位置。 void reset() throws IOException; // 测试此输入流是否支持 mark()和 reset() 方法。 // 是否支持 mark()和 reset()是特定输入流实例的不变属性。 boolean markSupported(); OutputStream是所有字节输出流的超类，其包含的基本方法如下。 // 将指定的字节写入此输出流。 // 要写入的字节是参数 b的低8位，b的 24 个高位将被忽略。 void write(int b) throws IOException; // 将一个字节数组中的数据写入输出流。 void write(byte[] b) throws IOException; // 将指定 byte数组中从偏移量 off 开始的 len 个字节写入此输出流。 void write(byte[] b, int off, int len) throws IOException; // 刷新此输出流并强制将输出流中缓存的数据写出。 void flush() throws IOException; // 关闭此输出流并释放与此流有关的所有系统资源。 void close() throws IOException; Reader是所有字符输入流的超类，其包含的基本方法如下。 // 试图将字符读入指定的字符缓冲区。 // 返回添加到缓冲区中的字符数量。 int read(CharBuffer target) throws IOException; // 读取单个字符，并以整数的形式返还，范围在 0 到 65535 之间。 // 如果读取前已经到了输入流的末尾返回-1. int read() throws IOException; // 将字符读入数组cbuf，并返回读取的字符数。 // 如果读取前已经到了输入流的末尾返回-1. int read(char[] cbuf) throws IOException; // 读取输入流中len个字符到数组 cbuf中,并将读取的第一个字符存储在元素cbuf[off]中，下一个存储在 cbuf[off+1]中，依次类推。 // 读取的字符数最多等于 len，也可能小于该值。以整数形式返回实际读取的字符数。 // 如果读取前已经到了输入流的末尾返回-1. int read(char[] cbuf, int off, int len) throws IOException; // 跳过和丢弃此输入流中数据的 n个字符。返回跳过的实际字符数。 // 如果 n 为负数，则不跳过任何字符。 long skip(long n) throws IOException; // 判断是否准备读取此流。 boolean ready() throws IOException; // 关闭此输入流并释放与该流关联的所有系统资源。 void close() throws IOException; // 在此输入流中标记当前的位置。调用reset()方法会根据此标记的位置重新定位此流，以便后续重新读取相同的字符。 // readlimit参数告知此输入流在标记位置失效之前允许读取的字符数。 void mark(int readlimit); // 将此流重新定位到最后一次对此输入流调用 mark()方法时的位置。 void reset() throws IOException; // 测试此输入流是否支持 mark()和 reset() 方法。 // 是否支持 mark()和 reset()是特定输入流实例的不变属性。 boolean markSupported(); Writer是所有字符输出流的超类，其包含的基本方法如下。 // 将指定的字符写入此输出流。 // 要写入的字符是参数 c的低16位。c的 16 个高位将被忽略。 void write(int c) throws IOException; // 将一字符数组中的数据写入输出流。 void write(char[] cbuf) throws IOException; // 将指定 cbuf数组中从偏移量 off 开始的 len 个字符写入此输出流。 void write(char[] cbuf, int off, int len) throws IOException; // 将字符串str写入此输出流。 void write(String str) throws IOException; // 将字符串str中从off开始的len个字符写入此输出流。 void write(String str, int off, int len) throws IOException; // 将指定字符序列添加到此 writer。 Writer append(CharSequence csq) throws IOException; // 将指定字符序列中索引从start到end之间的字符写入到此输出流。 Writer append(CharSequence csq, int start, int end) throws IOException; // 将指定字符添加到此 writer。 Writer append(char c) throws IOException; // 刷新此输出流并强制将输出流中缓冲的数据写出。 void flush() throws IOException; // 关闭此输出流并释放与此流有关的所有系统资源。 void close() throws IOException; 三、节点流根据数据来源不同对节点流进行分类如下图。 四、处理流缓冲流J2SDK提供了四种缓冲流：BufferedReader、BufferedWriter、BufferedInputStream和BufferedOutputStream。缓冲流对读写的数据提供了缓冲的功能，可以提高读写的效率，同时还增加了一些新的方法。 BufferedReader新增了readLine()方法用于读取一行字符串（以\\r或\\n分隔）。 BufferedWriter新增了newLine()方法用于写入一个分隔符。 public static void main(String[] args) { try { BufferedWriter bw = new BufferedWriter(new FileWriter( &quot;D:\\\\io\\\\bufferedTest.txt&quot;)); String s; for (int i = 0; i &lt; 10; i++) { s = String.valueOf(Math.random()); bw.write(s); bw.newLine(); } bw.flush(); bw.close(); Reader reader = new FileReader(&quot;D:\\\\io\\\\bufferedTest.txt&quot;); BufferedReader br = new BufferedReader(reader); while ((s = br.readLine()) != null) { System.out.println(s); } br.close(); } catch (FileNotFoundException e) { System.out.println(&quot;找不到指定文件!&quot;); System.exit(-1); } catch (IOException e) { System.out.println(&quot;系统错误！&quot;); System.exit(-1); } } 转换流J2SDK提供了InputStreamReader和OutputStreamWriter两个转换流，用于将字节流转换为字符流。 public static void main(String[] args) { try { OutputStream outStream = new FileOutputStream( &quot;D:\\\\io\\\\transformIo.txt&quot;); OutputStreamWriter outWriter = new OutputStreamWriter(outStream); outWriter.write(&quot;2017年3月25日风雨大作。。。&quot;); outWriter.close(); outWriter = new OutputStreamWriter(new FileOutputStream( &quot;D:\\\\io\\\\transformIo.txt&quot;, true), &quot;GBK&quot;); outWriter.write(&quot;2017年3月26日电闪雷鸣。。。&quot;); outWriter.close(); } catch (FileNotFoundException e) { System.out.println(&quot;找不到指定文件!&quot;); System.exit(-1); } catch (UnsupportedEncodingException e) { System.out.println(&quot;编码异常！&quot;); System.exit(-1); } catch (IOException e) { System.out.println(&quot;写入错误！&quot;); System.exit(-1); } System.out.println(&quot;写入成功！&quot;); } 数据流J2SDK提供了DataInputStream和DataOutputStream两个数据流，用以提供存取与机器无关的Java原始数据类型数据（如：int，double等）的方法。 public static void main(String[] args) { try { ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); DataOutputStream dataOut = new DataOutputStream(byteOut); dataOut.writeChar(65); dataOut.writeUTF(&quot;B&quot;); dataOut.writeBoolean(false); dataOut.writeChars(&quot;CD&quot;); dataOut.writeFloat(0.1111f); dataOut.close(); DataInputStream dataIn = new DataInputStream( new ByteArrayInputStream(byteOut.toByteArray())); System.out.println(dataIn.readChar()); System.out.println(dataIn.readUTF()); System.out.println(dataIn.readBoolean()); System.out.println(dataIn.readChar()); System.out.println(dataIn.readChar()); System.out.println(dataIn.readFloat()); } catch (IOException e) { System.out.println(&quot;写入错误！&quot;); System.exit(-1); } } Print流J2SDK提供了PrintWriter和PrintStream两个Print流，提供了重载的print()和println()方法用于多种数据类型的输出。 public static void main(String[] args) { try { FileOutputStream in = new FileOutputStream( &quot;D:\\\\io\\\\PrintIoTest.txt&quot;); PrintStream printer = new PrintStream(in); System.setOut(printer); BufferedReader br = new BufferedReader(new InputStreamReader( System.in)); String s; while ((s = br.readLine()) != null) { if (s.equalsIgnoreCase(&quot;exit&quot;)) { break; } System.out.println(s); } } catch (IOException e) { System.out.println(&quot;系统错误！&quot;); System.exit(-1); } } Object流J2SDK提供了ObjectInputStream和ObjectOutputStream两个Object流，用于将实现了Serializable接口的对象实例直接以二进制的形式进行存取的方法。 import java.io.Serializable; class User implements Serializable { private static final long serialVersionUID = 1L; String userName; int userAge; transient String phoneNum; } public static void main(String[] args) { User user = new User(); user.phoneNum = &quot;0756-8888888&quot;; user.userAge = 17; user.userName = &quot;弄玉&quot;; OutputStream os; try { os = new FileOutputStream(&quot;D:\\\\io\\\\ObjectIoTest.txt&quot;); ObjectOutputStream oos = new ObjectOutputStream(os); oos.writeObject(user); oos.flush(); oos.close(); FileInputStream fis = new FileInputStream( &quot;D:\\\\io\\\\ObjectIoTest.txt&quot;); ObjectInputStream ois = new ObjectInputStream(fis); user = (User) ois.readObject(); System.out.println(user.userName + &quot; &quot; + user.userAge + &quot; &quot; + user.phoneNum); ois.close(); } catch (FileNotFoundException e) { System.out.println(&quot;找不到指定文件!&quot;); System.exit(-1); } catch (ClassNotFoundException e) { System.out.println(&quot;类型错误!&quot;); System.exit(-1); } catch (IOException e) { System.out.println(&quot;系统错误！&quot;); System.exit(-1); } } 对于对象中使用transient关键字修饰的属性在序列化时将被忽略。对象还可以通过实现Externalizable接口，并实现writeExternal()和readExternal()方法来自己指定序列化和反序列化的实现过程。 五、流操作的典型示例import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; public class FileOperator { private static final int bytes = 1024 * 1024; /** * 文件复制 * @param sourcePath 文件源路径，例如：“D:\\\\IO\\text.txt” * @param targetPath 目标文件路径 */ public static void copyFile(String sourcePath, String targetPath) { File sourceFile = new File(sourcePath); long targetSize = 0; try { byte[] buffer = new byte[bytes]; InputStream inStream = new FileInputStream(sourceFile); // 读入源文件 OutputStream outStream = new FileOutputStream(targetPath); int len; while ((len = inStream.read(buffer)) &gt; 0) { outStream.write(buffer, 0, len); targetSize += len; } outStream.close(); inStream.close(); } catch (FileNotFoundException e) { System.out.println(&quot;系统找不到指定文件：&quot; + sourcePath); System.exit(-1); } catch (IOException e) { System.out.println(&quot;文件复制发生错误，复制失败！&quot;); System.exit(-1); } System.out.println(&quot;复制完成：&quot;); System.out.println(&quot;源文件大小：&quot; + sourceFile.length()); System.out.println(&quot;复制大小：&quot; + targetSize); } public static void main(String[] args) { String sourcePath = &quot;D:\\\\io\\\\&quot;; String targetPath = &quot;D:\\\\a&quot;; File file=new File(sourcePath); System.out.println(file.getAbsolutePath()); System.out.println(file.getPath()); System.out.println(file.getName()); System.out.println(file.getParent()); copyFolder(sourcePath, targetPath); } /** * 复制文件夹 * @param sourcePath 文件夹源路径，例如:“D:\\\\IO” * @param targetPath 目标文件夹路径 */ public static void copyFolder(String sourcePath, String targetPath) { File sourceFile = new File(sourcePath); File targetFolder=new File(targetPath); if(!targetFolder.exists()){ targetFolder.mkdirs(); } if(sourceFile.isDirectory()){ File[] files=sourceFile.listFiles(); for(File file:files){ if(file.isDirectory()){ copyFolder(file.getAbsolutePath(), targetPath+File.separator+file.getName());} else{ copyFile(file.getAbsolutePath(),targetPath+File.separator+file.getName()); } } } else{ copyFile(sourcePath,targetPath+File.separator+sourceFile.getName()); } } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,IO,流","slug":"Java-IO-流","permalink":"/tags/Java-IO-流/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Instrumentation","slug":"Java核心基础之--Instrumentation","date":"2020-06-06T08:53:10.000Z","updated":"2023-04-30T10:21:41.342Z","comments":true,"path":"2020/06/06/Java核心基础之--Instrumentation/","link":"","permalink":"/2020/06/06/Java核心基础之--Instrumentation/","excerpt":"","text":"利用 Java 代码，即 java.lang.instrument 做动态Instrumentation 是 Java SE 5 的新特性，它把 Java 的 instrument 功能从本地代码中解放出来，使之可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。 在 Java SE 6 里面，instrumentation 包被赋予了更强大的功能：启动后的 instrument、本地代码（native code）instrument，以及动态改变 classpath等等。这些改变，意味着 Java 具有了更强的动态控制、解释能力，它使得 Java 语言变得更加灵活多变。 在 Java SE6 里面，最大的改变使运行时的 Instrumentation 成为可能。在 Java SE 5 中，Instrument 要求在运行前利用命令行参数或者系统参数来设置代理类，在实际的运行之中，虚拟机在初始化之时（在绝大多数的 Java 类库被载入之前），instrumentation 的设置已经启动，并在虚拟机中设置了回调函数，检测特定类的加载情况，并完成实际工作。但是在实际的很多的情况下，我们没有办法在虚拟机启动之时就为其设定代理，这样实际上限制了 instrument 的应用。而 Java SE 6 的新特性改变了这种情况，通过 Java Tool API 中的 attach 方式，我们可以很方便地在运行过程中动态地设置加载代理类，以达到 instrumentation 的目的。 另外，对native 的 Instrumentation也是 Java SE 6 的一个崭新的功能，这使以前无法完成的功能 —— 对 native 接口的 instrumentation 可以在 Java SE 6 中，通过一个或者一系列的 prefix 添加而得以完成。 最后，Java SE 6 里的 Instrumentation 也增加了动态添加 class path的功能。所有这些新的功能，都使得 instrument 包的功能更加丰富，从而使 Java 语言本身更加强大。 Instrumentation 的基本功能和用法“java.lang.instrument”包的具体实现，依赖于 JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 是从 Java SE 5 开始引入，整合和取代了以前使用的 Java Virtual Machine Profiler Interface(JVMPI)和 the Java Virtual Machine Debug Interface(JVMDI)，而在 Java SE 6 中，JVMPI 和 JVMDI 已经消失了。JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。事实上，java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成Java 类的动态操作。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。关于 JVMTI 的详细信息，请参考 Java SE 6 文档中的介绍。 Instrumentation 的最大作用，就是类定义动态改变和操作。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 -javaagent参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。 在 Java SE 5 当中，开发者可以让 Instrumentation 代理在 main 函数运行前执行。简要说来就是如下几个步骤： (1) 编写 premain 函数编写一个 Java 类，包含如下两个方法当中的任何一个： public static void premain(String agentArgs, Instrumentation inst); // [1] public static void premain(String agentArgs); // [2] 其中，[1] 的优先级比 [2] 高，将会被优先执行（[1] 和 [2] 同时存在时，[2] 被忽略）。在这个 premain 函数中，开发者可以进行对类的各种操作。 agentArgs 是 premain 函数得到的程序参数，随同 “-javaagent”一起传入。与 main 函数不同的是，这个参数是一个字符串而不是一个字符串数组，如果程序参数有多个，程序将自行解析这个字符串。 Inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 (2) jar 文件打包将这个 Java 类打包成一个 jar 文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。（可能还需要指定其他属性以开启更多功能） (3) 运行用如下方式运行带有 Instrumentation 的 Java 程序： java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ] 对 Java 类文件的操作，可以理解为对一个 byte 数组的操作（将类文件的二进制字节流读入一个 byte 数组）。开发者可以在“ClassFileTransformer”的 transform 方法当中得到，操作并最终返回一个类的定义（一个 byte 数组）。这方面，Apache 的 BCEL 开源项目提供了强有力的支持，具体的字节码操作并非本文的重点，所以，本文中所举的例子，只是采用简单的类文件替换的方式来演示 Instrumentation 的使用。 下面，我们通过简单的举例，来说明 Instrumentation 的基本使用方法。 首先，我们有一个简单的类，TransClass， 可以通过一个静态方法返回一个整数 1。 public class TransClass { public int getNumber() { return 1; } } 我们运行如下类，可以得到输出 ”1“。 public class TestMainInJar { public static void main(String[] args) { System.out.println(new TransClass().getNumber()); } } 然后，我们将 TransClass 的 getNumber 方法改成如下 : public int getNumber() { return 2; } 再将这个返回 2 的 Java 文件编译成类文件，为了区别开原有的返回 1 的类，我们将返回 2 的这个类文件命名为 TransClass2.class.2。 接下来，我们建立一个 Transformer 类： import java.lang.instrument.ClassFileTransformer; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; class Transformer implements ClassFileTransformer { public static final String classNumberReturns2 = &quot;TransClass.class.2&quot;; public static byte[] getBytesFromFile(String fileName) { try { // precondition File file = new File(fileName); InputStream is = new FileInputStream(file); long length = file.length(); byte[] bytes = new byte[(int) length]; // Read in the bytes int offset = 0; int numRead = 0; while (offset &lt;bytes.length &amp;&amp; (numRead = is.read(bytes, offset, bytes.length - offset)) &gt;= 0) { offset += numRead; } if (offset &lt; bytes.length) { throw new IOException(&quot;Could not completely read file &quot; + file.getName()); } is.close(); return bytes; } catch (Exception e) { System.out.println(&quot;error occurs in _ClassTransformer!&quot; + e.getClass().getName()); return null; } } public byte[] transform(ClassLoader l, String className, Class&lt;?&gt; c, ProtectionDomain pd, byte[] b) throws IllegalClassFormatException { if (!className.equals(&quot;TransClass&quot;)) { return null; } return getBytesFromFile(classNumberReturns2); } } 这个类实现了 ClassFileTransformer 接口。其中，getBytesFromFile 方法根据文件名读入二进制字符流，而 ClassFileTransformer 当中规定的 transform 方法则完成了类定义的替换转换。 最后，我们建立一个 Premain 类，写入 Instrumentation 的代理方法 premain： public class Premain { public static void premain(String agentArgs， Instrumentation inst) throws ClassNotFoundException， UnmodifiableClassException { inst.addTransformer(new Transformer()); } } 可以看出，addTransformer 方法并没有指明要转换哪个类。转换发生在 premain 函数执行之后，main 函数执行之前，这时每装载一个类，transform 方法就会执行一次，看看是否需要转换，所以，在 transform（Transformer 类中）方法中，程序用 className.equals(“TransClass”) 来判断当前的类是否需要转换。 代码完成后，我们将他们打包为 TestInstrument1.jar。返回 1 的那个 TransClass 的类文件保留在 jar 包中，而返回 2 的那个 TransClass.class.2 则放到 jar 的外面。在 manifest 里面加入如下属性来指定 premain 所在的类： Manifest-Version: 1.0 Premain-Class: Premain 在运行这个程序的时候，如果我们用普通方式运行这个 jar 中的 main 函数，可以得到输出“1”。如果用下列方式运行 : java -javaagent:TestInstrument1.jar -cp TestInstrument1.jar TestMainInJar 则会得到输出“2”。 当然，程序运行的 main 函数不一定要放在 premain 所在的这个 jar 文件里面，这里只是为了例子程序打包的方便而放在一起的。 除了用 addTransformer 的方式，Instrumentation 当中还有另外一个方法“redefineClasses”来实现 premain 当中指定的转换。用法类似，如下： public class Premain { public static void premain(String agentArgs， Instrumentation inst) throws ClassNotFoundException， UnmodifiableClassException { ClassDefinition def = new ClassDefinition(TransClass.class， Transformer.getBytesFromFile(Transformer.classNumberReturns2)); inst.redefineClasses(new ClassDefinition[] { def }); System.out.println(&quot;success&quot;); } } redefineClasses 的功能比较强大，可以批量转换很多类。 Java SE 6 的新特性：虚拟机启动后的动态 instrument在 Java SE 5 当中，开发者只能在 premain 当中施展想象力，所作的 Instrumentation 也仅限与 main 函数执行前，这样的方式存在一定的局限性。 在 Java SE 5 的基础上，Java SE 6 针对这种状况做出了改进，开发者可以在main 函数开始执行以后，再启动自己的 Instrumentation 程序。 在 Java SE 6 的 Instrumentation 当中，有一个跟 premain“并驾齐驱”的“agentmain”方法，可以在 main 函数开始运行之后再运行。跟 premain 函数一样， 开发者可以编写一个含有“agentmain”函数的 Java 类： public static void agentmain (String agentArgs, Instrumentation inst); //[1] public static void agentmain (String agentArgs); //[2] 同样，[1] 的优先级比 [2] 高，将会被优先执行。跟 premain 函数一样，开发者可以在 agentmain 中进行对类的各种操作。其中的 agentArgs 和 Inst 的用法跟 premain 相同。 与“Premain-Class”类似，开发者必须在 manifest 文件里面设置“Agent-Class”来指定包含 agentmain 函数的类。可是，跟 premain 不同的是，agentmain 需要在 main 函数开始运行后才启动，这样的时机应该如何确定呢，这样的功能又如何实现呢？ 在 Java SE 6 文档当中，开发者也许无法在 java.lang.instrument 包相关的文档部分看到明确的介绍，更加无法看到具体的应用 agnetmain 的例子。不过，在 Java SE 6 的新特性里面，有一个不太起眼的地方，揭示了 agentmain 的用法。这就是Java SE 6 当中提供的 Attach API。 Attach API 不是 Java 的标准 API，而是 Sun 公司提供的一套扩展 API，用来向目标 JVM ”附着”（Attach）代理工具程序的。有了它，开发者可以方便的监控一个 JVM，运行一个外加的代理程序。 Attach API 很简单，只有 2 个主要的类，都在 com.sun.tools.attach 包里面：VirtualMachine 代表一个 Java 虚拟机，也就是程序需要监控的目标虚拟机，提供了 JVM 枚举，Attach 动作和 Detach 动作（Attach 动作的相反行为，从 JVM 上面解除一个代理）等等 ;VirtualMachineDescriptor 则是一个描述虚拟机的容器类，配合 VirtualMachine 类完成各种功能。 为了简单起见，我们举例简化如下：依然用类文件替换的方式，将一个返回 1 的函数替换成返回 2 的函数，Attach API 写在一个线程里面，用睡眠等待的方式，每隔半秒时间检查一次所有的 Java 虚拟机，当发现有新的虚拟机出现的时候，就调用 attach 函数，随后再按照 Attach API 文档里面所说的方式装载 Jar 文件。等到 5 秒钟的时候，attach 程序自动结束。而在 main 函数里面，程序每隔半秒钟输出一次返回值（显示出返回值从 1 变成 2）。 TransClass 类和 Transformer 类的代码不变，参看上一节介绍。 含有 main 函数的 TestMainInJar 代码为： public class TestMainInJar { public static void main(String[] args) throws InterruptedException { System.out.println(new TransClass().getNumber()); int count = 0; while (true) { Thread.sleep(500); count++; int number = new TransClass().getNumber(); System.out.println(number); if (3 == number || count &gt;= 10) { break; } } } } 含有 agentmain 的 AgentMain 类的代码为： import java.lang.instrument.ClassDefinition; import java.lang.instrument.Instrumentation; import java.lang.instrument.UnmodifiableClassException; public class AgentMain { public static void agentmain(String agentArgs, Instrumentation inst) throws ClassNotFoundException, UnmodifiableClassException, InterruptedException { inst.addTransformer(new Transformer (), true); inst.retransformClasses(TransClass.class); System.out.println(&quot;Agent Main Done&quot;); } } 其中，retransformClasses 是 Java SE 6 里面的新方法，它跟 redefineClasses 一样，可以批量转换类定义，多用于 agentmain 场合。 Jar 文件跟 Premain 那个例子里面的 Jar 文件差不多，也是把 main 和 agentmain 的类，TransClass，Transformer 等类放在一起，打包为“TestInstrument1.jar”，而 Jar 文件当中的 Manifest 文件为 : Manifest-Version: 1.0 Agent-Class: AgentMain 另外，为了运行 Attach API，我们可以再写一个控制程序来模拟监控过程：（代码片段） import com.sun.tools.attach.VirtualMachine; import com.sun.tools.attach.VirtualMachineDescriptor; …… // 一个运行 Attach API 的线程子类 static class AttachThread extends Thread { private final List&lt;VirtualMachineDescriptor&gt; listBefore; private final String jar; AttachThread(String attachJar, List&lt;VirtualMachineDescriptor&gt; vms) { listBefore = vms; // 记录程序启动时的 VM 集合 jar = attachJar; } public void run() { VirtualMachine vm = null; List&lt;VirtualMachineDescriptor&gt; listAfter = null; try { int count = 0; while (true) { listAfter = VirtualMachine.list(); for (VirtualMachineDescriptor vmd : listAfter) { if (!listBefore.contains(vmd)) { // 如果 VM 有增加，我们就认为是被监控的 VM 启动了 // 这时，我们开始监控这个 VM vm = VirtualMachine.attach(vmd); break; } } Thread.sleep(500); count++; if (null != vm || count &gt;= 10) { break; } } vm.loadAgent(jar); vm.detach(); } catch (Exception e) { ignore } } } …… public static void main(String[] args) throws InterruptedException { new AttachThread(&quot;TestInstrument1.jar&quot;, VirtualMachine.list()).start(); } } 运行时，可以首先运行上面这个启动新线程的 main 函数，然后，在 5 秒钟内（仅仅简单模拟 JVM 的监控过程）运行如下命令启动测试 Jar 文件 : java – javaagent:TestInstrument2.jar – cp TestInstrument2.jar TestMainInJar 如果时间掌握得不太差的话，程序首先会在屏幕上打出 1，这是改动前的类的输出，然后会打出一些 2，这个表示 agentmain 已经被 Attach API 成功附着到 JVM 上，代理程序生效了，当然，还可以看到“Agent Main Done”字样的输出。 以上例子仅仅只是简单示例，简单说明这个特性而已。真实的例子往往比较复杂，而且可能运行在分布式环境的多个 JVM 之中。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Java,Instrumentation","slug":"Java-Instrumentation","permalink":"/tags/Java-Instrumentation/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--获取302响应中的Location信息","slug":"Java核心基础之--获取302响应中的Location信息","date":"2020-06-06T08:52:10.000Z","updated":"2023-04-30T10:21:41.353Z","comments":true,"path":"2020/06/06/Java核心基础之--获取302响应中的Location信息/","link":"","permalink":"/2020/06/06/Java核心基础之--获取302响应中的Location信息/","excerpt":"","text":"HttpClient获取302响应中的Location头信息public static String getLocationUrl(String url) { RequestConfig config = RequestConfig.custom().setConnectTimeout(50000).setConnectionRequestTimeout(10000).setSocketTimeout(50000) .setRedirectsEnabled(false).build();//不允许重定向 CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(config).build(); String location = null; int responseCode = 0; HttpResponse response; try { response = httpClient.execute(new HttpGet(url)); responseCode = response.getStatusLine().getStatusCode(); if (responseCode == 302) { Header locationHeader = response.getFirstHeader(&quot;Location&quot;); location = locationHeader.getValue(); } } catch (Exception e) { e.printStackTrace(); } return location; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"302,Java,Location","slug":"302-Java-Location","permalink":"/tags/302-Java-Location/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Future","slug":"Java核心基础之--Future","date":"2020-06-06T08:51:10.000Z","updated":"2023-04-30T10:21:41.341Z","comments":true,"path":"2020/06/06/Java核心基础之--Future/","link":"","permalink":"/2020/06/06/Java核心基础之--Future/","excerpt":"","text":"参考书籍：《Java特种兵（上册）》 接口 Future&lt;V&gt; 可用于获取异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get() 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel() 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型，并返回 null 作为底层任务的结果。 package java.util.concurrent; import java.util.concurrent.ExecutionException; import java.util.concurrent.TimeUnit; import java.util.concurrent.TimeoutException; public interface Future&lt;V&gt; { /* * 尝试将任务的状态修改为CANCELLED * 该动作若将状态成功修改为CANCELLED，则会释放AQS的锁，成功返回true，失败返回false * 传入的boolean参数如果为true，则判定如果有正在运行的线程 runner，则会将其中断 */ boolean cancel(boolean mayInterruptIfRunning); /* * 判定任务的状态是否为CANCELLED */ boolean isCancelled(); /* * 判定任务是否结束 * 该方法不会阻塞，若返回true，则表示任务已经结束 */ boolean isDone(); /* * 尝试获取任务结束的返回值 * 如果是Runnable 则通常返回null，如果是Callable 则返回对应的return值 * 若任务尚未结束，则当前线程将会等待直到任务结束才返回 */ V get() throws InterruptedException, ExecutionException; /* * 尝试获取任务结束的返回值 * 达到设置的超时时间后，则会自动放弃等待，并抛出TimeoutException异常 */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } Future 接口有很多实现类，用得较多的是FutureTask，用于实现可取消的异步计算功能：利用开始和取消计算的方法、查询计算是否完成的方法和获取计算结果的方法。此类提供了对 Future 的基本实现，仅在计算完成时才能获取结果，如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。 下面是一个使用FutureTask进行异步计算的简单样例。 package com.pengjunlee; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class FutureTaskTest { static class CallableImpl implements Callable&lt;Integer&gt; { private int[] addends; public CallableImpl(int[] addends) { this.addends = addends; } public Integer call() throws Exception { int sum = 0; // 简单的数学计算，求出addends数组内的数字总和 for (int i = 0; i &lt; addends.length; i++) { sum += addends[i]; } return sum; } } public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executorService = Executors.newFixedThreadPool(3); // 以数学计算获取(1+2+3)*(4+5+6)*(7+8+9+10)的结果为例 int sum1 = executorService.submit( new CallableImpl(new int[] { 1, 2, 3 })).get(); int sum2 = executorService.submit( new CallableImpl(new int[] { 4, 5, 6 })).get(); int sum3 = executorService.submit( new CallableImpl(new int[] { 7, 8, 9, 10 })).get(); int result = sum1 * sum2 * sum3; System.out.println(&quot;(1+2+3)*(4+5+6)*(7+8+9+10)= &quot; + result); } } 运算结果： (1+2+3)*(4+5+6)*(7+8+9+10)= 3060 FutureTask内部有一个sync属性，这个属性所在的类是AQS（AbstractQueuedSynchronizer）的子类，即它是基于AQS来实现的。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Future,Java","slug":"Future-Java","permalink":"/tags/Future-Java/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java核心基础之--Base64编码与解码","slug":"Java核心基础之--Base64编码与解码","date":"2020-06-06T08:50:10.000Z","updated":"2023-04-30T10:21:41.341Z","comments":true,"path":"2020/06/06/Java核心基础之--Base64编码与解码/","link":"","permalink":"/2020/06/06/Java核心基础之--Base64编码与解码/","excerpt":"","text":"Base64简介Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。 按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） BASE64编码原理Base64要求把每三个8Bit的字节转换为四个6Bit的字节（3*8 = 4*6 = 24），然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。 Base64编码遵循以下规则： 把3个字符变成4个字符。 每76个字符加一个换行符。 最后的结束符也要处理。 转码过程示例： 3*8=4*6 内存1个字节占8位 转前： s 1 3 先转成ascii：对应 115 49 51 再转成2进制：01110011 00110001 00110011 3*8、共24位： 01110011 00110001 00110011 6位一组、分为4组：011100 110011 000100 110011 然而计算机是以byte（1byte=8位）为最小单位进行数据存储的，6位不够8位，高位需补0 每一组高位补两个0： 00011100 00110011 00000100 00110011 得到4个整数值： 28 51 4 51 对照转换表：结果c z E z 从严格意义上来说，BASE64编码算法并不算是真正的加密算法，它只是将源数据转码成为了一种不易阅读的形式，而转码的规则是公开的（解码很容易）。转码之后的数据具有不可读性，需要解码后才能阅读。 注：BASE64加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。 Java实现BASE64反射/* encode by Base64 */ public static String encodeBase64(byte[] input) throws Exception { Class clazz = Class.forName(&quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64&quot;); Method mainMethod = clazz.getMethod(&quot;encode&quot;, byte[].class); mainMethod.setAccessible(true); Object retObj = mainMethod.invoke(null, new Object[] { input }); return (String) retObj; } /* decode by Base64 */ public static byte[] decodeBase64(String input) throws Exception { Class clazz = Class.forName(&quot;com.sun.org.apache.xerces.internal.impl.dv.util.Base64&quot;); Method mainMethod = clazz.getMethod(&quot;decode&quot;, String.class); mainMethod.setAccessible(true); Object retObj = mainMethod.invoke(null, input); return (byte[]) retObj; } 使用commons-codec.jar/* encode by Base64 */ public static String encodeBase64(byte[] input) throws Exception { return new String(Base64.encodeBase64(input)); } /* decode by Base64 */ public static byte[] decodeBase64(String input) throws Exception { return Base64.decodeBase64(input); } Base64.encodeBase64()有几个重载的方法： Base64.encodeBase64(binaryData) //默认不换行 Base64.encodeBase64(binaryData, isChunked) //isChunked为true时换行,false不换行 Base64.encodeBase64Chunked(binaryData) //默认换行 Base64.encodeBase64String(binaryData) //以字符串形式返回 然而，标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。 为解决此问题，可采用一种用于URL的改进Base64编码，它不仅在末尾去掉填充的’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“_”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。 Base64中有以下几个方法，用于提供安全的URL(转换+为-、/为_、将多余的=去掉)： Base64.encodeBase64(binaryData, isChunked, urlSafe)//urlSafe为true时进行安全转换 Base64.encodeBase64URLSafe(binaryData)//默认进行安全转换 Base64.encodeBase64URLSafeString(binaryData)//默认进行安全转换，并以字符串形式返回 使用sun.misc.BASE64Encoder和sun.misc.BASE64Decoder /* encode by Base64 */ public static String encodeBase64(byte[] input) throws Exception { return new BASE64Encoder().encode(input); } /* decode by Base64 */ public static byte[] decodeBase64(String input) throws Exception { byte[] output = null; try { BASE64Decoder decoder = new BASE64Decoder(); output = decoder.decodeBuffer(input); } catch (IOException e) { e.printStackTrace(); } return output; } 注：在eclipse中对sun.misc包默认访问策略为Forbidden(禁止)，会导致该包无法导入，解决办法：--&gt;右键项目 --&gt;Properties --&gt;Java Bulid Path-&gt; Libraries--&gt;JRE System Library--&gt;Access rules--&gt;双击Type Access Rules在Accessible中添加accessible，下面填上** 点击确定。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"Base64,Java,编码与解码","slug":"Base64-Java-编码与解码","permalink":"/tags/Base64-Java-编码与解码/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Eureka注册探秘","slug":"SpringCloud之--Eureka注册探秘","date":"2020-05-31T08:51:38.000Z","updated":"2023-04-30T10:21:41.365Z","comments":true,"path":"2020/05/31/SpringCloud之--Eureka注册探秘/","link":"","permalink":"/2020/05/31/SpringCloud之--Eureka注册探秘/","excerpt":"","text":"转载自：Eureka中RetryableClientQuarantineRefreshPercentage参数探秘 前言我们知道Eureka分为两部分，Eureka Server和Eureka Client。Eureka Server充当注册中心的角色，Eureka Client相对于Eureka Server来说是客户端，需要将自身信息注册到注册中心。本文主要介绍的就是在Eureka Client注册到Eureka Server时RetryableClientQuarantineRefreshPercentage参数的使用技巧。 Eureka Client注册过程分析Eureka Client注册到Eureka Server时，首先遇到第一个问题就是Eureka Client端要知道Server的地址，这个参数对应的是eureka.client.service-url.defaultZone，举个例子，在Eureka Client的properties文件中配置如下： eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka 如上所示，Eureka Client配置对应的Eureka Server地址分别是8761、8762、8763、8764。这里存在两个问题： Eureka Client会将自身信息分别注册到这四个地址吗？ Eureka Clinent注册机制是怎样的？ 源码面前一目了然，带着这两个问题我们通过源码来解答这两个问题。Eureka Client在启动的时候注册源码如下：RetryableEurekaHttpClient中的execut方法 @Override protected &lt;R&gt; EurekaHttpResponse&lt;R&gt; execute(RequestExecutor&lt;R&gt; requestExecutor) { List&lt;EurekaEndpoint&gt; candidateHosts = null; int endpointIdx = 0; for (int retry = 0; retry &lt; numberOfRetries; retry++) { EurekaHttpClient currentHttpClient = delegate.get(); EurekaEndpoint currentEndpoint = null; if (currentHttpClient == null) { if (candidateHosts == null) { candidateHosts = getHostCandidates(); if (candidateHosts.isEmpty()) { throw new TransportException(&quot;There is no known eureka server; cluster server list is empty&quot;); } } if (endpointIdx &gt;= candidateHosts.size()) { throw new TransportException(&quot;Cannot execute request on any known server&quot;); } currentEndpoint = candidateHosts.get(endpointIdx++); currentHttpClient = clientFactory.newClient(currentEndpoint); } try { EurekaHttpResponse&lt;R&gt; response = requestExecutor.execute(currentHttpClient); if (serverStatusEvaluator.accept(response.getStatusCode(), requestExecutor.getRequestType())) { delegate.set(currentHttpClient); if (retry &gt; 0) { logger.info(&quot;Request execution succeeded on retry #{}&quot;, retry); } return response; } logger.warn(&quot;Request execution failure with status code {}; retrying on another server if available&quot;, response.getStatusCode()); } catch (Exception e) { logger.warn(&quot;Request execution failed with message: {}&quot;, e.getMessage()); // just log message as the underlying client should log the stacktrace } // Connection error or 5xx from the server that must be retried on another server delegate.compareAndSet(currentHttpClient, null); if (currentEndpoint != null) { quarantineSet.add(currentEndpoint); } } throw new TransportException(&quot;Retry limit reached; giving up on completing the request&quot;); } 按照我的理解，代码精简后内容如下： int endpointIdx = 0; //用来保存所有Eureka Server信息(8761、8762、8763、8764) List&lt;EurekaEndpoint&gt; candidateHosts = null; //numberOfRetries的值代码写死默认为3次 for (int retry = 0; retry &lt; numberOfRetries; retry++) { /** *首次进入循环时，获取全量的Eureka Server信息(8761、8762、8763、8764) */ if (candidateHosts == null) { candidateHosts = getHostCandidates(); } /** *通过endpointIdx自增，依次获取Eureka Server信息，然后发送 *注册的Post请求. */ currentEndpoint = candidateHosts.get(endpointIdx++); currentHttpClient = clientFactory.newClient(currentEndpoint); try { /** *发送注册的Post请求动作，注意如果成功，则跳出循环，如果失败则 *根据endpointIdx依次获取下一个Eureka Server. */ response = requestExecutor.execute(currentHttpClient); return respones; } catch (Exception e) { //向注册中心(Eureka Server)发起注册的post出现异常时，打印日志... } //如果此次注册动作失败，将当前的信息保存到quarantineSet中(一个Set集合) if (currentEndpoint != null) { quarantineSet.add(currentEndpoint); } } //如果都失败,则以异常形式抛出... throw new TransportException(&quot;Retry limit reached; giving up on completing the request&quot;); 上面代码中还有一个方法很重要就是 List candidateHosts = getHostCandidates();接下来看下getHostCandidates()方法源码。 private List&lt;EurekaEndpoint&gt; getHostCandidates() { List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints(); quarantineSet.retainAll(candidateHosts); // If enough hosts are bad, we have no choice but start over again int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); if (quarantineSet.isEmpty()) { // no-op } else if (quarantineSet.size() &gt;= threshold) { logger.debug(&quot;Clearing quarantined list of size {}&quot;, quarantineSet.size()); quarantineSet.clear(); } else { List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) { if (!quarantineSet.contains(endpoint)) { remainingHosts.add(endpoint); } } candidateHosts = remainingHosts; } return candidateHosts; } 按照我的理解，将代码精简下，只包括关键逻辑，内容如下： private List&lt;EurekaEndpoint&gt; getHostCandidates() { /** * 获取所有defaultZone配置的注册中心信息(Eureka Server)， * 在本文例子中代表4个(8761、8762、8763、8764)Eureka Server */ List candidateHosts = clusterResolver.getClusterEndpoints(); /** * quarantineSet这个Set集合中保存的是不可用的Eureka Server * 此处是拿不可用的Eureka Server与全量的Eureka Server取交集 */ quarantineSet.retainAll(candidateHosts); /** * 根据RetryableClientQuarantineRefreshPercentage参数计算阈值 * 该阈值后续会和quarantineSet中保存的不可用的Eureka Server个数 * 作比较，从而判断是否返回全量的Eureka Server还是过滤掉不可用的 * Eureka Server。 */ int threshold = (int) ( candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage() ); if (quarantineSet.isEmpty()) { /** * 首次进入的时候，此时quarantineSet为空，直接返回全量的 * Eureka Server列表 */ } else if (quarantineSet.size() &gt;= threshold) { /** * 将不可用的Eureka Server与threshold值相比较，如果不可 * 用的Eureka Server个数大于阈值，则将之前保存的Eureka * Server内容直接清空，并返回全量的Eureka Server列表。 */ quarantineSet.clear(); } else { /** * 通过quarantineSet集合保存不可用的Eureka Server来过滤 * 全量的EurekaServer，从而获取此次Eureka Client要注册要 * 注册的Eureka Server实例地址。 */ List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) { if (!quarantineSet.contains(endpoint)) { remainingHosts.add(endpoint); } } candidateHosts = remainingHosts; } return candidateHosts; } 通过源码分析，我们现在初步知道，当Eureka Client向Eureka Server发起注册请求的时候(根据defaultZone寻找Eureka Server列表)，如果有一次请求注册成功，那么后续就不会在向其他Eureka Server发起注册请求。以本文为例，注册中心有四个(8761、8762、8763、8764)。如果8761对应的Eureka Server服务的状态是UP，那么Eureka Client向该注册中心注册成功后，不会再向(8762、8763、8764)对应的Eureka Server发起注册请求(对应程序是在for循环中直接return respones)。 说到这里又引出来另外一个问题，如果8761这个Eureka Server是down掉的呢？ 根据源码我们可知Eureka Client首次会向8761这个Server发起注册请求，如果该Server的状态是down，那么它会将该Server保存到quarantineSet这个Set集合中，然后再次访问8762这个Eureka Server，如果8762这个Server的状态依旧是down，它也会把这个Server保存到quarantineSet这个Set集合中，然后继续访问8763这个Server，如果8763这个Server的状态依旧是down，此时除了会将其保存到quarantineSet这个Set集合中之外，还会跳出本次循环。从而结束此次注册过程。 说道这里有人要问接下来会不会向8764这个Server发起注册，答案是否定的，因为循环的次数默认是3次。所以即使8764这个Server的状态是UP，它也不会接收到来自Eureka Client发起的注册信息。 Eureka Client向Eureka Server发起注册信息的过程除了在Eureka Client启动的时候触发，还有另外一种方式，就是后台定时任务。 假设我们上面描述的场景是在Eureka Client启动的时候，因为在启动的时候注册这个过程全部失败了，当后台定时任务执行时，还会进入该注册流程。注意此时quarantineSet的值为3(8761、8762、8763之前注册失败的Eureka Server)。 所以当程序再次进入getHostCandidates()方法时，if (quarantineSet.isEmpty())这个方法是不满足的，接下来会走else if (quarantineSet.size() &gt;= threshold)这个判断，如果这个判断成立，那么会将quarantineSet集合清空，同时返回全量的Eureka Server列表，如果这个判断不成立，会拿quarantineSet集合中保存的内容去过滤Eureka Server的全量列表。以本文为例：quarantineSet中保存的是(8761、8762、8763)三个Eureka Server，Eureka Server全量列表的内容是(8761、8762、8763、8764)四个Eureka Server，过滤后返回的结果为8764这个Eureka Server。 在本文的例子中8761、8762、8763这三个Eureka Server的状态是down而8764这个Eureka Server的状态是UP，我们其实是想走到最后的else分支，从而完成过滤操作，并最终得到8764这个Server，遗憾的是它并不会走到这个分支，而是被上面的else if (quarantineSet.size() &gt;= threshold)这个分支所拦截，返回的依旧是全量的Eureka Server列表。这样造成的后果就是Eureka Client依旧会依次向(8761、8762、8763)这三个down的Eureka Server发起注册请求。 那么问题的关键在哪里呢？问题的关键就是threshold这个值的由来，因为此时quarantineSet.size()的值为3，而3这个值大于threshold，从而导致，会将quarantineSet集合清空，返回全量的Server列表。 我们知道threshold这个值是根据全量的Eureka Server列表乘以一个可配置的参数计算出来的，在本文的例子当中，我的properties文件中除了defaultZone之外并没有配置这个参数，那么也就是说这个参数是有默认值的，通过源码我们了解到，这个默认值是0.66。具体源码如下： final class PropertyBasedTransportConfigConstants { /** *省略部分源码 */ static class Values { static final int SESSION_RECONNECT_INTERVAL = 20*60; //默认值为0.66 static final double QUARANTINE_REFRESH_PERCENTAGE = 0.66; static final int DATA_STALENESS_TRHESHOLD = 5*60; static final int ASYNC_RESOLVER_REFRESH_INTERVAL = 5*60*1000; static final int ASYNC_RESOLVER_WARMUP_TIMEOUT = 5000; static final int ASYNC_EXECUTOR_THREADPOOL_SIZE = 5; } } /** *@return the percentage of the full endpoints set above which the *quarantine set is cleared in the range [0, 1.0] */ double getRetryableClientQuarantineRefreshPercentage(); 看到这里就不难理解了，因为这个值是0.66而此时全量的Eureka Server值为4。计算之后的值为2，而由于注册的for循环为3次，所以当第二次发起注册流程的时候quarantineSet的值始终大于threshold。这样就会导致一个问题，就是如果8761、8762、8763一直是down即使8764一直是好的，那么Eureka Client也不会注册成功。而且这个参数值的区间为0到1. 既然通过源码分析我们找到了问题根源，其实对应的我们也找到了解决这个问题的办法，就是对应把这个参数值调大些。这个值在properties中对应的写法如下： eureka.client.transport.retryableClientQuarantineRefreshPercentage = xxx 接下来我们修改下properties文件，修改后的内容如下： eureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka,http://localhost:8763/eureka,http://localhost:8764/eureka eureka.client.transport.retryableClientQuarantineRefreshPercentage=1 接下来按照这个配置再次回顾下上面的流程： Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3. 接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为1。所以计算出的threshold的值为4。而此时quarantineSet的值为3。所以不会进入到else if (quarantineSet.size() &gt;= threshold)分支，而是会进入最后的esle分支。 在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。 Eureka Client向8764这个Eureka Server发起注册请求，得到成功相应，并返回。 遗留问题说道这里我们感觉好像是解决了这个问题，那么问一个问题，这个参数值可以设置的无限大吗？ 比如我将这个参数值设置为10，虽然javaDoc中说明这个参数值的范围在0-1之间，但是并没有说明如果将这个参数调整大于1会出现什么情况。接下来按照上面的流程我们分析下： 之前我们分析的流程中的前提是8761、8762、8763这三台Server的状态是down而8764这个server的状态是up，现在我们修改下这个前提。 假设一开始8761、8762、8763、8764这四台Eureka Server的状态都是down。Eureka Client启动时进行注册(8761、8762、8763的状态是down)，所以此时quarantineSet的值为3. 接下来在定时任务中又触发注册事件，此时因为参数的值从0.66调整为10。所以计算出的threshold的值为40。而此时quarantineSet的值为3。所以不会进入到else if (quarantineSet.size() &gt;= threshold)分支，而是会进入最后的esle分支。 在else分支中会完成过滤功能，最终返回的list中的结果只有一个就是8764这个Eureka Server。 Eureka Client向8764这个Eureka Server发起注册请求，因为此时8764的状态也是down导致注册失败，此时quarantineSet中的内容是(8761、8762、8763、8764) 当定时任务再次触发时if (quarantineSet.isEmpty())这个分支不会进入，因为此时quarantineSet的值为4 else if (quarantineSet.size() &gt;= threshold)这分支也不会进入因为threshold的值为40 最终会进入else分支，这个分支原本的含义是想通过quarantineSet来充当过滤器，从全量的Eureka Server中过滤掉之前状态为down的Eureka Server，但是由于quarantineSet的值现在已经是全量，导致过滤后的结果返回的是一个空的list。即使此时Eureka Server列表(8761、8762、8763、8764)任何一个Server的状态变为UP，该Eureka Client也不可能完成注册事件。 解决办法上面出现的那个问题，根本原因个人认为是由于eureka.client.transport.retryableClientQuarantineRefreshPercentage 参数过大而源码中没有校验，从而导致没有进入else if (quarantineSet.size() &gt;= threshold)的逻辑分支，因为此时如果quarantineSet中的值已经达到了所有Eureka Server列表，那么此时我们希望的是将这个Set集合清空，从而再次返回全量的Eureka Server列表，也就是说再重新来一次注册流程。 所以基于上面的分析，个人认为在源码的getHostCandidates增加下校验，具体代码如下： private List&lt;EurekaEndpoint&gt; getHostCandidates() { List&lt;EurekaEndpoint&gt; candidateHosts = clusterResolver.getClusterEndpoints(); quarantineSet.retainAll(candidateHosts); // If enough hosts are bad, we have no choice but start over again int threshold = (int) (candidateHosts.size() * transportConfig.getRetryableClientQuarantineRefreshPercentage()); /** * 增加判断如果threshold的值过大，即超过Eureka Server * 列表的数量，那么将其再次赋值，赋值的内容为Eureka Server * 列表的数量。 */ if (threshold &gt; candidateHosts.size()) { threshold = candidateHosts.size(); } if (quarantineSet.isEmpty()) { // no-op } else if (quarantineSet.size() &gt;= threshold) { logger.debug(&quot;Clearing quarantined list of size {}&quot;, quarantineSet.size()); quarantineSet.clear(); } else { List&lt;EurekaEndpoint&gt; remainingHosts = new ArrayList&lt;&gt;(candidateHosts.size()); for (EurekaEndpoint endpoint : candidateHosts) { if (!quarantineSet.contains(endpoint)) { remainingHosts.add(endpoint); } } candidateHosts = remainingHosts; } return candidateHosts; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Config-Server配置中心","slug":"SpringCloud之--Config-Server配置中心","date":"2020-05-31T08:50:38.000Z","updated":"2023-04-30T10:21:41.364Z","comments":true,"path":"2020/05/31/SpringCloud之--Config-Server配置中心/","link":"","permalink":"/2020/05/31/SpringCloud之--Config-Server配置中心/","excerpt":"","text":"Spring Cloud 配置中心为分布式系统中的服务器端和客户端提供外部化配置支持。通过Config-Server，你可以在一个地方集中对所有环境中的应用程序的外部化配置进行管理。例如，当一个应用程序从开发环境切换到测试环境，然后再从测试环境切换到生产环境，你可以使用Config-Server统一管理这些环境之间的配置，并确保应用程序在迁移时能够拥有它运行所需要的一切配置。简而言之：Config-Server 就是用来实现配置统一管理和不同环境间配置的统一切换的。Config-Server 服务器的后端存储默认使用Git，因此它很容易支持配置环境的标签版本，同时可供多数的内容管理工具去访问。你也可以很容易地添加其他的替代实现，并将它们插入到Spring配置中。 相关产品： 来自淘宝的Diamond 来自百度的Disconf 来自Springcloud的Config-Server 搭建配置中心Config-Server配置中心的工作原理如下图所示： 引入依赖新建一个maven项目，起名为config-center，在其 pom.xml 文件中引入如下依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Config-Server 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 创建启动类新建一个Springboot应用的启动类ConfigCenterApplication类，并在上增加@EnableConfigServer注解，用来启用Config-Server。 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; @SpringBootApplication @EnableConfigServer public class ConfigCenterApplication { public static void main(String[] args) { SpringApplication.run(ConfigCenterApplication.class, args); } } 添加配置application.yml 添加配置如下： server: port: 9001 spring: application: name: config-center eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 此时，由于尚未配置用来作为服务器后端存储的Git仓库地址，若启动应用会报如下错误： *************************** APPLICATION FAILED TO START *************************** Description: Invalid config server configuration. Action: If you are using the git profile, you need to set a Git URI in your configuration. If you are using a native profile and have spring.cloud.config.server.bootstrap=true, you need to use a composite configuration. 与一般的Spring Boot应用相同，默认情况下Config-Server也通过8080端口启动。为了客户端读取配置方便，你可以把启动端口改为8888（客户端默认会从http://localhost:8888/加载与服务ID相同的配置）。此外，Config-Server还通过spring.config.name=configserver（Config-Server Jar包中有一个configserver.yml 配置文件）配置为我们设置了一个默认配置库，客户端通过配置 spring.cloud.config.discovery.serviceId=configserver 便可直接使用。当然你也可以通过application.yml来对配置中心进行配置。 创建Git仓库本文使用开源中国的码云来创建我们的Git仓库，当然你也可以选择其他的Github或者阿里云Git等创建自己的Git仓库。 点击导航栏中的“+”按钮==&gt;新建仓库，填入仓库信息，完成创建。 点击 克隆/下载 ==&gt;复制，将Git仓库地址复制下来备用。 配置Git仓库接下来，在application.yml中添加Git仓库配置如下： spring: cloud: config: server: git: uri: https://gitee.com/pengjunlee/config-cloud.git username: 你的码云账号 password: 你的账号密码 再次启动ConfigCenterApplication，发现可以正常启动了。启动完成之后，Eureka注册中心中注册的服务列表如下： 搭建客户端接下来，我们通过对上一章《微服务下的链路追踪（Sleuth+Zipkin）》中的product-service服务进行改造，来示例如何从配置中心获取配置。 引入依赖 在product-service的pom.xml中添加配置中心客户端依赖： &lt;!-- Config-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; 或者： &lt;!-- Starter-Config 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt; 修改配置先将product-service中的application.yml文件改名为bootstrap.yml（bootstrap.yml在应用上下文启动阶段加载，比application.yml早），然后再对其内容进行修改： # 设置服务(应用)名称 spring: application: name: product-service # 指定用于获取配置的配置中心服务(应用)名称 cloud: config: discovery: enabled: true serviceId: config-center profile: dev # 指定分枝版本，默认为master label: master # 指定注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 注意：如果不指定配置中心，客户端默认会从 http://localhost:8888 加载与服务ID相同的配置。 在Git仓库创建配置文件客户端通过发送Http请求来从配置中心读取配置，这些Http请求的URI遵循以下规则： /{name}-{profiles}.properties /{name}-{profiles}.yml || /{name}-{profiles}.yaml /{label}/{name}-{profiles}.properties /{label}/{name}-{profiles}.json /{name}/{profiles}/{label:.*} /{name}-{profiles}.json /{label}/{name}-{profiles}.yml || /{label}/{name}-{profiles}.yaml /{name}/{profiles:.*[^-].*} /{name}/{profile}/{label}/** /{name}/{profile}/{label}/** /{name}/{profile}/** 其中各个参数的含义如下： name 服务的ID，即spring.application.name的值，本例中为 product-service； profiles 激活的profile，通过spring.cloud.config.profile指定，本例中为 dev； label 分枝的版本，通过spring.cloud.config.label指定，本例中为默认值 master； 接下来我们需要按照上述规则，在Git仓库的相应位置创建配置文件。根据bootstrap.yml中的配置，资源请求地址可以为 /master/product-service-dev.yml 。 在Git仓库的master分枝中创建product-service-dev.yml和product-service-test.yml两个文件，分别将服务的启动端口指定为8771和8772： # product-service-dev.yml server: port: 8771 # product-service-test.yml server: port: 8772 文件创建完成之后，启动配置中心，先在浏览器对两个文件进行访问。 此时，启动product-service将读取http://localhost:8888/product-service-dev.yml中的配置，即启动端口为8771。若将 bootstrap.yml中的spring.cloud.config.profile的值设置为test，则将读取http://localhost:8888/product-service-test.yml中的配置，应用的启动端口也会相应地变为8772，证明从配置中心读取配置成功。 参考文章http://jm.taobao.org/2016/09/28/an-article-about-config-center/ https://cloud.spring.io/spring-cloud-stream/ https://spring.io/projects/spring-cloud-config https://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Sleuth+Zipkin链路追踪","slug":"SpringCloud之--Sleuth+Zipkin链路追踪","date":"2020-05-31T08:49:38.000Z","updated":"2023-04-30T10:21:41.367Z","comments":true,"path":"2020/05/31/SpringCloud之--Sleuth+Zipkin链路追踪/","link":"","permalink":"/2020/05/31/SpringCloud之--Sleuth+Zipkin链路追踪/","excerpt":"","text":"Sleuth简介Sleuth是Spring Cloud的组件之一，它为Spring Cloud实现了一种分布式追踪解决方案，兼容Zipkin，HTrace和其他基于日志的追踪系统，例如 ELK（Elasticsearch 、Logstash、 Kibana）。 相关术语Sleuth引入了许多 Dapper中的术语： Span基本的工作单元。无论是发送一个RPC或是向RPC发送一个响应都是一个Span。每一个Span通过一个64位ID来进行唯一标识，并通过另一个64位ID对Span所在的Trace进行唯一标识。Span能够启动和停止，他们不断地追踪自身的时间信息，当你创建了一个Span，你必须在未来的某个时刻停止它。提示：启动一个Trace的初始化Span被叫作 Root Span ，它的 Span ID 和 Trace Id 相同。 Trace由一系列Span 组成的一个树状结构。例如，如果你要执行一个分布式大数据的存储操作，这个Trace也许会由你的PUT请求来形成。 Annotation用来及时记录一个事件的存在。通过引入 Brave 库，我们不用再去设置一系列的特别事件，从而让 Zipkin 能够知道客户端和服务器是谁、请求是从哪里开始的、又到哪里结束。 出于学习的目的，还是把Annotation记录的事件类型在这里列举一下： cs （Client Sent） - 客户端发起一个请求，这个注释指示了一个Span的开始。 sr （Server Received） - 服务端接收请求并开始处理它，如果用 sr 时间戳减去 cs 时间戳便能看出有多少网络延迟。 ss（Server Sent）- 注释请求处理完成(响应已发送给客户端)，如果用 ss 时间戳减去sr 时间戳便可得出服务端处理请求耗费的时间。 cr（Client Received）- 预示了一个 Span的结束，客户端成功地接收到了服务端的响应，如果用 cr 时间戳减去 cs 时间戳便可得出客户端从服务端获得响应所需耗费的整个时间。 下图展示了一个系统中的 Span 和 Trace 大概的样子： 颜色相同的注释表示是同一个Span（这里一共有7个Span，编号从 Ａ到Ｇ），以下面这个注释为例： Trace Id = X Span Id = D Client Sent 这个注释表示当前Span的Trace Id 为 X，Span Id 为 D，同时，发生了 Client Sent 事件。 下图展示了父子关系的Span的调用链路： 使用Sleuth为了确保你的应用名称能够在Zipkin中正确显示，你需要先在Springboot的核心配置文件中对spring.application.name 属性进行配置。 引入依赖如果你只想使用SpringCloud Sleuth 而不想与 Zipkin 做集成，引入如下依赖： &lt;dependencies&gt; &lt;!-- Sleuth 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 如果你想通过 HTTP 将 SpringCloud Sleuth 与 Zipkin做集成，引入如下依赖： &lt;dependencies&gt; &lt;!-- Zipkin 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 如果你想使用RabbitMQ 或者Kafka 替代 HTTP ，需先引入 spring-rabbit 或者 spring-kafka 依赖。默认的目标名称是 zipkin 。如果你使用的是Kafka ，必须设置相应的 spring.zipkin.sender.type 属性： spring.zipkin.sender.type: kafka 注意：spring-cloud-sleuth-stream已经过期并且和这些目标不兼容。 如果你使用的是RabbitMQ，需要添加 spring-cloud-starter-zipkin 和 spring-rabbit 依赖。 &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${release.train.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit&lt;/artifactId&gt; &lt;/dependency&gt; 为了示例，这里我们使用Sleuth+Zipkin的默认配置，在需要进行链路追踪的所有服务端添加如下配置： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Server 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Sleuth+Zipkin 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 创建服务 如图所示，创建order-service和product-service两个服务，并在order-service中通过Feign对product-service进行远程调用。 product-service 在product-service的controller中提供一个商品服务： @RestController @RequestMapping(&quot;/api/v1/product&quot;) public class ProductController { private final Logger logger = LoggerFactory.getLogger(getClass()); /** * 商品服务 */ @GetMapping(&quot;/service&quot;) public String productService() { logger.info(&quot;Product Service Is Called...&quot;); return &quot;Product Service Is Called...&quot;; } } order-service由于需要在 order-service 中调用product-service，先创建一个ProductClient： @FeignClient(name = &quot;product-service&quot;) public interface ProductClient { @GetMapping(&quot;/api/v1/product/service&quot;) public String productService(); } 为了示例简单，我们直接在order-service的controller中通过ProductClient对product-service进行调用： @RestController @RequestMapping(&quot;/api/v1/order&quot;) public class OrderController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Autowired private ProductClient productClient; @GetMapping(value = &quot;/service&quot;) public String orderService() { logger.info(&quot;Order Service Is Called...&quot;); String ret = productClient.productService(); logger.info(ret.toString()); return &quot;Order Service Is Called...&quot;; } } 启动&amp;测试按照以下顺序启动应用进行测试： ==&gt;启动Eureka注册中心，端口号 8761 ==&gt;分别通过8771和8781两个端口启动product-service和order-service两个服务 启动完成之后，Eureka注册中心中注册的服务列表如下： 在浏览器中输入以下地址: http://localhost:8781/api/v1/order/service，返回如下内容： 同时，在order-service后台打印如下日志： 2019-02-27 13:49:17.439 INFO [order-service,895caa4daa30bb0a,895caa4daa30bb0a,true] 2812 --- [nio-8781-exec-2] c.pengjunlee.controller.OrderController : Order Service Is Called... 2019-02-27 13:49:17.465 INFO [order-service,895caa4daa30bb0a,895caa4daa30bb0a,true] 2812 --- [nio-8781-exec-2] c.pengjunlee.controller.OrderController : Product Service Is Called... 在product-service后台打印如下日志： 2019-02-27 13:49:17.448 INFO [product-service,895caa4daa30bb0a,9cd122253ea82104,true] 20736 --- [nio-8771-exec-8] c.p.controller.ProductController : Product Service Is Called... 正如上面 product-service 和 order-service 中打印的日志所示，Sleuth将Trace Id和Span Id添加到Slf4J MDC（Mapped Diagnostic Context）并在日志中进行了打印，这样，你就能够从日志聚合器中提取任何一个给定的Trace 或者Span 的所有日志了。 接下来，重点解释一下日志中的 [appname,traceId,spanId,exportable] 各部分所代表的含义： appname：记录日志的应用的名称，即spring.application.name的值； traceId：Sleuth为一次请求链路生成的唯一ID，一个Trace中可以包含多个Span； spanId：请求链路基本的工作单元，代表发生一次特定的操作，例如：发送一个Http请求； exportable：是否需要将日志导出到 Zipkin； Sleuth提供了对常见分布式链路追踪数据模型的抽象：Trace、Span、Annotation和键值对Annotation。Spring-Cloud-Sleuth虽然基于htrace，但与Zipkin（dapper）也兼容。 Sleuth记录时间信息以帮助进行延迟分析。通过使用sleuth，您可以查明应用程序中延迟的原因。 当spring-cloud-sleuth-zipkin包含在classpath中时，应用程序将生成并收集与zipkin兼容的追踪记录。默认情况下，会通过HTTP将它们发送到本地主机（端口9411）上的Zipkin服务器。您可以通过设置spring.zipkin.baseurl来配置服务的地址。 如果你依赖的是spring-rabbit，那么应用程序会将追踪记录发送到Rabbit MQ代理，而不是HTTP。 如果你依赖的是spring-kafka，并设置了spring.zipkin.sender.type:kafka，那么应用程序会将追踪记录发送到Kafka代理而不是HTTP。 注意：如果你使用的是Zipkin，请通过设置spring.sleuth.sampler.probability来配置导出Span的概率（默认值：0.1，即10%）。否则，您可能会认为Sleuth不起作用，因为它省略了一些Span。 注意：如果你使用的是SLF4J，Trace和Span的追踪记录默认会被记录到MDC，所以日志的用户可以立刻看到。但如果你使用的是其他的日志系统，你还需要对日志的打印格式进行设置才能看到相同的结果： logging.pattern.level = %5p [${spring.zipkin.service.name:${spring.application.name:-}},%X{X-B3-TraceId:-},%X{X-B3-SpanId:-},%X{X-Span-Export:-}] Zipkin简介Zipkin是一个分布式系统的APM工具（Application Performance Management），基于Google Dapper 实现。它帮助收集解决微服务架构中延迟问题所需的时间数据，并管理这些数据。和Sleuth结合可以提供可视化Web界面分析调用链路耗时情况。 使用Zipkin如果你使用的Java版本为JDK 8，可以下载一个Zipkin的独立可执行Jar。 下载地址： https://search.maven.org/remote_content?g=io.zipkin.java&amp;a=zipkin-server&amp;v=LATEST&amp;c=exec 使用如下命令启动Zipkin： java -jar zipkin-server-2.12.2-exec.jar 启动完成后，访问 http://localhost:9411/zipkin/dependency/ 查看服务的依赖关系。 参考文章https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-zuul-starter https://github.com/openzipkin/brave https://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.htmlhttps://cloud.spring.io/spring-cloud-static/Finchley.SR2/single/spring-cloud.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Zuul高级配置(下)","slug":"SpringCloud之--Zuul高级配置(下)","date":"2020-05-31T08:48:38.000Z","updated":"2023-04-30T10:21:41.368Z","comments":true,"path":"2020/05/31/SpringCloud之--Zuul高级配置(下)/","link":"","permalink":"/2020/05/31/SpringCloud之--Zuul高级配置(下)/","excerpt":"","text":"为路由提供HystrixFallback当Zuul中某一个路由的断路器被断开时，你可以通过创建一个FallbackProvider类型的Bean来为它提供一个Fallback响应。在这个Bean中你需要指定Fallback响应所对应的路由的ID并提供一个ClientHttpResponse作为返回的Fallback响应，下面是一个FallbackProvider实现的实例。 import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import org.springframework.cloud.netflix.zuul.filters.route.FallbackProvider; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.client.ClientHttpResponse; import org.springframework.stereotype.Component; import com.netflix.hystrix.exception.HystrixTimeoutException; @Component public class MessageFallbackProvider implements FallbackProvider { @Override public String getRoute() { return &quot;zuul-msg&quot;; } @Override public ClientHttpResponse fallbackResponse(String route, final Throwable cause) { if (cause instanceof HystrixTimeoutException) { return response(HttpStatus.GATEWAY_TIMEOUT); } else { return response(HttpStatus.INTERNAL_SERVER_ERROR); } } private ClientHttpResponse response(final HttpStatus status) { return new ClientHttpResponse() { @Override public HttpStatus getStatusCode() throws IOException { return status; } @Override public int getRawStatusCode() throws IOException { return status.value(); } @Override public String getStatusText() throws IOException { return status.getReasonPhrase(); } @Override public void close() { } @Override public InputStream getBody() throws IOException { return new ByteArrayInputStream(&quot;消息服务暂时不可用，请稍后重试！&quot;.getBytes()); } @Override public HttpHeaders getHeaders() { HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; } }; } } 路由的配置信息如下： zuul: routes: message-service: /zuul-msg/** 当message-service服务调用失败时，返回结果见下图。 如果你想为所有的路由提供一个默认的Fallback，可以创建一个FallbackProvider Bean并将它的getRoute() 方法的返回值设置为 “*”或者 null。 class MyFallbackProvider implements FallbackProvider { @Override public String getRoute() { return &quot;*&quot;; } @Override public ClientHttpResponse fallbackResponse(String route, Throwable throwable) { return new ClientHttpResponse() { @Override public HttpStatus getStatusCode() throws IOException { return HttpStatus.OK; } @Override public int getRawStatusCode() throws IOException { return 200; } @Override public String getStatusText() throws IOException { return &quot;OK&quot;; } @Override public void close() { } @Override public InputStream getBody() throws IOException { return new ByteArrayInputStream(&quot;fallback&quot;.getBytes()); } @Override public HttpHeaders getHeaders() { HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType.APPLICATION_JSON); return headers; } }; } } 重写Location头信息如果Zuul面向的是一个Web应用，那么你可能会碰到需要重写Location请求头的情况，你只需要创建一个LocationRewriteFilter类型Bean即可。 import org.springframework.cloud.netflix.zuul.EnableZuulProxy; import org.springframework.cloud.netflix.zuul.filters.post.LocationRewriteFilter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration @EnableZuulProxy public class ZuulConfig { @Bean public LocationRewriteFilter locationRewriteFilter() { return new LocationRewriteFilter(); } } 注意：此过滤器会作用于所有响应状态码为 3XX 的Location头信息，这并不一定适用于所有的场景，比如重定向到外部URL。 启用跨域请求默认情况下，Zuul会把所有的Cross Origin requests (CORS，跨域请求)路由给相应的服务，如果你想代替Zuul自己来处理这些请求，你可以提供一个自定义的 WebMvcConfigurer Bean： @Bean public WebMvcConfigurer corsConfigurer() { return new WebMvcConfigurer() { public void addCorsMappings(CorsRegistry registry) { registry.addMapping(&quot;/path-1/**&quot;).allowedOrigins(&quot;http://allowed-origin.com&quot;).allowedMethods(&quot;GET&quot;, &quot;POST&quot;); } }; } 在这个例子中，我们允许从 http://allowed-origin.com 向Zuul中以 path-1 开头的终端发送 GET和POST类型的跨域请求。你既可以将 CORS 配置作用于指定的路径，也可以使用 /** 让它作用于整个应用。你可以在其中配置以下属性：allowedOrigins、allowedMethods、allowedHeaders、exposedHeaders、allowCredentials、maxAge。 创建前置过滤器前置过滤器对RequestContext中的数据进行设置，并提供给下游的过滤器使用，它的最主要的用途就是对路由过滤器所需的信息进行设置。 import javax.servlet.http.HttpServletRequest; import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; public class QueryParamPreFilter extends ZuulFilter { @Override public int filterOrder() { return FilterConstants.PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration } @Override public String filterType() { return FilterConstants.PRE_TYPE; } @Override public boolean shouldFilter() { RequestContext ctx = RequestContext.getCurrentContext(); return !ctx.containsKey(FilterConstants.FORWARD_TO_KEY) // a filter has already forwarded &amp;&amp; !ctx.containsKey(FilterConstants.SERVICE_ID_KEY); // a filter has already determined serviceId } @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); if (request.getParameter(&quot;sample&quot;) != null) { // put the serviceId in `RequestContext` ctx.put(FilterConstants.SERVICE_ID_KEY, request.getParameter(&quot;foo&quot;)); } return null; } } 创建路由过滤器路由过滤器在前置过滤器之后运行，并负责构造需要发送给其他服务的请求。它在这的主要工作是：把请求数据传送至客户端所需要的 model 中，并把客户端 model 中的内容转换成响应数据返回。 import java.io.InputStream; import java.util.Enumeration; import java.util.List; import java.util.Map; import javax.servlet.http.HttpServletRequest; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.netflix.zuul.filters.ProxyRequestHelper; import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants; import org.springframework.util.LinkedMultiValueMap; import org.springframework.util.StreamUtils; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; import okhttp3.Headers; import okhttp3.MediaType; import okhttp3.OkHttpClient; import okhttp3.Request; import okhttp3.RequestBody; import okhttp3.Response; import okhttp3.internal.http.HttpMethod; public class OkHttpRoutingFilter extends ZuulFilter { @Autowired private ProxyRequestHelper helper; @Override public String filterType() { return FilterConstants.ROUTE_TYPE; } @Override public int filterOrder() { return FilterConstants.SIMPLE_HOST_ROUTING_FILTER_ORDER - 1; } @Override public boolean shouldFilter() { return RequestContext.getCurrentContext().getRouteHost() != null &amp;&amp; RequestContext.getCurrentContext().sendZuulResponse(); } @Override public Object run() { OkHttpClient httpClient = new OkHttpClient.Builder().build(); // customize RequestContext context = RequestContext.getCurrentContext(); HttpServletRequest request = context.getRequest(); String method = request.getMethod(); String uri = this.helper.buildZuulRequestURI(request); Headers.Builder headers = new Headers.Builder(); Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) { String name = headerNames.nextElement(); Enumeration&lt;String&gt; values = request.getHeaders(name); while (values.hasMoreElements()) { String value = values.nextElement(); headers.add(name, value); } } try { InputStream inputStream = request.getInputStream(); RequestBody requestBody = null; if (inputStream != null &amp;&amp; HttpMethod.permitsRequestBody(method)) { MediaType mediaType = null; if (headers.get(&quot;Content-Type&quot;) != null) { mediaType = MediaType.parse(headers.get(&quot;Content-Type&quot;)); } requestBody = RequestBody.create(mediaType, StreamUtils.copyToByteArray(inputStream)); } Request.Builder builder = new Request.Builder().headers(headers.build()).url(uri).method(method, requestBody); Response response = httpClient.newCall(builder.build()).execute(); LinkedMultiValueMap&lt;String, String&gt; responseHeaders = new LinkedMultiValueMap&lt;&gt;(); for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : response.headers().toMultimap().entrySet()) { responseHeaders.put(entry.getKey(), entry.getValue()); } this.helper.setResponse(response.code(), response.body().byteStream(), responseHeaders); context.setRouteHost(null); // prevent SimpleHostRoutingFilter from running } catch (Exception e) { e.printStackTrace(); } return null; } } 创建后置过滤器后置过滤器通常是用来对响应进行处理，例如下面这个过滤器添加了一个UUID作为 X-Sample 的头内容。 import java.util.UUID; import javax.servlet.http.HttpServletResponse; import org.springframework.cloud.netflix.zuul.filters.support.FilterConstants; import com.netflix.zuul.ZuulFilter; import com.netflix.zuul.context.RequestContext; public class AddResponseHeaderFilter extends ZuulFilter { @Override public String filterType() { return FilterConstants.POST_TYPE; } @Override public int filterOrder() { return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1; } @Override public boolean shouldFilter() { return true; } @Override public Object run() { RequestContext context = RequestContext.getCurrentContext(); HttpServletResponse servletResponse = context.getResponse(); servletResponse.addHeader(&quot;X-Sample&quot;, UUID.randomUUID().toString()); return null; } } Zuul错误处理在Zuul过滤器生命周期的任一阶段一旦出现异常，错误过滤器就会执行。SendErrorFilter 只会在RequestContext.getThrowable() 不是 null 的时候运行。它会在请求中设置一些特定的 javax.servlet.error.* 属性并将请求转向Springboot的错误页面。 应用上下文饿加载Zuul 在内部使用的是Ribbon 对远程url进行调用。默认情况下，Ribbon客户端会在Spring Cloud第一次调用时进行懒加载。如果需要在应用启动时就进行加载，可以做如下配置。 zuul: ribbon: eager-load: enabled: true 请求失败重试Spring Cloud Netflix 提供了很多种方法用来创建 HTTP 请求，你可以使用负载均衡的RestTemplate、Ribbon 或者 Feign ，但无论你选择了哪一种，都有可能会出现请求失败的情况。当一个请求失败时，你可能会希望它自动地进行重试，要实现这一点的话，你需要把 Spring Retry 添加到你的classpath ，然后，负载均衡的RestTemplate、Ribbon 、 Feign 以及 Zuul 就会对所有失败的请求自动进行重试（前提是你的配置允许它这样做的话）。 补偿策略默认情况下，重试请求是没有补偿策略的，如果你想要配置一个补偿策略，你需要为指定的服务创建一个 LoadBalancedRetryFactory 类型的Bean，并重写它的 createBackOffPolicy 方法。 @Configuration public class MyConfiguration { @Bean LoadBalancedRetryFactory retryFactory() { return new LoadBalancedRetryFactory() { @Override public BackOffPolicy createBackOffPolicy(String service) { return new ExponentialBackOffPolicy(); } }; } } 相关配置在使用Ribbon进行重试时，你可以使用下面前三个个Ribbon配置项对重试的功能进行控制。 # Max number of retries on the same server (excluding the first try) sample-client.ribbon.MaxAutoRetries=1 # Max number of next servers to retry (excluding the first server) sample-client.ribbon.MaxAutoRetriesNextServer=1 # Whether all operations can be retried for this client sample-client.ribbon.OkToRetryOnAllOperations=true # Interval to refresh the server list from the source sample-client.ribbon.ServerListRefreshInterval=2000 # Connect timeout used by Apache HttpClient sample-client.ribbon.ConnectTimeout=3000 # Read timeout used by Apache HttpClient sample-client.ribbon.ReadTimeout=3000 # Initial list of servers, can be changed via Archaius dynamic property at runtime sample-client.ribbon.listOfServers=www.microsoft.com:80,www.yahoo.com:80,www.google.com:80 另外，如果你想当返回的响应的状态码为某些值的时候才进行重试，你可以使用 clientName.ribbon.retryableStatusCodes 把那些需要Ribbon客户端进行重试的状态码列举出来。 clientName: ribbon: retryableStatusCodes: 404,502 或者创建一个 LoadBalancedRetryPolicy 类型的Bean ，并实现它的retryableStatusCode方法。 禁用重试# 全部禁用 zuul.retryable=false # 禁用指定路由 zuul.routes.routename.retryable=false 参考文章https://github.com/spring-projects/spring-retry https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-zuul-starter","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Zuul高级配置(上)","slug":"SpringCloud之--Zuul高级配置(上)","date":"2020-05-31T08:47:38.000Z","updated":"2023-04-30T10:21:41.368Z","comments":true,"path":"2020/05/31/SpringCloud之--Zuul高级配置(上)/","link":"","permalink":"/2020/05/31/SpringCloud之--Zuul高级配置(上)/","excerpt":"","text":"自定义路由规则在《Zuul路由和过滤》一章中，我们并未对Zuul的路由规则进行设置，默认会使用服务的 ID 对服务进行路由，即：在源服务的URI之前增加 /service-id 前缀。 # Zuul 默认路由地址 http://&lt;zuul-host&gt;:&lt;zuul-port&gt;/service-id/[service-URI] 除了可以直接使用默认的路由规则外，Zuul还提供了很多配置项允许我们对路由映射规则进行自定义，例如： zuul: ignoredServices: &#39;*&#39; routes: message-service: /zuul-msg/** 示例中这个配置的作用是：忽略除 message-service 外的所有服务（不对它们进行路由），只将message-service 服务路由到 /zuul-msg/** 地址上。 zuul.ignored-services # 忽略指定微服务，多个微服务之间使用逗号分隔 zuul.routes.service-id # 指定service-id服务的路由地址 注意：在 zuul.routes 中配置了的服务，即使被包含在 zuul.ignored-services 配置中也不会被忽略。 若将上例中的配置改成如下，则表示除 message-service 外的所有服务都使用默认的路由规则。 zuul: routes: message-service: /zuul-msg/** 如果你希望对某一个路由进行更精细的控制，可以独立地指定该服务的路由地址和它的service-id，例如： zuul: routes: message: path: /zuul-msg/** serviceId: message-service 或者，像下面这样指定一个该服务的物理地址来替代上例中的service-id： zuul: routes: message: path: /zuul-msg/** url: http://localhost:8771/ 连续多次访问 http://localhost:8791/zuul-msg/api/v1/msg/get 返回结果相同，见下图： 可以看出，通过url配置的路由不会被当作HystrixCommand执行，自然也就不会使用Ribbon在多个Url之间进行负载均衡。所以，推荐使用serviceId进行配置。或者，指定一个包含有多个可用服务列表的serviceId，例如： zuul: routes: message: path: /zuul-msg/** serviceId: msg-servers hystrix: command: msg-servers: execution: isolation: thread: timeoutInMilliseconds: 1000 msg-servers: ribbon: NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList listOfServers: http://localhost:8771/,http://localhost:8772/ ConnectTimeout: 1000 ReadTimeout: 3000 MaxTotalHttpConnections: 500 MaxConnectionsPerHost: 100 还有另外一种方法也可以达到上述目标：使用service-id为要路由的服务指定一个Ribbon客户端，并设置Ribbon禁用Eureka，例如： zuul: routes: message: path: /zuul-msg/** serviceId: msg-servers ribbon: eureka: enabled: false msg-servers: ribbon: listOfServers: http://localhost:8771/,http://localhost:8772/ 如果你的service-id命名满足一定的规则，可以使用正则表达式从service-id中提取一些变量作为你的路由地址，例如： @Bean public PatternServiceRouteMapper serviceRouteMapper() { return new PatternServiceRouteMapper(&quot;(?&lt;name&gt;^.+)-(?&lt;version&gt;v.+$)&quot;, &quot;${version}/${name}&quot;); } 在这个示例中，一个名称为myusers-v1的服务会被路由到 /v1/myusers/** 地址上。在这里你可以使用任意正则表达式，但是要保证所有的命名组必须都包含servicePattern和routePattern两部分。如果servicePattern不匹配service-id，就会使用默认的规则，即在服务原有的URI之前增加 /service-id 前缀。Zuul的这一特性默认是关闭的，而且只能被应用到已经发现的服务。 对那些要忽略的微服务也可以采用模式匹配进行更加精细的控制，例如： zuul: ignoredPatterns: /**/v2/** routes: message-service: /zuul-msg/** 该例中的配置会忽略所有包含 /v2/ 的请求。 使用 zuul.prefix 配置项可以为所有的路由地址都添加一个前缀，例如 /abc 。 zuul: prefix: /abc routes: message-service: /zuul-msg/** 添加前缀之后路由地址为：http://localhost:8791/abc/zuul-msg/api/v1/msg/get 。 默认情况下，Zuul代理会在将请求转发出去之前先将其中的前缀字符串剔除掉。如果你不想剔除前缀，可以设置 zuul.stripPrefix=false。如果你只是想不剔除指定某一个服务中的前缀，可以使用如下配置： zuul: prefix: /abc # stripPrefix: false routes: message-service: /zuul-msg/** stripPrefix: false zuul.routes 中的配置条目最终都会被绑定到一个ZuulProperties类型的对象，在 ZuulProperties 中还有一个 retryable 标识，将该标识设置成 ture 能够让Ribbon客户端对失败的请求自动进行重试。 zuul.routes 中配置的路由地址最终都会被存储在一个Map中，路由的地址即为Map的key，Map的value是一个ZuulRoute类型的对象。在yaml配置文件中，路由地址相同的两个服务，后面的会覆盖前面的配置，从而导致先配置的服务不可用。 注意：如果需要保留路由的顺序，需要使用yaml文件，因为使用properties文件时会丢失顺序。 目前，Zuul已经使用 Apache HTTP Client 替换掉了已经过时的Ribbon RestClient 来作为自己的HTTP Client。你若想继续使用 RestClient 或者 okhttp3.OkHttpClient，只需要将 ribbon.restclient.enabled 或者 ribbon.okhttp.enabled 设置为 true 即可。当然，你也可以使用自定义的 Apache HTTP client 或者 OK HTTP client，提供一个相应的 ClosableHttpClient 或者OkHttpClient 类型的 Bean即可。 设置请求头默认情况下，Zuul会为转发的请求添加一些 X-Forwarded-* 请求头，可以通过配置项 zuul.addProxyHeaders = false 来关闭它。请求中的前缀默认会被剔除，同样地，请求中的X-Forwarded-Prefix 请求头也会被摘取出来。 在同一个系统中，请求头在多个服务之间是可以共享的，但是你可能并不希望某些敏感的请求头信息泄露到下游的外部服务器，你可以把这些敏感请求头配置到zuul.sensitiveHeaders列表，从而禁止它们被传递到下游。例如： zuul: sensitiveHeaders: Cookie,Set-Cookie,Authorization routes: message-service: /zuul-msg/** sensitiveHeaders: token sensitiveHeaders就相当于是一个向下游传递的请求头黑名单，默认包含了 Cookie，Set-Cookie和Authorization三个请求头。因此，如果你需要向下传递所有的请求头信息，需要明确地把sensitiveHeaders设置成一个空列表，如下： zuul: sensitiveHeaders: routes: message-service: /zuul-msg/** 另外，你还可以把那些不需要传递到下游的请求头或响应头配置到 zuul.ignoredHeaders 中，可以达到相同的作用。默认情况下，当类路径中不包含 Spring Security 时，ignoredHeaders 列表是空的；当类路径中包含 Spring Security时，ignoredHeaders 列表会被初始化包含一些由Spring Security指定的 security 头信息，例如 involving caching。这种情况下如果你需要把这些 security 头信息传递到下游，可以添加 zuul.ignoreSecurityHeaders = false 配置项。 管理终端默认情况下，当@EnableZuulProxy与Actuator一起使用时，Actuator健康监控页面会增加两个终端：Routes和Filters。 需要在pom.xml中引入Actuator依赖： &lt;!-- Actuator 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 并在application.yml文件中增加配置： management: security: enabled: false endpoints: web: exposure: include: hystrix.stream,* 访问 /actuator/routes 终端会返回一个映射路由的列表，如下图。 访问 /actuator/routes/details 终端会返回一个映射路由的详细信息列表，如下图。 访问 /actuator/filters 终端会返回一个包含了过滤器类型和配置的Map对象。 编码设置在对进来的请求进行处理的时候，请求参数会被解码以便在Zuul过滤器中能够对它们进行一些修改，然后又会在路由过滤器中重新编码并发送出去，重新编码后的结果跟原来的输入可能会有所不同，这在多数情况下是没什么问题的，但是在一些对复杂的请求字符串编码比较挑剔的Web服务器中仍有可能会出问题。解决的办法就是添加如下的配置来强制使用原始编码的请求字符串，相当于直接使用 HttpServletRequest.getQueryString()方法来获取请求字符串。 在对进来的请求进行处理的时候，会先对请求的URI进行解码，再和路由地址进行匹配，然后又会在路由过滤器中对请求的URI重新编码并发送给后端，当你的URI中包含 “/” 字符时这可能会引发一些意想不到的问题。解决的办法就是添加如下的配置来强制使用原始编码的请求URI，相当于直接使用 HttpServletRequest.getRequestURI()方法来获取请求URI。 禁用Zuul过滤器Spring Cloud的Zuul自带了一些过滤器Bean，默认情况下它们都是启用的。如果你想禁用其中的某一个过滤器，可以使用如下配置： zuul.&lt;SimpleClassName&gt;.&lt;filterType&gt;.disable=true 按照惯例，过滤器所在包名中 “filters” 字符串后面的就是过滤器的类型了，例如，禁用 org.springframework.cloud.netflix.zuul.filters.post.SendResponseFilter ，配置如下： zuul.SendResponseFilter.post.disable=true 超时设置 如果你需要设置通过Zuul路由的请求的Socket超时时间和Read超时时间，有两种配置方法，需要根据你的配置情况进行选择： 如果使用了服务发现，使用ribbon.ReadTimeout 和 ribbon.SocketTimeout 进行配置。 如果是通过指定URL的方式进行路由，使用zuul.host.connect-timeout-millis 和 zuul.host.socket-timeout-millis进行配置。 参考文章https://github.com/spring-projects/spring-retry https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-zuul-starter","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Zuul路由和过滤","slug":"SpringCloud之--Zuul路由和过滤","date":"2020-05-31T08:46:38.000Z","updated":"2023-04-30T10:21:41.367Z","comments":true,"path":"2020/05/31/SpringCloud之--Zuul路由和过滤/","link":"","permalink":"/2020/05/31/SpringCloud之--Zuul路由和过滤/","excerpt":"","text":"Zuul是什么？API Gateway 是随着微服务（Microservice）这个概念一起兴起的一种架构模式，它用于解决微服务过于分散，没有一个统一的出入口来进行流量管理的问题。 API Gateway可以作为整个系统对外的唯一入口，它是一个介于客户端和服务器之间的中间层，用来处理一些与业务无关的边缘功能，例如：智能路由、登录鉴权、流量监控与限流、网络隔离，等等。 API Gateway 的一种比较常规的选择就是使用Nginx代理，但是Netflix带来了它自己的解决方案—-Zuul。Zuul 是Netflix公司开源的基于JVM的微服务网关，可以和Eureka、Ribbon和Hystrix等组件配合使用，提供动态路由，监控，弹性，安全等边缘服务。它相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门，可以适当的对多个 Amazon Auto Scaling Groups 进行路由请求。 Netflix公司主要使用Zuul完成以下功能： 鉴权 流量监控 压力测试 金丝雀测试（灰度测试/AB测试） 动态路由 服务迁移 限流 安全防护 静态响应处理 Zuul的工作原理和大部分基于Java的Web应用类似，Zuul也采用了servlet架构，因此Zuul处理每个请求的方式是：针对每个请求使用一个线程来处理。通常情况下，为了提高性能，所有请求会被放到处理队列中，从线程池中选取空闲线程来处理该请求。这样的设计方式，足以应付一般的高并发场景。 如图所示，Zuul的核心是一系列的filters，并且它还提供了一个框架，可以对过滤器进行动态的加载，编译，运行。Zuul的过滤器之间并不会直接进行通信，而是通过一个RequestContext的静态类进行数据传递。RequestContext用ThreadLocal变量来记录每个Request所需要传递的数据。 Zuul的过滤器是使用Groovy语言编写而成的，这些过滤器文件被放在Zuul Server上的特定目录下面，Zuul会定期轮询这些目录，修改过的过滤器会动态的加载到Zuul Server中以便于request使用。 Zuul的标准过滤器有以下四种类型： 前置过滤器(pre filters)：在请求到达Origin Server之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的Origin Server、记录调试信息等。 路由过滤器(routing filters)：将用户的请求转发给Origin Server。发送给Origin Server的用户请求在这类过滤器中build，并使用Apache HttpClient或者Netfilx Ribbon发送给Origin Server。 后置过滤器(post filters)：在用户请求从Origin Server返回以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将从Origin Server获取到的响应发送给客户端等。 错误过滤器(error filters)：在其他阶段发生错误时执行该过滤器。 一个请求会先按顺序通过所有的前置过滤器，之后在路由过滤器中转发给后端应用，得到响应后又会通过所有的后置过滤器，最后再将响应发送给客户端。在整个流程中如果发生了异常则会跳转到错误过滤器中。 一般来说，如果需要在请求到达后端应用前就进行处理的话，会选择前置过滤器，例如鉴权、请求转发、增加请求参数等行为。在请求完成后需要处理的操作放在后置过滤器中完成，例如统计返回值和调用时间、记录日志、增加跨域头等行为。路由过滤器一般只需要选择 Zuul 中内置的即可，错误过滤器一般只需要一个，这样可以在 Gateway 遇到错误逻辑时直接抛出异常中断流程，并直接统一处理返回结果。 使用Zuul接下来我们将沿用上一章《Ribbon客户端负载均衡》中的项目，演示如何使用Zuul。 引入Zuul依赖新建一个maven项目，起名为api-gateway，在其 pom.xml 文件中引入Zuul依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Zuul 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 修改启动类新建一个Springboot应用的启动类ApiGatewayApplication，并在上面添加@EnableZuulProxy注解，用来启用Zuul反向代理。 import org.springframework.boot.WebApplicationType; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.netflix.zuul.EnableZuulProxy; @SpringBootApplication @EnableDiscoveryClient @EnableZuulProxy public class ApiGatewayApplication { public static void main(String[] args) { new SpringApplicationBuilder(ApiGatewayApplication.class).web(WebApplicationType.SERVLET).run(args); } } 添加配置application.yml 添加配置如下： server: port: 8791 # 服务的名称 spring: application: name: api-gateway # 注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 启动测试按照以下顺序启动应用进行测试： ==&gt;启动Eureka注册中心，端口号 8761 ==&gt;分别通过8771和8772两个端口启动message-service ==&gt;启动api-gateway，端口号 8791 启动完成之后，Eureka注册中心中注册的服务列表如下： 首先，我们在浏览器中输入以下地址: http://localhost:8771/api/v1/msg/get，将会显示以下界面： 同样的，访问地址：http://localhost:8772/api/v1/msg/get，将会显示以下界面： 证明两个message-service服务都能正常访问。 接下来我们通过Zuul网关请求服务，请求地址的格式如下： &lt;zuul-host&gt;:&lt;zuul-port&gt;/service-name/[service-URI] # zuul-host zuul网关的主机名称或IP地址，本例中为localhost # zuul-port zuul网关的端口号，本例中为 8791 # service-name 要请求的服务名称，本例中为 message-service # service-URI 要请求的服务的uri地址，本例中为 /api/v1/msg/get 本例中，完整的请求地址为：http://localhost:8791/message-service/api/v1/msg/get ，连续请求两次，返回结果如下： 可见，Zuul不仅成功地帮我们路由到了相应的微服务还对请求做了负载均衡。 Zuul集群架构通常我们都会启动多个Zuul网关节点，并通过Nginx对多个网关进行负载均衡。为了防止Nginx出现单点故障，还需要在Nginx集群之前使用Lvs+KeepAlived进行健康检查以及故障迁移，典型的Zuul高可用集群架构如下图所示。 参考文章https://www.jianshu.com/p/e0434a421c03 https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#netflix-zuul-starter","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Hystrix服务熔断与降级","slug":"SpringCloud之--Hystrix服务熔断与降级","date":"2020-05-31T08:45:38.000Z","updated":"2023-04-30T10:21:41.366Z","comments":true,"path":"2020/05/31/SpringCloud之--Hystrix服务熔断与降级/","link":"","permalink":"/2020/05/31/SpringCloud之--Hystrix服务熔断与降级/","excerpt":"","text":"服务熔断服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。 服务降级服务降级是从整个系统的负荷情况出发和考虑的，对某些负荷会比较高的情况，为了预防某些功能（业务场景）出现负荷过载或者响应慢的情况，在其内部暂时舍弃对一些非核心的接口和数据的请求，而直接返回一个提前准备好的fallback（退路）错误处理信息。这样，虽然提供的是一个有损的服务，但却保证了整个系统的稳定性和可用性。 熔断VS降级相同点： 目标一致 都是从可用性和可靠性出发，为了防止系统崩溃； 用户体验类似 最终都让用户体验到的是某些功能暂时不可用； 不同点： 触发原因不同 服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑； Hystrix简介 Hystrix：英 [hɪst&#39;rɪks] 美 [hɪst&#39;rɪks]，翻译过来是“豪猪”的意思。 在分布式环境中，不可避免地会出现某些依赖的服务发生故障的情况。Hystrix是这样的一个库，它通过添加容许时延和容错逻辑来帮助你控制这些分布式服务之间的交互。Hystrix通过隔离服务之间的访问点，阻止跨服务的级联故障，并提供了退路选项，所有这些都可以提高系统的整体弹性。 Hystrix的设计目的： 通过第三方客户端的库来为访问依赖服务时的潜在故障提供保护和控制； 防止在复杂分布式系统中出现级联故障； 快速失败和迅速恢复； 在允许的情况下，提供退路对服务进行优雅降级； 提供近实时的监控、报警和操作控制； 接下来我们将通过对《Feign模拟RPC调用》一章中的 message-center 项目进行改造，演示如何使用Hystrix，eureka服务注册中心以及message-service服务提供者无需更改。 使用Hystrix引入Hystrix依赖在 pom.xml 文件中引入Hystrix依赖： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Hystrix 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 修改启动类在MessageCenterApplication启动类上增加@EnableCircuitBreaker注解： @SpringBootApplication @EnableFeignClients @EnableCircuitBreaker public class MessageCenterApplication { public static void main(String[] args) { new SpringApplicationBuilder(MessageCenterApplication.class).web(WebApplicationType.SERVLET).run(args); } } 这里我们在启动类中又增加了@EnableCircuitBreaker注解，用来开启断路器功能。如果你觉得启动类上的注解个数有点多的话，可以使用一个@SpringCloudApplication 注解来代替@SpringBootApplication（或者@EnableEurekaServer）、@EnableDiscoveryClient、@EnableCircuitBreaker这三个注解。 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Inherited @SpringBootApplication @EnableDiscoveryClient @EnableCircuitBreaker public @interface SpringCloudApplication { } 修改Controller接下来，我们为MessageCenterController中的getMsg()接口增加断路器功能，修改部分代码如下： @GetMapping(&quot;/msg/get&quot;) @HystrixCommand(fallbackMethod = &quot;getMsgFallback&quot;) public Object getMsg() { String msg = messageService.getMsg(); return msg; } public Object getMsgFallback() { return &quot;祝您 2019 猪年大吉，&#39;猪&#39;事如意！&quot;; } 先启动Eureka，再启动一个8771端口的message-service服务，最后启动message-center。待启动完成之后，Eureka注册中心实例注册信息如下： 此时，访问 http://localhost:8781/api/v1/center/msg/get ，返回如下结果表明服务调用成功： 然后，停掉message-service服务，再次请求 http://localhost:8781/api/v1/center/msg/get ，返回结果如下： 可以看出fallback中的信息被直接返回了，表明Hystrix断路器调用成功。 注意：fallback方法的签名需要和原方法保持一致。 /** * 获取消息详情 */ @GetMapping(&quot;/api/v1/msg/detail/{id}&quot;) @HystrixCommand(fallbackMethod = &quot;getDetailFallback&quot;) public MessageEntity getDetail(@PathVariable(name = &quot;id&quot;) Long id) { return messageService.getById(id); } /** * 获取消息详情退路 */ public MessageEntity getDetailFallback(Long id){ return null; } Feign结合Hystrix以MessageService的Feign客户端为例，为其添加Hystrix断路器功能。 修改Feign客户端通过配置@FeignClient注解的fallback属性来位MessageServiceClient指定一个自定义的fallback处理类（MessageServiceFallback）。 @FeignClient(name = &quot;message-service&quot;, fallback = MessageServiceFallback.class) public interface MessageServiceClient { @GetMapping(&quot;/api/v1/msg/get&quot;) public String getMsg(); } 创建Fallback处理类MessageServiceFallback需要实现MessageServiceClient接口，并且在Spring容器中必须存在一个该类型的有效Bean。在这里，我们使用@Component注解将其注入到Spring容器中。 @Component public class MessageServiceFallback implements MessageServiceClient { @Override public String getMsg() { System.out.println(&quot;调用消息接口失败，对其进行降级处理！&quot;); return &quot;消息接口繁忙，请稍后重试！&quot;; } } 修改配置在新版本的Springcloud中，Feign默认关闭了对Hystrix的支持，需要在application.yml进行配置： feign: hystrix: enabled: true 当message-service服务不可用时，请求 http://localhost:8781/api/v1/center/msg/get，返回结果如下： 查看后台日志，打印如下内容，表明fallback方法被成功调用了： 监控Hystrix启用健康监控Actuator是Springboot提供的用来对应用系统进行自省和监控的功能模块，借助于Actuator开发者可以很方便地对应用系统某些监控指标进行查看、统计等。 若要使用Actuator对Hystrix 流进行监控，除了需在工程POM文件中引入spring-boot-starter-actuator依赖: &lt;!-- Actuator 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 还需要在application.yml 中添加如下配置： management: endpoints: web: exposure: include: hystrix.stream 启用Hystrix-Dashboard使用Hystrix一个最大的好处就是它会为我们自动收集每一个HystrixCommand的信息，并利用Hystrix-Dashboard通过一种高效的方式对每一个断路器的健康状态进行展示。 值得注意的是，在使用HystrixCommand对RibbonClient进行包装的时候，你需要确保你配置的Hystrix超时时间要比Ribbon的超时时间长，包括由它们引起的重试时间，举个例子：如果你的Ribbon连接超时时间是1秒，并且Ribbon会连续重试请求3次，那么你的Hystrix连接超时时间需要配置成稍大于3秒。 引入依赖在 pom.xml 文件中引入Hystrix-Dashboard依赖： &lt;!-- Hystrix Dashboard 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; 修改启动类在MessageCenterApplication启动类上增加@EnableHystrixDashboard注解： @EnableFeignClients @SpringCloudApplication @EnableHystrixDashboard public class MessageCenterApplication { public static void main(String[] args) { new SpringApplicationBuilder(MessageCenterApplication.class).web(WebApplicationType.SERVLET).run(args); } } 仪表盘界面启动应用，访问 http://localhost:8781/hystrix ，打开Hystrix-Dashboard监控首页。 在这里配置好需要监控的Hystrix流地址 http://localhost:8781/actuator/hystrix.stream ，开始监控。 参考文章https://github.com/netflix/hystrix/wiki https://github.com/netflix/hystrix https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Feign模拟RPC调用","slug":"SpringCloud之--Feign模拟RPC调用","date":"2020-05-31T08:44:38.000Z","updated":"2023-04-30T10:21:41.365Z","comments":true,"path":"2020/05/31/SpringCloud之--Feign模拟RPC调用/","link":"","permalink":"/2020/05/31/SpringCloud之--Feign模拟RPC调用/","excerpt":"","text":"Feign简介Feign是一个声明式的Web Service客户端，它能够让Web Service客户端的编写变得更加容易（你只需创建一个接口，并在接口上添加相应注解即可）。除了Feign自带的注解外它还支持JAX-RS注解，SpringCloud又为Feign增加了对SpringMVC注解的支持，同时为了能够使用和Spring Web中默认使用的相同的httpMessageConverter，SpringCloud集成了Ribbon和Eureka，用来在使用Feign时能够为其提供一个负载均衡的HTTP客户端。 总起来说，Feign具有如下特性： 可插拔的注解支持，包括Feign注解和JAX-RS注解; 支持可插拔的HTTP编码器和解码器; 支持Hystrix和它的Fallback; 支持Ribbon的负载均衡; 支持HTTP请求和响应的压缩。 接下来我们将通过对上一章《Ribbon客户端负载均衡》中的 message-center 项目进行改造，演示如何使用Feign。 message-center改造引入Feign依赖由于Feign依赖中默认包含了Ribbon，所以只需要在 pom.xml 文件中引入Feign依赖即可，Ribbon依赖无需重复引入： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Feign 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 修改启动类在MessageCenterApplication启动类上增加@EnableFeignClients注解： import org.springframework.boot.WebApplicationType; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients public class MessageCenterApplication { public static void main(String[] args) { new SpringApplicationBuilder(MessageCenterApplication.class).web(WebApplicationType.SERVLET).run(args); } } 这里我们在启动类中增加了@EnableFeignClients注解，用来开启Feign客户端发现功能。 如果你的Feign客户端类文件不在Spring的包扫描路径之中，可以在@EnableFeignClients注解中对Feign客户端的包路径进行指定。 @SpringBootApplication @EnableFeignClients(basePackages = &quot;com.pengjunlee.client.**&quot;) public class MessageCenterApplication { public static void main(String[] args) { new SpringApplicationBuilder(MessageCenterApplication.class).web(WebApplicationType.SERVLET).run(args); } } 创建Feign客户端在上一章《Ribbon客户端负载均衡》中，对外提供服务的HTTP接口定义在MessageController中。 @RestController @RequestMapping(&quot;/api/v1/msg&quot;) public class MessageController { @Value(&quot;${server.port}&quot;) private String port; /** * 返回一条消息 */ @GetMapping(&quot;/get&quot;) public String getMsg() { return &quot;This message is sent from port: &quot; + port; } } 接下来，我们在消费端message-center中为它创建一个Feign客户端。新建一个接口取名MessageServiceClient，并在上面添加@FeignClient注解，完整代码如下： import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; @FeignClient(name = &quot;message-service&quot;) public interface MessageServiceClient { @GetMapping(&quot;/api/v1/msg/get&quot;) public String getMsg(); } 说明：此处@FeignClient注解的name属性应与message-service应用的spring.application.name属性相同，表示为message-service服务创建一个Feign客户端。接口的映射地址路径以及接口入参都必须与MessageController中的方法完全相同。 调用Feign客户端接下来，我们来看一看如何在消费端使用创建好的Feign客户端对message-service服务进行调用，示例代码如下： import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.pengjunlee.service.MessageServiceClient; @RestController @RequestMapping(&quot;/api/v1/center&quot;) public class MessageCenterController { @Autowired private MessageServiceClient messageService; @GetMapping(&quot;/msg/get&quot;) public Object getMsg() { String msg = messageService.getMsg(); return msg; } } 启动应用，再次请求 http://localhost:8781/api/v1/center/msg/get ，返回如下结果表明服务调用成功： 关于传参Feign除了支持自带的注解和JAX-RS注解外，还支持 SpringMVC注解，常用的有：@RequestParam 、@PathVariable、@RequestBody 等。 例如，服务端提供如下两个服务接口： /** * 获取消息详情 */ @GetMapping(&quot;/api/v1/msg/detail/{id}&quot;) public MessageEntity getDetail(@PathVariable(name = &quot;id&quot;) Long id) { return messageService.getById(id); } /** * 新建一条消息 */ @PostMapping(&quot;/api/v1/msg/save&quot;) public MessageEntity save(@RequestBody MessageEntity message) { return messageService.save(message); } 相应的，在Feign客户端中可以进行如下定义： /** * 获取消息详情 */ @GetMapping(&quot;/api/v1/msg/detail/{id}&quot;) public MessageEntity getDetail(@PathVariable(name = &quot;id&quot;) Long id) ; /** * 新建一条消息 */ @PostMapping(&quot;/api/v1/msg/save&quot;) public MessageEntity save(@RequestBody MessageEntity message) ; 重写Feign的默认配置在Spring Cloud对Feign的支持实现中，一个核心的概念就是客户端命名，每一个Feign客户端都是整个组件系统的一部分，它们相互协同一起工作来按照需求与远程服务器取得联系。并且它们每一个都有自己的名字，应用程序开发人员可以使用@feignclient来给它取名。Spring Cloud按照自己的需要又使用FeignClientsConfiguration为每一个已命名的客户端创建了一个ApplicationContext，额外包含了一个feign.Decoder、一个 feign.Encoder 和一个 feign.Contract。你可以通过指定@FeignClient注解的contextId 属性来设置ApplicationContext的名字。 SpringCloud还允许你在FeignClientsConfiguration的基础之上使用@FeignClient声明一些额外的配置，从而实现对Feign客户端的完全控制，如下例所示： @FeignClient(name = &quot;message-service&quot;, configuration = MessageConfiguration.class) public interface MessageServiceClient { //.. } 在这个例子中，这个Feign客户端将由FeignClientsConfiguration 和MessageConfiguration中的组件一起组成（后者会覆盖前者的配置）。 注意：本例中，MessageConfiguration不必用@Configuration注解进行标注，如果确实要加上@Configuration注解，你需要注意把MessageConfiguration排除在@ComponentScan和@SpringBootApplication扫描的包路径之外，否则它将成为feign.Decoder、feign.Encoder 和 feign.Contract 等的默认值。 下表列出了 Spring Cloud Netflix 缺省为Feign提供的所有 Bean（Bean类型 Bean名称：Bean实现）： Decoder feignDecoder: ResponseEntityDecoder (包装了一个 SpringDecoder) Encoder feignEncoder: SpringEncoder Logger feignLogger: Slf4jLogger Contract feignContract: SpringMvcContract Feign.Builder feignBuilder: HystrixFeign.Builder Client feignClient: 启用 Ribbon 时是 LoadBalancerFeignClient，否则使用 feign.Client.Default。 你可以使用 OkHttpClient 或者 ApacheHttpClient 的Feign客户端，只需要将 feign.okhttp.enabled 或者 feign.httpclient.enabled 设置为 true ，并将相应类添加到项目的CLASSPATH即可。你也可以使用自定义的HTTP 客户端，使用 Apache 时提供一个ClosableHttpClient 类型Bean或者使用OK HTTP时提供一个OkHttpClient 类型Bean。 默认情况下，Spring Cloud Netflix 并没有为Feign提供下列的Bean，但依然会从Spring容器中查找这些类型的Bean用来创建Feign客户端。 Logger.Level Retryer ErrorDecoder Request.Options Collection&lt;RequestInterceptor&gt; SetterFactory 创建这些类型的一个Bean 并将它写到 @FeignClient 声明的配置中，这样你就能够对这些Bean中的每一个进行重写。例如下面的 MessageConfiguration 利用feign.Contract.Default替代了SpringMvcContract 并向RequestInterceptor 集合中添加了一个RequestInterceptor 。 @Configuration public class MessageConfiguration { @Bean public Contract feignContract() { return new feign.Contract.Default(); } @Bean public BasicAuthRequestInterceptor basicAuthRequestInterceptor() { return new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;password&quot;); } } 当然，@FeignClient 也支持通过配置文件进行配置。 feign: client: config: message-service: connectTimeout: 5000 readTimeout: 5000 loggerLevel: full errorDecoder: com.pengjunlee.SimpleErrorDecoder retryer: com.pengjunlee.SimpleRetryer requestInterceptors: - com.pengjunlee.FooRequestInterceptor - com.pengjunlee.BarRequestInterceptor decode404: false encoder: com.pengjunlee.SimpleEncoder decoder: com.pengjunlee.SimpleDecoder contract: com.pengjunlee.SimpleContract 默认配置可以通过@EnableFeignClients的defaultConfiguration属性进行指定，然后会被应用到所有的Feign客户端。如果你希望使用配置文件对所有的@FeignClient进行配置，可以使用 default 作为Feign客户端的名称。 feign: client: config: default: connectTimeout: 5000 readTimeout: 5000 loggerLevel: basic 如果我们同时使用了@Configuration Bean和文件配置，文件配置会优先生效。如果你希望优先使用 @Configuration Bean中的配置，可以将 feign.client.default-to-properties 设置为 false 。 如果你需要在RequestInterceptor中使用ThreadLocal 变量，你需要将Hystrix 的线程隔离策略设置为 SEMAPHORE 或者直接禁用Hystrix 。 # To disable Hystrix in Feign feign: hystrix: enabled: false # To set thread isolation to SEMAPHORE hystrix: command: default: execution: isolation: strategy: SEMAPHORE 关于超时在启用Ribbon的情况下，Feign客户端是一个LoadBalancerFeignClient Bean，其内部有一个 execute() 方法用来发送一个HTTP请求并获取响应， 本质上其实还是使用的Ribbon做负载均衡，并使用RestTemplate发送的请求。execute() 接口声明如下： public Response execute(Request request, Request.Options options) throws IOException;其中，Request 用来封装HTTP请求的详细信息。 /** * * An immutable request to an http server. * */ public final class Request { private final String method; private final String url; private final Map&lt;String, Collection&lt;String&gt;&gt; headers; private final byte[] body; private final Charset charset; // ... } Options 则封装了一些请求控制参数： public static class Options { private final int connectTimeoutMillis; private final int readTimeoutMillis; private final boolean followRedirects; public Options(int connectTimeoutMillis, int readTimeoutMillis) { this(connectTimeoutMillis, readTimeoutMillis, true); } public Options() { this(10 * 1000, 60 * 1000); } // ... } 从Options 源码来看，Feign客户端默认的读取超时时间为60秒。若同时使用了Hystrix，由于Hystrix 默认的读取超时时间为1秒，会导致Feign客户端默认的读取超时时间设置无效，即超过1秒即为读取超时。可使用如下配置同时对Feign客户端和Hystrix 的超时配置进行重写。 feign: client: config: default: connectTimeout: 5000 readTimeout: 5000 参考文章https://cloud.spring.io/spring-cloud-openfeign/single/spring-cloud-openfeign.html https://www.jianshu.com/p/a0d50385e598 https://blog.csdn.net/chengqiuming/article/details/80713471","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Ribbon客户端负载均衡","slug":"SpringCloud之--Ribbon客户端负载均衡","date":"2020-05-31T08:43:38.000Z","updated":"2023-04-30T10:21:41.366Z","comments":true,"path":"2020/05/31/SpringCloud之--Ribbon客户端负载均衡/","link":"","permalink":"/2020/05/31/SpringCloud之--Ribbon客户端负载均衡/","excerpt":"","text":"服务器端负载均衡负载均衡是我们处理高并发、缓解网络压力和进行服务器扩容的重要手段之一，但是一般情况下我们所说的负载均衡通常都是指服务器端负载均衡，服务器端负载均衡又分为两种，一种是硬件负载均衡，还有一种是软件负载均衡。 硬件负载均衡主要通过在服务器节点之前安装专门用于负载均衡的设备，常见的如：F5。 软件负载均衡则主要是在服务器上安装一些具有负载均衡功能的软件来完成请求分发进而实现负载均衡，常见的如：LVS 、 Nginx 、Haproxy。 无论是硬件负载均衡还是软件负载均衡，它的工作原理都不外乎下面这张图： 客户端负载均衡而微服务的出现，则为负载均衡的实现提供了另外一种思路：把负载均衡的功能以库的方式集成到服务的消费方，而不再是由一台指定的负载均衡设备集中提供。这种方案称为软负载均衡（Soft Load Balancing）或者客户端负载均衡。常见的如：Spring Cloud中的 Ribbon。 Ribbon是一个基于HTTP和TCP的客户端负载均衡器，当我们将Ribbon和Eureka一起使用时，Ribbon会到Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用，客户端负载均衡也需要心跳机制去维护服务端清单的有效性，当然这个过程需要配合服务注册中心一起完成。 服务器端负载均衡 VS 客户端负载均衡的特点如下： 服务器端负载均衡 客户端先发送请求到负载均衡服务器，然后由负载均衡服务器通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求。 客户端负载均衡 客户端自己维护一个可用服务器地址列表，在发送请求前先通过负载均衡算法选择一个将用来处理本次请求的服务器，然后再直接将请求发送至该服务器。 接下来我们将延续上一章的Eureka注册中心，继续搭建一个基于Ribbon的客户端负载均衡示例。 Ribbon负载均衡示例搭建创建服务提供者引入依赖新建一个 Maven 工程，取名 message-service 用来提供消息服务，在其 pom.xml 文件中引入依赖，内容如下： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 添加配置application.yml添加配置如下： spring: application: name: message-service eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 服务提供者创建一个 MessageController 控制器对外提供一个http接口服务。 import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&quot;/api/v1/msg&quot;) public class MessageController { @Value(&quot;${server.port}&quot;) private String port; /** * 返回一条消息 */ @GetMapping(&quot;/get&quot;) public String getMsg() { return &quot;This message is sent from port: &quot; + port; } } 创建启动类import org.springframework.boot.WebApplicationType; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class MessageApplication { public static void main(String[] args) { new SpringApplicationBuilder(MessageApplication.class).web(WebApplicationType.SERVLET).run(args); } } 启动服务右键--&gt;Run As --&gt; Run Configurations...，分别使用 8771、8772、8773 三个端口各启动一个MessageApplication应用。 -Dserver.port=8771 -Dserver.port=8772 -Dserver.port=8773 启动完成后，浏览器输入：http://localhost:8761/ 效果图如下： 服务消费者引入Ribbon依赖新建一个 Maven 工程，取名 message-center 用来调用消息服务，在其 pom.xml 文件中引入依赖，内容如下： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Eureka-Client 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Ribbon 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 添加配置application.yml 添加配置如下： server: port: 8781 spring: application: name: message-center eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 使用Ribbon客户端方式一： 在启动类中向Spring容器中注入一个带有@LoadBalanced注解的RestTemplate Bean。 import org.springframework.boot.WebApplicationType; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.context.annotation.Bean; import org.springframework.web.client.RestTemplate; @SpringBootApplication @EnableEurekaClient public class MessageCenterApplication { @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } public static void main(String[] args) { new SpringApplicationBuilder(MessageCenterApplication.class).web(WebApplicationType.SERVLET).run(args); } } 在调用那些需要做负载均衡的服务时，使用上面注入的RestTemplate Bean进行调用即可。 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(&quot;/api/v1/center&quot;) public class MessageCenterController { @Autowired private RestTemplate restTemplate; @GetMapping(&quot;/msg/get&quot;) public Object getMsg() { String msg = restTemplate.getForObject(&quot;http://message-service/api/v1/msg/get&quot;, String.class); return msg; } } 方式二： 直接使用 LoadBalancerClient 中的负载均衡策略获取一个可用的服务地址，然后再进行请求。 import java.net.URI; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.loadbalancer.LoadBalancerClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; @RestController @RequestMapping(&quot;/api/v1/center&quot;) public class MessageCenterController { @Autowired private LoadBalancerClient loadBalancer; @GetMapping(&quot;/msg/get&quot;) public Object getMsg() { ServiceInstance instance = loadBalancer.choose(&quot;message-service&quot;); URI url = URI.create(String.format(&quot;http://%s:%s/api/v1/msg/get&quot;, instance.getHost(), instance.getPort())); RestTemplate restTemplate = new RestTemplate(); String msg = restTemplate.getForObject(url, String.class); return msg; } } 待应用启动之后，连续三次请求地址 http://localhost:8781/api/v1/center/msg/get ，返回的结果如图所示： 切换Ribbon负载均衡策略Ribbon本身提供了下面几种负载均衡策略： RoundRobinRule: 轮询策略，Ribbon以轮询的方式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问; RandomRule: 随机策略，也就是说Ribbon会随机从服务器列表中选择一个进行访问; BestAvailableRule: 最大可用策略，即先过滤出故障服务器后，选择一个当前并发请求数最小的; WeightedResponseTimeRule: 带有加权的轮询策略，对各个服务器响应时间进行加权处理，然后在采用轮询的方式来获取相应的服务器; AvailabilityFilteringRule: 可用过滤策略，先过滤出故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个; ZoneAvoidanceRule: 区域感知策略，先使用主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例清单，依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤，判断最小过滤数（默认1）和最小过滤百分比（默认0），最后对满足条件的服务器则使用RoundRobinRule(轮询方式)选择一个服务器实例。 我们可以将上例中的message-service的负载均衡策略设置为随机访问RandomRule，application.yml配置如下： message-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 当然，我们也可以通过继承ClientConfigEnabledRoundRobinRule，来实现自己的负载均衡策略。 自定义Ribbon客户端您可以使用外部属性按照 ..= 的格式对Ribbon客户端的某些特性进行配置，这与使用Netflix API类似。当然，你也可以在Springboot配置文件中进行配置。所有的配置项均以静态字段的形式定义在 CommonClientConfigKey 类（Ribbon核心的一部分）中。 SpringCloud还允许你在RibbonClientConfiguration的基础之上使用@RibbonClient声明一些额外配置，从而实现对Ribbon客户端的完全控制，如下例所示： import org.springframework.cloud.netflix.ribbon.RibbonClient; import org.springframework.cloud.netflix.ribbon.ZonePreferenceServerListFilter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.netflix.loadbalancer.IPing; import com.netflix.loadbalancer.PingUrl; import com.pengjunlee.TestConfiguration.MessageConfiguration; @Configuration @RibbonClient(name = &quot;message-service&quot;, configuration = MessageConfiguration.class) public class TestConfiguration { @Configuration protected static class MessageConfiguration { @Bean public ZonePreferenceServerListFilter serverListFilter() { ZonePreferenceServerListFilter filter = new ZonePreferenceServerListFilter(); filter.setZone(&quot;myTestZone&quot;); return filter; } @Bean public IPing ribbonPing() { return new PingUrl(); } } } 在这个例子中，这个Ribbon客户端将由RibbonClientConfiguration和MessageConfiguration中的组件一起组成（后者会覆盖前者的配置）。 注意：本例中，MessageConfiguration必须用@Configuration注解标注，但是它不应该被包含在Spring的组件扫描路径之中，否则它将被所有的Ribbon客户端共享。如果你使用@ComponentScan（或者@SpringBootApplication），那么你应该采取措施来避免它被包含到扫描范围之中。 下表列出了 Spring Cloud Netflix 缺省为Ribbon提供的所有 Bean： 创建这些类型的一个Bean 并将它写到 @RibbonClient 声明的配置中，这样你就能够对这些Bean中的每一个进行重写。例如上面的 MessageConfiguration 中利用PingUrl替代了NoOpPing并提供了一个自定义的serverListFilter。 自定义Ribbon客户端的默认配置通过@RibbonClients注解可以为所有的Ribbon客户端提供一个默认的配置。例如 import org.springframework.cloud.netflix.ribbon.RibbonClients; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.netflix.client.config.IClientConfig; import com.netflix.loadbalancer.BestAvailableRule; import com.netflix.loadbalancer.ConfigurationBasedServerList; import com.netflix.loadbalancer.IPing; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.PingUrl; import com.netflix.loadbalancer.Server; import com.netflix.loadbalancer.ServerList; import com.netflix.loadbalancer.ServerListSubsetFilter; @RibbonClients(defaultConfiguration = DefaultRibbonConfig.class) public class RibbonClientDefaultConfigurationTestsConfig { public static class BazServiceList extends ConfigurationBasedServerList { public BazServiceList(IClientConfig config) { super.initWithNiwsConfig(config); } } } @Configuration class DefaultRibbonConfig { @Bean public IRule ribbonRule() { return new BestAvailableRule(); } @Bean public IPing ribbonPing() { return new PingUrl(); } @Bean public ServerList&lt;Server&gt; ribbonServerList(IClientConfig config) { return new RibbonClientDefaultConfigurationTestsConfig.BazServiceList(config); } @Bean public ServerListSubsetFilter serverListFilter() { ServerListSubsetFilter filter = new ServerListSubsetFilter(); return filter; } } 通过配置属性自定义Ribbon客户端Spring Cloud Netflix 从1.2.0版本开始支持通过配置属性自定义Ribbon客户端，这可以让你在应用启动时根据不同的环境来改变Ribbon的行为。 支持配置的属性列表如下： &lt;clientName&gt;.ribbon.NFLoadBalancerClassName: 需实现 ILoadBalancer &lt;clientName&gt;.ribbon.NFLoadBalancerRuleClassName: 需实现 IRule &lt;clientName&gt;.ribbon.NFLoadBalancerPingClassName: 需实现 IPing &lt;clientName&gt;.ribbon.NIWSServerListClassName: 需实现 ServerList &lt;clientName&gt;.ribbon.NIWSServerListFilterClassName: 需实现 ServerListFilter 注意：通过配置属性定义的类与上述@RibbonClient配置类中定义的Bean以及Spring Cloud Netflix 提供的缺省配置相比具有更高的优先级。 例如对 message-service 服务的 IRule 属性进行修改，可以在application.yml中进行如下配置： message-service: ribbon: NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList NFLoadBalancerRuleClassName: com.netflix.loadbalancer.WeightedResponseTimeRule 脱离Eureka使用RibbonEureka提供了一种抽象的发现远程服务的便捷的方式，这样你就不必在客户端中硬编码服务地址列表，但是如果你不用Eureka，也可以继续使用Ribbon和Feign。假设在不使用Eureka，你用@RibbonClient声明了一个”stores”服务，这个时候Ribbon Client 默认会引用一个配置好的服务列表，你可以在application.yml中对它进行配置： stores: ribbon: listOfServers: example.com,google.com 在Ribbon中禁用Eureka通过将 ribbon.eureka.enabled 属性设置为 false 可以在Ribbon中禁用Eureka。 ribbon: eureka: enabled: false Ribbon缓存配置对于每一个Ribbon客户端，Spring Cloud都会维护一个与其相应的应用上下文，这个应用上下文会在相应服务第一次被请求时进行懒加载。你可以使用饥饿加载来取代懒加载，通过指定那些需要饥饿加载Ribbon客户端名称，在应用启动时就对其应用上下文进行加载。 ribbon: eager-load: enabled: true clients: client1, client2, client3 参考文章https://www.jianshu.com/p/d32ae141f680 https://blog.csdn.net/u014401141/article/details/78676296 https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.0.2.RELEASE/single/spring-cloud-netflix.html#spring-cloud-ribbon","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--Eureka服务注册中心","slug":"SpringCloud之--Eureka服务注册中心","date":"2020-05-31T08:42:38.000Z","updated":"2023-04-30T10:21:41.364Z","comments":true,"path":"2020/05/31/SpringCloud之--Eureka服务注册中心/","link":"","permalink":"/2020/05/31/SpringCloud之--Eureka服务注册中心/","excerpt":"","text":"Spring Cloud是一系列框架的集合，它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，构建了服务治理(服务注册与发现)、配置中心、消息总线、负载均衡、断路器、数据监控、分布式会话和集群状态管理等功能，为我们提供一整套企业级分布式云应用的完美解决方案。 Spring Cloud的服务治理等核心功能主要是通过Spring Cloud Netflix的相关产品来实现，包括：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）和客户端负载均衡（Ribbon）。 本文主要对如何使用Eureka搭建服务注册中心进行介绍，我们先从最简单的单机模式Eureka服务器搭建开始。 关于SpringCloud版本由于Spring Cloud是诸多子项目集合的综合项目，原则上由其子项目维护自己的发布版本号，也就是我们常用的版本号，如:1.2.3.RELEASE、1.1.4.RELEASE等。因此Spring Cloud为了避免版本号与其子项目的版本号混淆，所以没有采用版本号的方式，而是采用命名的方式。这些版本名称采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。比如，最早的Release版本名称为Angel，第二个Release版本的名称为Brixton，以此类推……。而我们在本系列文章所使用的版本名称为:Finchley.SR2，也就是目前的最新版本，其中的SR是service releases的简写，而1则是该版本名称中的第1个版本。其对应的Springboot版本为2.0.6.RELEASE。 关于更多版本的介绍，请参考官网。 单机模式Eureka注册中心引入Eureka-Server依赖新建一个 Maven 工程，并在其pom.xml文件中引入依赖，内容如下： &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka-Server 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud 版本控制依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; 创建启动类import org.springframework.boot.WebApplicationType; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.builder.SpringApplicationBuilder; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaServerApplication { public static void main(String[] args) { new SpringApplicationBuilder(EurekaServerApplication.class).web(WebApplicationType.SERVLET).run(args); } } 添加配置默认情况下，每一个Eureka服务端同时也是Eureka客户端，你需要为它提供（至少一个）service-url 让它用来定位它的同类（其他Eureka服务端），如果你一个service-url 都不提供，服务虽然能够运行并且正常工作，但是它会在你的日志文件中插入很多由于它不能成功注册到同类而生成的噪音日志。 在集群模式下，两个Eureka（一个服务端和一个客户端）通过注册表合并和心跳监控能够让一个独立的Eureka服务端从故障中完美复活（只要还有监控或者弹性运行环境使它保持存活）。在单机模式，我们需要关闭Eureka的这些客户端行为，这样的话它就不会再不停地去尝试连接它的同类并不停地失败了。 在 Springboot的核心配置文件 application.yml 中加入如下配置来关闭Eureka的客户端行为： server: port: 8761 eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 其中fetch-registry和register-with-eureka两个配置用来关闭Eureka的客户端行为。 fetch-registry：表示是否从eureka server获取注册表信息，如果是单一节点，不需要同步其他eureka server节点，则可以设置为false；若是集群，则设置为true，默认为true。 register-with-eureka：表示是否将自己注册到eureka server，默认为true。 高可用Eureka注册中心由于Eureka服务端没有后台存储，但是所有的服务实例都需要不断地向Eureka服务端发送心跳来更新它们在注册表中的状态，所以，这一系列的功能只能在内存中完成的。同时，每一个Eureka客户端都有一个内存缓存存储了Eureka的注册表信息，对服务的请求可以直接从缓存的注册表中获取，并不需要每一次都到Eureka注册表中去获取。 你可以添加多个同类Eureka实例到你的系统中，只要它们彼此之间能够相互连接，它们就能够在彼此之间进行注册表同步，这能够让Eureka具有更高的弹性和可用性。事实上，这也是Eureka的默认行为，所以你唯一要做的就是配置一个有效的同类serviceUrl 来使它生效。 双节点注册中心修改配置文件修改上例中的application.yml文件，内容如下： --- server: port: 8761 spring: profiles: peer1 application: name: eureka-server eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8762/eureka/ --- server: port: 8762 spring: profiles: peer2 application: name: eureka-server eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8761/eureka/ 有了这个YAML文件，我们就能够在一台服务器上通过在启动时指定不同的Spring profile来模拟启动两个主机（peer1和peer2）了。事实上，如果你是在一个知晓自己主机名（默认主机是通过java.net.InetAddress 进行查找）的服务器上运行程序，eureka.instance.hostname配置项并不是必须的。 修改hosts文件修改Windows系统的hosts文件: # Windows：C:\\Windows\\System32\\drivers\\etc\\hosts # Linux：/etc/hosts 在hosts文件中加入如下配置： 127.0.0.1 peer1 127.0.0.1 peer2 127.0.0.1 peer3 启动测试右键--&gt;Run As --&gt; Run Configurations...，分别以peer1和peeer2 配置信息启动EurekaServerApplication。 --spring.profiles.active=peer1 --spring.profiles.active=peer2 依次启动完成后，浏览器输入：&lt;http://peer1:8761/&gt; 效果图如下： 多节点注册中心修改配置文件在生产中我们可能需要三台或者大于三台的注册中心来保证服务的稳定性，配置的原理其实都一样，将注册中心分别指向其它的注册中心。这里只介绍三台集群的配置情况，其实和双节点的注册中心类似，修改上例中的application.yml文件，再添加一个 profiles 配置，内容如下： --- server: port: 8761 spring: profiles: peer1 application: name: eureka-server eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2:8762/eureka/,http://peer3:8763/eureka/ --- server: port: 8762 spring: profiles: peer2 application: name: eureka-server eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1:8761/eureka/,http://peer3:8763/eureka/ --- server: port: 8763 spring: profiles: peer3 application: name: eureka-server eureka: instance: hostname: peer3 client: serviceUrl: defaultZone: http://peer1:8761/eureka/,http://peer2:8762/eureka/ 启动测试分别加载三个profiles的配置启动EurekaServerApplication。 常见问题EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 出现原因：默认情况下，为了防止由于网络问题而造成的已经正常启动的Eureka实例无法成功注册，Eureka会开启自我保护模式，这样即使Eureka实例续约失败也不会从可用列表中被剔除，可继续从注册表中返回并对外提供服务。 解决办法：关闭自我保护模式，将配置 eureka.server.enable-self-preservation 设置为 false 。关闭自我保护之后，提示信息将变为如下内容： THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS. 参考文章https://cloud.spring.io/spring-cloud-static/spring-cloud-netflix/2.0.2.RELEASE/single/spring-cloud-netflix.html https://www.jianshu.com/p/d32ae141f680 http://spring.io/projects/spring-cloud","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"SpringCloud系列之--CAP定理","slug":"SpringCloud之--CAP定理","date":"2020-05-31T08:41:38.000Z","updated":"2023-04-30T10:21:41.364Z","comments":true,"path":"2020/05/31/SpringCloud之--CAP定理/","link":"","permalink":"/2020/05/31/SpringCloud之--CAP定理/","excerpt":"","text":"定理简介1998年，加州大学的计算机科学家 Eric Brewer 提出了分布式系统的三个指标： C：Consistency，一致性。在分布式系统中的所有数据备份，在同一时刻具有同样的值，所有节点在同一时刻读取的数据都是最新的数据副本（all nodes see the same data at the same time）。 A：Availability ，可用性，好的响应性能。完全的可用性指的是在任何故障模型下，服务都会在有限的时间内处理完成并进行响应（Reads and writes always succeed）。 P：Partition Tolerance ，分区容错性，即分布式系统在遇到某些节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。分区容错性要求一个分布式系统中有某一个或者几个节点故障时，其他剩下的节点还能够正常运转并对外提供服务，对于用户而言并没有什么体验上的影响。 Eric Brewer 指出任何分布式系统只可同时满足CAP三个指标中的两个，无法三者兼顾，这个结论就叫做 CAP 定理。 定理解读分布式的服务化系统都需要满足分区容忍性，那么我们必须在一致性（C）和可用性（A）之间进行权衡。在网络分区故障发生时，两个分布式节点之间无法进行通信，那么我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的一致性（C）将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲可用性（A），也就是在网络分区故障发生时，暂停分布式系统对外提供修改数据服务，直到网络状况完全恢复正常再继续对外提供修改数据服务。 CP满足的情况下，A不能满足的原因：若要满足一致性（C）就需要在多个分布式节点之间进行数据同步，在数据同步完成之前整个系统都将不可用。节点数量越多分区容错性（P）越好，同时数据同步所耗费的时间自然也就越长，从而无法在有限的时间内完成请求响应，导致可用性（A）不能满足。 CA满足的情况下，P不能满足的原因：若要满足一致性（C）就需要在多个分布式节点之间进行数据同步，在数据同步完成之前整个系统都将不可用。需同步的节点数量越多，数据同步所需耗费的时间越长，可用性（A）也越差。若要同时保证可用性（A），那么需同步的节点数量就需要尽量减少，从而导致分区容错性（P）无法满足。 AP满足的情况下，C不能满足的原因：节点的数量越多，分区容错性（P）越好，节点间数据同步所需耗费的时间越长，若要在有限的时间内完成请求响应即保证可用性（A），那么数据就可能不能及时地同步到其他节点，从而无法保证节点间的数据一致性（C）。 如何抉择对于现如今大多数的互联网应用场景，都倾向于采用分布式微服务架构，它们通常节点众多、部署相对分散，随着集群规模变得越来越大，节点故障、网络故障已是常态。 在这种情况下，对于那些对数据一致性（C）要求不高的场景，例如电商系统，我们只需要保证分区容错性（P）和可用性（A），对于数据一致性（C）退而求其次仅保证数据的最终一致性即可。这虽然会某些地方影响客户体验，但并不会达到造成用户流失的严重程度。 对于像银行系统这类对数据一致性（C）要求较高的场景，数据一致性（C）必须保证。网络发生故障宁可停止服务（或者只读不写），这是保证分区容错性（P）和数据一致性（C），舍弃可用性（A）。 目前比较主流的注册中心有 Zookeeper、Eureka、Consul、Etcd 等，以Zookeeper 和Eureka为例， 在进行注册中心选择时，CAP又该如何抉择呢？ Zookeeper：CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举新的Leader，或者半数以上节点不可用，则无法提供服务，因此可用性（A）没法满足。 Eureka：AP设计，无主从节点，一个节点挂了，自动切换其他节点继续使用，去中心化，但数据一致性（C）不满足。 在分布式系统中分区容错性（P）肯定要满足，所以只能在CA中二选一， 没有最好的选择，只有更适合的，我们需要根据自己的业务场景来进行架构设计： 如果要求一致性，则选择 Zookeeper，如金融行业 如果要求可用性，则选择 Eureka，如电商系统","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"SpringCloud,Java,SpringBoot","slug":"SpringCloud-Java-SpringBoot","permalink":"/tags/SpringCloud-Java-SpringBoot/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--线程上下文类加载器","slug":"深入理解JVM之--线程上下文类加载器","date":"2020-05-30T09:53:38.000Z","updated":"2023-04-30T10:21:41.373Z","comments":true,"path":"2020/05/30/深入理解JVM之--线程上下文类加载器/","link":"","permalink":"/2020/05/30/深入理解JVM之--线程上下文类加载器/","excerpt":"","text":"转载自：《深入理解Java类加载器(2)：线程上下文类加载器》 一、线程上下文类加载器线程上下文类加载器（context class loader）是从 JDK 1.2 开始引入的。类 java.lang.Thread中的方法 getContextClassLoader()和 setContextClassLoader(ClassLoader cl)用来获取和设置线程的上下文类加载器。如果没有通过 setContextClassLoader(ClassLoader cl)方法进行设置的话，线程将继承其父线程的上下文类加载器。Java 应用运行的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过此类加载器来加载类和资源。 前面提到的类加载器的代理模式并不能解决 Java 应用开发中会遇到的类加载器的全部问题。Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。这些 SPI 的接口由 Java 核心库来提供，如 JAXP 的 SPI 接口定义包含在 javax.xml.parsers包中。这些 SPI 的实现代码很可能是作为 Java 应用所依赖的 jar 包被包含进来，可以通过类路径（CLASSPATH）来找到，如实现了 JAXP SPI 的 Apache Xerces所包含的 jar 包。SPI 接口中的代码经常需要加载具体的实现类。如 JAXP 中的 javax.xml.parsers.DocumentBuilderFactory类中的 newInstance()方法用来生成一个新的 DocumentBuilderFactory的实例。这里的实例的真正的类是继承自 javax.xml.parsers.DocumentBuilderFactory，由 SPI 的实现所提供的。如在 Apache Xerces 中，实现的类是 org.apache.xerces.jaxp.DocumentBuilderFactoryImpl。而问题在于，SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的；SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。也就是说，类加载器的代理模式无法解决这个问题。 线程上下文类加载器正好解决了这个问题。如果不做任何的设置，Java 应用的线程的上下文类加载器默认就是系统上下文类加载器。在 SPI 接口的代码中使用线程上下文类加载器，就可以成功的加载到 SPI 实现的类。线程上下文类加载器在很多 SPI 的实现中都会用到。 Java默认的线程上下文类加载器是系统类加载器(AppClassLoader)。以下代码摘自sun.misc.Launch的无参构造函数Launch()。 // Now create the class loader to use to launch the application try { loader = AppClassLoader.getAppClassLoader(extcl); } catch (IOException e) { throw new InternalError( &quot;Could not create application class loader&quot; ); } // Also set the context class loader for the primordial thread. Thread.currentThread().setContextClassLoader(loader); 使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类。典型的例子有：通过线程上下文来加载第三方库jndi实现，而不依赖于双亲委派。大部分java application服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。还有一些采用hot swap特性的框架，也使用了线程上下文类加载器，比如 seasar (full stack framework in japenese)。 线程上下文从根本解决了一般应用不能违背双亲委派模式的问题。使java类加载体系显得更灵活。随着多核时代的来临，相信多线程开发将会越来越多地进入程序员的实际编码过程中。因此，在编写基础设施时， 通过使用线程上下文来加载类，应该是一个很好的选择。 当然，好东西都有利弊。使用线程上下文加载类，也要注意保证多个需要通信的线程间的类加载器应该是同一个，防止因为不同的类加载器导致类型转换异常(ClassCastException)。 defineClass(String name, byte[] b, int off, int len,ProtectionDomain protectionDomain)是java.lang.Classloader提供给开发人员，用来自定义加载class的接口。使用该接口，可以动态的加载class文件。例如在jdk中，URLClassLoader是配合findClass方法来使用defineClass，可以从网络或硬盘上加载class。而使用类加载接口，并加上自己的实现逻辑，还可以定制出更多的高级特性。 下面是一个简单的hot swap类加载器实现。hot swap即热插拔的意思，这里表示一个类已经被一个加载器加载了以后，在不卸载它的情况下重新再加载它一次。我们知道Java缺省的加载器对相同全名的类只会加载一次，以后直接从缓存中取这个Class object。因此要实现hot swap，必须在加载的那一刻进行拦截，先判断是否已经加载，若是则重新加载一次，否则直接首次加载它。我们从URLClassLoader继承，加载类的过程都代理给系统类加载器URLClassLoader中的相应方法来完成。 package classloader; import java.net.URL; import java.net.URLClassLoader; /** * 可以重新载入同名类的类加载器实现 * 放弃了双亲委派的加载链模式，需要外部维护重载后的类的成员变量状态 */ public class HotSwapClassLoader extends URLClassLoader { public HotSwapClassLoader(URL[] urls) { super(urls); } public HotSwapClassLoader(URL[] urls, ClassLoader parent) { super(urls, parent); } // 下面的两个重载load方法实现类的加载，仿照ClassLoader中的两个loadClass() // 具体的加载过程代理给父类中的相应方法来完成 public Class&lt;?&gt; load(String name) throws ClassNotFoundException { return load(name, false); } public Class&lt;?&gt; load(String name, boolean resolve) throws ClassNotFoundException { // 若类已经被加载，则重新再加载一次 if (null != super.findLoadedClass(name)) { return reload(name, resolve); } // 否则用findClass()首次加载它 Class&lt;?&gt; clazz = super.findClass(name); if (resolve) { super.resolveClass(clazz); } return clazz; } public Class&lt;?&gt; reload(String name, boolean resolve) throws ClassNotFoundException { return new HotSwapClassLoader(super.getURLs(), super.getParent()).load( name, resolve); } } 两个重载的load方法参数与ClassLoader类中的两个loadClass()相似。在load的实现中，用findLoadedClass()查找指定的类是否已经被祖先加载器加载了，若已加载则重新再加载一次，从而放弃了双亲委派的方式（这种方式只会加载一次）。若没有加载则用自身的findClass()来首次加载它。下面是使用示例： package classloader; public class A { private B b; public void setB(B b) { this.b = b; } public B getB() { return b; } } package classloader; public class B { } package classloader; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.net.MalformedURLException; import java.net.URL; public class TestHotSwap { public static void main(String args[]) throws MalformedURLException { A a = new A(); // 加载类A B b = new B(); // 加载类B a.setB(b); // A引用了B，把b对象拷贝到A.b System.out.printf(&quot;A classLoader is %s\\n&quot;, a.getClass().getClassLoader()); System.out.printf(&quot;B classLoader is %s\\n&quot;, b.getClass().getClassLoader()); System.out.printf(&quot;A.b classLoader is %s\\n&quot;, a.getB().getClass().getClassLoader()); try { URL[] urls = new URL[]{ new URL(&quot;file:///C:/Users/JackZhou/Documents/NetBeansProjects/classloader/build/classes/&quot;) }; HotSwapClassLoader c1 = new HotSwapClassLoader(urls, a.getClass().getClassLoader()); Class clazz = c1.load(&quot;classloader.A&quot;); // 用hot swap重新加载类A Object aInstance = clazz.newInstance(); // 创建A类对象 Method method1 = clazz.getMethod(&quot;setB&quot;, B.class); // 获取setB(B b)方法 method1.invoke(aInstance, b); // 调用setB(b)方法，重新把b对象拷贝到A.b Method method2 = clazz.getMethod(&quot;getB&quot;); // 获取getB()方法 Object bInstance = method2.invoke(aInstance); // 调用getB()方法 System.out.printf(&quot;Reloaded A.b classLoader is %s\\n&quot;, bInstance.getClass().getClassLoader()); } catch (MalformedURLException | ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException e) { e.printStackTrace(); } } } 运行输出： A classLoader is sun.misc.Launcher$AppClassLoader@73d16e93B classLoader is sun.misc.Launcher$AppClassLoader@73d16e93A.b classLoader is sun.misc.Launcher$AppClassLoader@73d16e93Reloaded A.b classLoader is sun.misc.Launcher$AppClassLoader@73d16e93 HotSwapClassLoader加载器的作用是重新加载同名的类。为了实现hot swap，一个类在加载过后，若重新再加载一次，则新的Class object的状态会改变，老的状态数据需要通过其他方式拷贝到重新加载过的类生成的全新Class object实例中来。上面A类引用了B类，加载A时也会加载B（如果B已经加载，则直接从缓存中取出）。在重新加载A后，其Class object中的成员b会重置，因此要重新调用setB(b)拷贝一次。你可以注释掉这行代码，再运行会抛出java.lang.NullPointerException，指示A.b为null。 注意新的A Class object实例所依赖的B类Class object，如果它与老的B Class object实例不是同一个类加载器加载的， 将会抛出类型转换异常(ClassCastException)，表示两种不同的类。因此在重新加载A后，要特别注意给它的B类成员b传入外部值时，它们是否由同一个类加载器加载。为了解决这种问题， HotSwapClassLoader自定义的l/oad方法中，当前类（类A）是由自身classLoader加载的， 而内部依赖的类（类B）还是老对象的classLoader加载的。 二、何时使用?这是一个很常见的问题，但答案却很难回答。这个问题通常在需要动态加载类和资源的系统编程时会遇到。总的说来动态加载资源时，往往需要从三种类加载器里选择：系统或程序的类加载器、当前类加载器、以及当前线程的上下文类加载器。在程序中应该使用何种类加载器呢？ 系统类加载器通常不会使用。此类加载器处理启动应用程序时classpath指定的类，可以通过ClassLoader.getSystemClassLoader()来获得。所有的ClassLoader.getSystemXXX()接口也是通过这个类加载器加载的。一般不要显式调用这些方法，应该让其他类加载器代理到系统类加载器上。由于系统类加载器是JVM最后创建的类加载器，这样代码只会适应于简单命令行启动的程序。一旦代码移植到EJB、Web应用或者Java Web Start应用程序中，程序肯定不能正确执行。 因此一般只有两种选择，当前类加载器和线程上下文类加载器。当前类加载器是指当前方法所在类的加载器。这个类加载器是运行时类解析使用的加载器，Class.forName(String)和Class.getResource(String)也使用该类加载器。代码中X.class的写法使用的类加载器也是这个类加载器。 线程上下文类加载器在Java 2(J2SE)时引入。每个线程都有一个关联的上下文类加载器。如果你使用new Thread()方式生成新的线程，新线程将继承其父线程的上下文类加载器。如果程序对线程上下文类加载器没有任何改动的话，程序中所有的线程将都使用系统类加载器作为上下文类加载器。Web应用和Java企业级应用中，应用服务器经常要使用复杂的类加载器结构来实现JNDI（Java命名和目录接口)、线程池、组件热部署等功能，因此理解这一点尤其重要。 为什么要引入线程的上下文类加载器？将它引入J2SE并不是纯粹的噱头，由于Sun没有提供充分的文档解释说明这一点，这使许多开发者很糊涂。实际上，上下文类加载器为同样在J2SE中引入的类加载代理机制提供了后门。通常JVM中的类加载器是按照层次结构组织的，目的是每个类加载器（除了启动整个JVM的原初类加载器）都有一个父类加载器。当类加载请求到来时，类加载器通常首先将请求代理给父类加载器。只有当父类加载器失败后，它才试图按照自己的算法查找并定义当前类。 有时这种模式并不能总是奏效。这通常发生在JVM核心代码必须动态加载由应用程序动态提供的资源时。拿JNDI为例，它的核心是由JRE核心类(rt.jar)实现的。但这些核心JNDI类必须能加载由第三方厂商提供的JNDI实现。这种情况下调用父类加载器（原初类加载器）来加载只有其子类加载器可见的类，这种代理机制就会失效。解决办法就是让核心JNDI类使用线程上下文类加载器，从而有效的打通类加载器层次结构，逆着代理机制的方向使用类加载器。 顺便提一下，XML解析API(JAXP)也是使用此种机制。当JAXP还是J2SE扩展时，XML解析器使用当前类加载器方法来加载解析器实现。但当JAXP成为J2SE核心代码后，类加载机制就换成了使用线程上下文加载器，这和JNDI的原因相似。 好了，现在我们明白了问题的关键：这两种选择不可能适应所有情况。一些人认为线程上下文类加载器应成为新的标准。但这在不同JVM线程共享数据来沟通时，就会使类加载器的结构乱七八糟。除非所有线程都使用同一个上下文类加载器。而且，使用当前类加载器已成为缺省规则，它们广泛应用在类声明、Class.forName等情景中。即使你想尽可能只使用上下文类加载器，总是有这样那样的代码不是你所能控制的。这些代码都使用代理到当前类加载器的模式。混杂使用代理模式是很危险的。 更为糟糕的是，某些应用服务器将当前类加载器和上下文类加器分别设置成不同的ClassLoader实例。虽然它们拥有相同的类路径，但是它们之间并不存在父子代理关系。想想这为什么可怕：记住加载并定义某个类的类加载器是虚拟机内部标识该类的组成部分，如果当前类加载器加载类X并接着执行它，如JNDI查找类型为Y的数据，上下文类加载器能够加载并定义Y，这个Y的定义和当前类加载器加载的相同名称的类就不是同一个，使用隐式类型转换就会造成异常。 这种混乱的状况还将在Java中存在很长时间。在J2SE中还包括以下的功能使用不同的类加载器： JNDI使用线程上下文类加载器。 Class.getResource()和Class.forName()使用当前类加载器。 JAXP使用上下文类加载器。 java.util.ResourceBundle使用调用者的当前类加载器。 URL协议处理器使用java.protocol.handler.pkgs系统属性并只使用系统类加载器。 Java序列化API缺省使用调用者当前的类加载器。 这些类加载器非常混乱，没有在J2SE文档中给以清晰明确的说明。 该如何选择类加载器？ 如若代码是限于某些特定框架，这些框架有着特定加载规则，则不要做任何改动，让框架开发者来保证其工作（比如应用服务器提供商，尽管他们并不能总是做对）。如在Web应用和EJB中，要使用Class.gerResource来加载资源。 在其他情况下，我们可以自己来选择最合适的类加载器。可以使用策略模式来设计选择机制。其思想是将“总是使用上下文类加载器”或者“总是使用当前类加载器”的决策同具体实现逻辑分离开。往往设计之初是很难预测何种类加载策略是合适的，该设计能够让你可以后来修改类加载策略。 考虑使用下面的代码，这是作者本人在工作中发现的经验。这儿有一个缺省实现，应该可以适应大部分工作场景： package classloader.context; /** * 类加载上下文，持有要加载的类 */ public class ClassLoadContext { private final Class m_caller; public final Class getCallerClass() { return m_caller; } ClassLoadContext(final Class caller) { m_caller = caller; } } package classloader.context; /** * 类加载策略接口 */ public interface IClassLoadStrategy { ClassLoader getClassLoader(ClassLoadContext ctx); } /** * 缺省的类加载策略，可以适应大部分工作场景 */ public class DefaultClassLoadStrategy implements IClassLoadStrategy { /** * 为ctx返回最合适的类加载器，从系统类加载器、当前类加载器 * 和当前线程上下文类加载中选择一个最底层的加载器 * @param ctx * @return */ @Override public ClassLoader getClassLoader(final ClassLoadContext ctx) { final ClassLoader callerLoader = ctx.getCallerClass().getClassLoader(); final ClassLoader contextLoader = Thread.currentThread().getContextClassLoader(); ClassLoader result; // If &#39;callerLoader&#39; and &#39;contextLoader&#39; are in a parent-child // relationship, always choose the child: if (isChild(contextLoader, callerLoader)) { result = callerLoader; } else if (isChild(callerLoader, contextLoader)) { result = contextLoader; } else { // This else branch could be merged into the previous one, // but I show it here to emphasize the ambiguous case: result = contextLoader; } final ClassLoader systemLoader = ClassLoader.getSystemClassLoader(); // Precaution for when deployed as a bootstrap or extension class: if (isChild(result, systemLoader)) { result = systemLoader; } return result; } // 判断anotherLoader是否是oneLoader的child private boolean isChild(ClassLoader oneLoader, ClassLoader anotherLoader){ //... } // ... more methods } 决定应该使用何种类加载器的接口是IClassLoaderStrategy，为了帮助IClassLoadStrategy做决定，给它传递了个ClassLoadContext对象作为参数。ClassLoadContext持有要加载的类。 上面代码的逻辑很简单：如调用类的当前类加载器和上下文类加载器是父子关系，则总是选择子类加载器。对子类加载器可见的资源通常是对父类可见资源的超集，因此如果每个开发者都遵循J2SE的代理规则，这样做大多数情况下是合适的。 当前类加载器和上下文类加载器是兄弟关系时，决定使用哪一个是比较困难的。理想情况下，Java运行时不应产生这种模糊。但一旦发生，上面代码选择上下文类加载器。这是作者本人的实际经验，绝大多数情况下应该能正常工作。你可以修改这部分代码来适应具体需要。一般来说，上下文类加载器要比当前类加载器更适合于框架编程，而当前类加载器则更适合于业务逻辑编程。 最后需要检查一下，以便保证所选类加载器不是系统类加载器的父亲，在开发标准扩展类库时这通常是个好习惯。注意作者故意没有检查要加载资源或类的名称。Java XML API成为J2SE核心的历程应该能让我们清楚过滤类名并不是好想法。作者也没有试图检查哪个类加载器加载首先成功，而是检查类加载器的父子关系，这是更好更有保证的方法。 下面是类加载器的选择器： package classloader.context; /** * 类加载解析器，获取最合适的类加载器 */ public abstract class ClassLoaderResolver { private static IClassLoadStrategy s_strategy; // initialized in &lt;clinit&gt; private static final int CALL_CONTEXT_OFFSET = 3; // may need to change if this class is redesigned private static final CallerResolver CALLER_RESOLVER; // set in &lt;clinit&gt; static { try { // This can fail if the current SecurityManager does not allow // RuntimePermission (&quot;createSecurityManager&quot;): CALLER_RESOLVER = new CallerResolver(); } catch (SecurityException se) { throw new RuntimeException(&quot;ClassLoaderResolver: could not create CallerResolver: &quot; + se); } s_strategy = new DefaultClassLoadStrategy(); //默认使用缺省加载策略 } /** * This method selects the best classloader instance to be used for * class/resource loading by whoever calls this method. The decision * typically involves choosing between the caller&#39;s current, thread context, * system, and other classloaders in the JVM and is made by the {@link IClassLoadStrategy} * instance established by the last call to {@link #setStrategy}. * * @return classloader to be used by the caller [&#39;null&#39; indicates the * primordial loader] */ public static synchronized ClassLoader getClassLoader() { final Class caller = getCallerClass(0); // 获取执行当前方法的类 final ClassLoadContext ctx = new ClassLoadContext(caller); // 创建类加载上下文 return s_strategy.getClassLoader(ctx); // 获取最合适的类加载器 } public static synchronized IClassLoadStrategy getStrategy() { return s_strategy; } public static synchronized IClassLoadStrategy setStrategy(final IClassLoadStrategy strategy) { final IClassLoadStrategy old = s_strategy; // 设置类加载策略 s_strategy = strategy; return old; } /** * A helper class to get the call context. It subclasses SecurityManager * to make getClassContext() accessible. An instance of CallerResolver * only needs to be created, not installed as an actual security manager. */ private static final class CallerResolver extends SecurityManager { @Override protected Class[] getClassContext() { return super.getClassContext(); // 获取当执行栈的所有类，native方法 } } /* * Indexes into the current method call context with a given * offset. */ private static Class getCallerClass(final int callerOffset) { return CALLER_RESOLVER.getClassContext()[CALL_CONTEXT_OFFSET + callerOffset]; // 获取执行栈上某个方法所属的类 } } 可通过调用ClassLoaderResolver.getClassLoader()方法来获取类加载器对象，并使用其ClassLoader的接口如loadClass()等来加载类和资源。此外还可使用下面的ResourceLoader接口来取代ClassLoader接口： package classloader.context; import java.net.URL; public class ResourceLoader { /** * 加载一个类 * * @param name * @return * @throws java.lang.ClassNotFoundException * @see java.lang.ClassLoader#loadClass(java.lang.String) */ public static Class&lt;?&gt; loadClass(final String name) throws ClassNotFoundException { //获取最合适的类加载器 final ClassLoader loader = ClassLoaderResolver.getClassLoader(); //用指定加载器加载类 return Class.forName(name, false, loader); } /** * 加载一个资源 * * @param name * @return * @see java.lang.ClassLoader#getResource(java.lang.String) */ public static URL getResource(final String name) { //获取最合适的类加载器 final ClassLoader loader = ClassLoaderResolver.getClassLoader(); //查找指定的资源 if (loader != null) { return loader.getResource(name); } else { return ClassLoader.getSystemResource(name); } } // ... more methods ... } ClassLoadContext.getCallerClass()返回的类在ClassLoaderResolver或ResourceLoader使用，这样做的目的是让其能找到调用类的类加载器（上下文加载器总是能通过Thread.currentThread().getContextClassLoader()来获得）。注意调用类是静态获得的，因此这个接口不需现有业务方法增加额外的Class参数，而且也适合于静态方法和类初始化代码。具体使用时，可以往这个上下文对象中添加具体部署环境中所需的其他属性。 三、类加载器与Web容器对于运行在 Java EE容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。 绝大多数情况下，Web 应用的开发人员不需要考虑与类加载器相关的细节。下面给出几条简单的原则： 每个 Web 应用自己的 Java 类文件和使用的库的 jar 包，分别放在 WEB-INF/classes和 WEB-INF/lib目录下面。 多个应用共享的 Java 类文件和 jar 包，分别放在 Web 容器指定的由所有 Web 应用共享的目录下面。 当出现找不到类的错误时，检查当前类的类加载器和当前线程的上下文类加载器是否正确。 四、类加载器与OSGiOSGi是 Java 上的动态模块系统。它为开发人员提供了面向服务和基于组件的运行环境，并提供标准的方式用来管理软件的生命周期。OSGi 已经被实现和部署在很多产品上，在开源社区也得到了广泛的支持。Eclipse就是基于OSGi 技术来构建的。 OSGi 中的每个模块（bundle）都包含 Java 包和类。模块可以声明它所依赖的需要导入（import）的其它模块的 Java 包和类（通过 Import-Package），也可以声明导出（export）自己的包和类，供其它模块使用（通过 Export-Package）。也就是说需要能够隐藏和共享一个模块中的某些 Java 包和类。这是通过 OSGi 特有的类加载器机制来实现的。OSGi 中的每个模块都有对应的一个类加载器。它负责加载模块自己包含的 Java 包和类。当它需要加载 Java 核心库的类时（以 java开头的包和类），它会代理给父类加载器（通常是启动类加载器）来完成。当它需要加载所导入的 Java 类时，它会代理给导出此 Java 类的模块来完成加载。 模块也可以显式的声明某些 Java 包和类，必须由父类加载器来加载。只需要设置系统属性 org.osgi.framework.bootdelegation的值即可。 假设有两个模块 bundleA 和 bundleB，它们都有自己对应的类加载器 classLoaderA 和 classLoaderB。在 bundleA 中包含类 com.bundleA.Sample，并且该类被声明为导出的，也就是说可以被其它模块所使用的。bundleB 声明了导入 bundleA 提供的类 com.bundleA.Sample，并包含一个类 com.bundleB.NewSample继承自 com.bundleA.Sample。在 bundleB 启动的时候，其类加载器 classLoaderB 需要加载类 com.bundleB.NewSample，进而需要加载类 com.bundleA.Sample。由于 bundleB 声明了类 com.bundleA.Sample是导入的，classLoaderB 把加载类 com.bundleA.Sample的工作代理给导出该类的 bundleA 的类加载器 classLoaderA。classLoaderA 在其模块内部查找类 com.bundleA.Sample并定义它，所得到的类 com.bundleA.Sample实例就可以被所有声明导入了此类的模块使用。对于以 java开头的类，都是由父类加载器来加载的。如果声明了系统属性 org.osgi.framework.bootdelegation=com.example.core.*，那么对于包 com.example.core中的类，都是由父类加载器来完成的。 OSGi 模块的这种类加载器结构，使得一个类的不同版本可以共存在 Java 虚拟机中，带来了很大的灵活性。不过它的这种不同，也会给开发人员带来一些麻烦，尤其当模块需要使用第三方提供的库的时候。下面提供几条比较好的建议： 如果一个类库只有一个模块使用，把该类库的 jar 包放在模块中，在 Bundle-ClassPath中指明即可。 如果一个类库被多个模块共用，可以为这个类库单独的创建一个模块，把其它模块需要用到的 Java 包声明为导出的。其它模块声明导入这些类。 如果类库提供了 SPI 接口，并且利用线程上下文类加载器来加载 SPI 实现的 Java 类，有可能会找不到 Java 类。如果出现了 NoClassDefFoundError异常，首先检查当前线程的上下文类加载器是否正确。通过 Thread.currentThread().getContextClassLoader()就可以得到该类加载器。该类加载器应该是该模块对应的类加载器。如果不是的话，可以首先通过 class.getClassLoader()来得到模块对应的类加载器，再通过 Thread.currentThread().setContextClassLoader()来设置当前线程的上下文类加载器。 总结类加载器是 Java 语言的一个创新。它使得动态安装和更新软件组件成为可能。本文详细介绍了类加载器的相关话题，包括基本概念、代理模式、线程上下文类加载器、与 Web 容器和 OSGi 的关系等。开发人员在遇到 ClassNotFoundException和 NoClassDefFoundError等异常的时候，应该检查抛出异常的类的类加载器和当前线程的上下文类加载器，从中可以发现问题的所在。在开发自己的类加载器的时候，需要注意与已有的类加载器组织结构的协调。 参考文献：https://www.ibm.com/developerworks/cn/java/j-lo-classloader/ http://www.blogjava.net/lihao336/archive/2009/09/17/295489.html http://kenwublog.com/structure-of-java-class-loader","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--Java类加载原理解析","slug":"深入理解JVM之--Java类加载原理解析","date":"2020-05-30T09:48:38.000Z","updated":"2023-04-30T10:21:41.370Z","comments":true,"path":"2020/05/30/深入理解JVM之--Java类加载原理解析/","link":"","permalink":"/2020/05/30/深入理解JVM之--Java类加载原理解析/","excerpt":"","text":"转载自：《深入理解Java类加载器(1)：Java类加载原理解析》 一、前言每个开发人员对Java.lang.ClassNotFoundExcetpion这个异常肯定都不陌生，这背后就涉及到了java技术体系中的类加载。Java的类加载机制是技术体系中比较核心的部分，虽然和大部分开发人员直接打交道不多，但是对其背后的机理有一定理解有助于排查程序中出现的类加载失败等技术问题，对理解java虚拟机的连接模型和java语言的动态性都有很大帮助。 二、Java类加载器2.1JVM三种预定义类型类加载器我们首先看一下JVM预定义的三种类型类加载器，当一个 JVM启动的时候，Java缺省开始使用如下三种类型类装入器： 启动（Bootstrap）类加载器：引导类装入器是用本地代码实现的类装入器，它负责将 &lt;Java_Runtime_Home&gt;/lib下面的核心类库或-Xbootclasspath选项指定的jar包加载到内存中。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 扩展（Extension）类加载器：扩展类加载器是由Sun的ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt; Java_Runtime_Home &gt;/lib/ext或者由系统变量-Djava.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 系统（System）类加载器：系统类加载器是由 Sun的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径java -classpath或-Djava.class.path变量所指的目录下的类库加载到内存中。开发者可以直接使用系统类加载器。 除了以上列举的三种类加载器，还有一种比较特殊的类型就是线程上下文类加载器，这个将在后面单独介绍。 2.2 类加载双亲委派机制 在这里，需要着重说明的是，JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。关于虚拟机默认的双亲委派机制，我们可以从系统类加载器和扩展类加载器为例作简单分析。 图一 标准扩展类加载器继承层次图 图二 系统类加载器继承层次图 通过图一和图二我们可以看出，类加载器均是继承自java.lang.ClassLoader抽象类。我们下面我们就看简要介绍一下java.lang.ClassLoader中几个最重要的方法： //加载指定名称（包括包名）的二进制类型，供用户调用的接口 public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException{ … } //加载指定名称（包括包名）的二进制类型，同时指定是否解析（但是这里的resolve参数不一定真正能达到解析的效果），供继承用 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException{ … } //findClass方法一般被loadClass方法调用去加载指定名称类，供继承用 protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { … } //定义类型，一般在findClass方法中读取到对应字节码后调用，可以看出不可继承 //（说明：JVM已经实现了对应的具体功能，解析对应的字节码，产生对应的内部数据结构放置到方法区，所以无需覆写，直接调用就可以了） protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError{ … } 通过进一步分析标准扩展类加载器（sun.misc.Launcher$ExtClassLoader）和系统类加载器（sun.misc.Launcher$AppClassLoader）的代码以及其公共父类（java.net.URLClassLoader和java.security.SecureClassLoader）的代码可以看出，都没有覆写java.lang.ClassLoader中默认的加载委派规则—loadClass（…）方法。既然这样，我们就可以通过分析java.lang.ClassLoader中的loadClass（String name）方法的代码就可以分析出虚拟机默认采用的双亲委派机制到底是什么模样： public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return loadClass(name, false); } protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先判断该类型是否已经被加载 Class c = findLoadedClass(name); if (c == null) { //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载 try { if (parent != null) { //如果存在父类加载器，就委派给父类加载器加载 c = parent.loadClass(name, false); } else { //如果不存在父类加载器，就检查是否是由启动类加载器加载的类， //通过调用本地方法native findBootstrapClass0(String name) c = findBootstrapClass0(name); } } catch (ClassNotFoundException e) { // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; } 通过上面的代码分析，我们可以对JVM采用的双亲委派类加载机制有了更感性的认识，下面我们就接着分析一下启动类加载器、标准扩展类加载器和系统类加载器三者之间的关系。可能大家已经从各种资料上面看到了如下类似的一幅图片： 图三 类加载器默认委派关系图 上面图片给人的直观印象是系统类加载器的父类加载器是标准扩展类加载器，标准扩展类加载器的父类加载器是启动类加载器，下面我们就用代码具体测试一下： public class LoaderTest { public static void main(String[] args) { try { System.out.println(ClassLoader.getSystemClassLoader()); System.out.println(ClassLoader.getSystemClassLoader().getParent()); System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent()); } catch (Exception e) { e.printStackTrace(); } } } 说明：通过java.lang.ClassLoader.getSystemClassLoader()可以直接获取到系统类加载器。 代码输出如下： sun.misc.Launcher$AppClassLoader@6d06d69csun.misc.Launcher$ExtClassLoader@70dea4enull 通过以上的代码输出，我们可以判定系统类加载器的父加载器是标准扩展类加载器，但是我们试图获取标准扩展类加载器的父类加载器时确得到了null，就是说标准扩展类加载器本身强制设定父类加载器为null。我们还是借助于代码分析一下。 我们首先看一下java.lang.ClassLoader抽象类中默认实现的两个构造函数： protected ClassLoader() { SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkCreateClassLoader(); } //默认将父类加载器设置为系统类加载器，getSystemClassLoader()获取系统类加载器 this.parent = getSystemClassLoader(); initialized = true; } protected ClassLoader(ClassLoader parent) { SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkCreateClassLoader(); } //强制设置父类加载器 this.parent = parent; initialized = true; } 我们再看一下ClassLoader抽象类中parent成员的声明： // The parent class loader for delegation private ClassLoader parent; 声明为私有变量的同时并没有对外提供可供派生类访问的public或者protected设置器接口（对应的setter方法），结合前面的测试代码的输出，我们可以推断出： 系统类加载器（AppClassLoader）调用ClassLoader(ClassLoader parent)构造函数将父类加载器设置为标准扩展类加载器(ExtClassLoader)。（因为如果不强制设置，默认会通过调用getSystemClassLoader()方法获取并设置成系统类加载器，这显然和测试输出结果不符。） 扩展类加载器（ExtClassLoader）调用ClassLoader(ClassLoader parent)构造函数将父类加载器设置为null。（因为如果不强制设置，默认会通过调用getSystemClassLoader()方法获取并设置成系统类加载器，这显然和测试输出结果不符。） 现在我们可能会有这样的疑问：扩展类加载器（ExtClassLoader）的父类加载器被强制设置为null了，那么扩展类加载器为什么还能将加载任务委派给启动类加载器呢？ 图四 标准扩展类加载器和系统类加载器成员大纲视图 图五 扩展类加载器和系统类加载器公共父类成员大纲视图 通过图四和图五可以看出，标准扩展类加载器和系统类加载器及其父类（java.NET.URLClassLoader和java.security.SecureClassLoader）都没有覆写java.lang.ClassLoader中默认的加载委派规则—loadClass（…）方法。有关java.lang.ClassLoader中默认的加载委派规则前面已经分析过，如果父加载器为null，则会调用本地方法进行启动类加载尝试。所以，图三中，启动类加载器、标准扩展类加载器和系统类加载器之间的委派关系事实上是仍就成立的。（在后面的用户自定义类加载器部分，还会做更深入的分析）。 2.3 类加载双亲委派示例以上已经简要介绍了虚拟机默认使用的启动类加载器、标准扩展类加载器和系统类加载器，并以三者为例结合JDK代码对JVM默认使用的双亲委派类加载机制做了分析。下面我们就来看一个综合的例子。首先在IDE中建立一个简单的java应用工程，然后写一个简单的JavaBean如下： package classloader.test.bean; public class TestBean { public TestBean() { } } 在现有当前工程中另外建立一测试类（ClassLoaderTest.java）内容如下： 测试一： package classloader.test.bean; public class ClassLoaderTest { public static void main(String[] args) { try { //查看当前系统类路径中包含的路径条目 System.out.println(System.getProperty(&quot;java.class.path&quot;)); //调用加载当前类的类加载器（这里即为系统类加载器）加载TestBean Class typeLoaded = Class.forName(&quot;classloader.test.bean.TestBean&quot;); //查看被加载的TestBean类型是被那个类加载器加载的 System.out.println(typeLoaded.getClassLoader()); } catch (Exception e) { e.printStackTrace(); } } } 对应的输出如下： C:\\Users\\JackZhou\\Documents\\NetBeansProjects\\ClassLoaderTest\\build\\classessun.misc.Launcher$AppClassLoader@73d16e93 说明：当前类路径默认的含有的一个条目就是工程的输出目录。 测试二： 将当前工程输出目录下的TestBean.class打包进test.jar剪贴到&lt;Java_Runtime_Home&gt;/lib/ext目录下（现在工程输出目录下和JRE扩展目录下都有待加载类型的class文件）。再运行测试一测试代码，结果如下： C:\\Users\\JackZhou\\Documents\\NetBeansProjects\\ClassLoaderTest\\build\\classessun.misc.Launcher$ExtClassLoader@15db9742 对比测试一和测试二，我们明显可以验证前面说的双亲委派机制，系统类加载器在接到加载classloader.test.bean.TestBean类型的请求时，首先将请求委派给父类加载器（标准扩展类加载器），标准扩展类加载器抢先完成了加载请求。 测试三： 将test.jar拷贝一份到&lt;Java_Runtime_Home&gt;/lib下，运行测试代码，输出如下： C:\\Users\\JackZhou\\Documents\\NetBeansProjects\\ClassLoaderTest\\build\\classessun.misc.Launcher$ExtClassLoader@15db9742 测试三和测试二输出结果一致。那就是说，放置到·&lt;Java_Runtime_Home&gt;/lib·目录下的·TestBean·对应的class字节码并没有被加载，这其实和前面讲的双亲委派机制并不矛盾。虚拟机出于安全等因素考虑，不会加载·&lt;Java_Runtime_Home&gt;/lib·存在的陌生类，开发者通过将要加载的非JDK自身的类放置到此目录下期待启动类加载器加载是不可能的。做个进一步验证，删除·&lt;Java_Runtime_Home&gt;/lib/ext·目录下和工程输出目录下的TestBean对应的class文件，然后再运行测试代码，则将会有·ClassNotFoundException·异常抛出。有关这个问题，大家可以在·java.lang.ClassLoader·中的·loadClass(String name, boolean resolve)·方法中设置相应断点运行测试三进行调试，会发现·findBootstrapClass0()·会抛出异常，然后在下面的findClass方法中被加载，当前运行的类加载器正是扩展类加载器（·sun.misc.Launcher$ExtClassLoader·），这一点可以通过JDT中变量视图查看验证。 三、java程序动态扩展方式Java的连接模型允许用户运行时扩展引用程序，既可以通过当前虚拟机中预定义的加载器加载编译时已知的类或者接口，又允许用户自行定义类装载器，在运行时动态扩展用户的程序。通过用户自定义的类装载器，你的程序可以装载在编译时并不知道或者尚未存在的类或者接口，并动态连接它们并进行有选择的解析。 运行时动态扩展java应用程序有如下两个途径： 3.1 调用java.lang.Class.forName(…)加载类这个方法其实在前面已经讨论过，在后面的问题2解答中说明了该方法调用会触发哪个类加载器开始加载任务。这里需要说明的是多参数版本的forName(…)方法： public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException 这里的initialize参数是很重要的。它表示在加载同时是否完成初始化的工作（说明：单参数版本的forName方法默认是完成初始化的）。有些场景下需要将initialize设置为true来强制加载同时完成初始化。例如典型的就是利用DriverManager进行JDBC驱动程序类注册的问题。因为每一个JDBC驱动程序类的静态初始化方法都用DriverManager注册驱动程序，这样才能被应用程序使用。这就要求驱动程序类必须被初始化，而不单单被加载。Class.forName的一个很常见的用法就是在加载数据库驱动的时候。如 Class.forName(“org.apache.derby.jdbc.EmbeddedDriver”).newInstance()用来加载 Apache Derby 数据库的驱动。 3.2 用户自定义类加载器通过前面的分析，我们可以看出，除了和本地实现密切相关的启动类加载器之外，包括标准扩展类加载器和系统类加载器在内的所有其他类加载器我们都可以当做自定义类加载器来对待，唯一区别是是否被虚拟机默认使用。前面的内容中已经对java.lang.ClassLoader抽象类中的几个重要的方法做了介绍，这里就简要叙述一下一般用户自定义类加载器的工作流程吧（可以结合后面问题解答一起看）： 首先检查请求的类型是否已经被这个类装载器装载到命名空间中了，如果已经装载，直接返回；否则转入步骤2； 委派类加载请求给父类加载器（更准确的说应该是双亲类加载器，真实虚拟机中各种类加载器最终会呈现树状结构），如果父类加载器能够完成，则返回父类加载器加载的Class实例；否则转入步骤3； 调用本类加载器的findClass（…）方法，试图获取对应的字节码，如果获取的到，则调用defineClass（…）导入类型到方法区；如果获取不到对应的字节码或者其他原因失败，返回异常给loadClass（…）， loadClass（…）转而抛异常，终止加载过程（注意：这里的异常种类不止一种）。 说明：这里说的自定义类加载器是指JDK 1.2以后版本的写法，即不覆写改变java.lang.loadClass(…)已有委派逻辑情况下。 整个加载类的过程如下图： 图六 自定义类加载器加载类的过程 四、常见问题分析4.1 由不同的类加载器加载的指定类还是相同的类型吗？ 在Java中，一个类用其完全匹配类名(fully qualified class name)作为标识，这里指的完全匹配类名包括包名和类名。但在JVM中一个类用其全名和一个加载类ClassLoader的实例作为唯一标识，不同类加载器加载的类将被置于不同的命名空间。我们可以用两个自定义类加载器去加载某自定义类型（注意不要将自定义类型的字节码放置到系统路径或者扩展路径中，否则会被系统类加载器或扩展类加载器抢先加载），然后用获取到的两个Class实例进行java.lang.Object.equals（…）判断，将会得到不相等的结果。这个大家可以写两个自定义的类加载器去加载相同的自定义类型，然后做个判断；同时，可以测试加载java.*类型，然后再对比测试一下测试结果。 4.2 在代码中直接调用Class.forName(String name)方法，到底会触发那个类加载器进行类加载行为？ Class.forName(String name)默认会使用调用类的类加载器来进行类加载。我们直接来分析一下对应的jdk的代码： //java.lang.Class.java publicstatic Class&lt;?&gt; forName(String className) throws ClassNotFoundException { return forName0(className, true, ClassLoader.getCallerClassLoader()); } //java.lang.ClassLoader.java // Returns the invoker&#39;s class loader, or null if none. static ClassLoader getCallerClassLoader() { // 获取调用类（caller）的类型 Class caller = Reflection.getCallerClass(3); // This can be null if the VM is requesting it if (caller == null) { return null; } // 调用java.lang.Class中本地方法获取加载该调用类（caller）的ClassLoader return caller.getClassLoader0(); } //java.lang.Class.java //虚拟机本地实现，获取当前类的类加载器，前面介绍的Class的getClassLoader()也使用此方法 native ClassLoader getClassLoader0(); 4.3 在编写自定义类加载器时，如果没有设定父加载器，那么父加载器是谁？ 前面讲过，在不指定父类加载器的情况下，默认采用系统类加载器。可能有人觉得不明白，现在我们来看一下JDK对应的代码实现。众所周知，我们编写自定义的类加载器直接或者间接继承自java.lang.ClassLoader抽象类，对应的无参默认构造函数实现如下： //摘自java.lang.ClassLoader.java protected ClassLoader() { SecurityManager security = System.getSecurityManager(); if (security != null) { security.checkCreateClassLoader(); } this.parent = getSystemClassLoader(); initialized = true; } 我们再来看一下对应的getSystemClassLoader()方法的实现： private static synchronized void initSystemClassLoader() { //... sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); scl = l.getClassLoader(); //... } 我们可以写简单的测试代码来测试一下： System.out.println(sun.misc.Launcher.getLauncher().getClassLoader()); 本机对应输出如下：sun.misc.Launcher$AppClassLoader@73d16e93 所以，我们现在可以相信当自定义类加载器没有指定父类加载器的情况下，默认的父类加载器即为系统类加载器。同时，我们可以得出如下结论：即使用户自定义类加载器不指定父类加载器，那么，同样可以加载如下三个地方的类： &lt;Java_Runtime_Home&gt;/lib下的类； &lt; Java_Runtime_Home &gt;/lib/ext下或者由系统变量java.ext.dir指定位置中的类； 当前工程类路径下或者由系统变量java.class.path指定位置中的类。 4.4 在编写自定义类加载器时，如果将父类加载器强制设置为null，那么会有什么影响？如果自定义的类加载器不能加载指定类，就肯定会加载失败吗？ JVM规范中规定如果用户自定义的类加载器将父类加载器强制设置为null，那么会自动将启动类加载器设置为当前用户自定义类加载器的父类加载器（这个问题前面已经分析过了）。同时，我们可以得出如下结论：即使用户自定义类加载器不指定父类加载器，那么，同样可以加载到&lt;Java_Runtime_Home&gt;/lib下的类，但此时就不能够加载&lt;Java_Runtime_Home&gt;/lib/ext目录下的类了。 说明：问题3和问题4的推断结论是基于用户自定义的类加载器本身延续了java.lang.ClassLoader.loadClass（…）默认委派逻辑，如果用户对这一默认委派逻辑进行了改变，以上推断结论就不一定成立了，详见问题5。 4.5 编写自定义类加载器时，一般有哪些注意点？ 一般尽量不要覆写已有的loadClass(…)方法中的委派逻辑 一般在JDK 1.2之前的版本才这样做，而且事实证明，这样做极有可能引起系统默认的类加载器不能正常工作。在JVM规范和JDK文档中（1.2或者以后版本中），都没有建议用户覆写loadClass(…)方法，相比而言，明确提示开发者在开发自定义的类加载器时覆写findClass(…)逻辑。举一个例子来验证该问题： //用户自定义类加载器WrongClassLoader.Java（覆写loadClass逻辑） public class WrongClassLoader extends ClassLoader { public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { return this.findClass(name); } protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { // 假设此处只是到工程以外的特定目录D:\\library下去加载类 // 具体实现代码省略 } } 通过前面的分析我们已经知道，这个自定义类加载器WrongClassLoader的默认类加载器是系统类加载器，但是现在问题4种的结论就不成立了。大家可以简单测试一下，现在&lt;Java_Runtime_Home&gt;/lib、&lt; Java_Runtime_Home &gt;/lib/ext和工程类路径上的类都加载不上了。 //问题5测试代码一 public class WrongClassLoaderTest { publicstaticvoid main(String[] args) { try { WrongClassLoader loader = new WrongClassLoader(); Class classLoaded = loader.loadClass(&quot;beans.Account&quot;); System.out.println(classLoaded.getName()); System.out.println(classLoaded.getClassLoader()); } catch (Exception e) { e.printStackTrace(); } } } 这里D:&quot;classes&quot;beans&quot;Account.class是物理存在的。输出结果： java.io.FileNotFoundException: D:&quot;classes&quot;java&quot;lang&quot;Object.class (系统找不到指定的路径。) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at WrongClassLoader.findClass(WrongClassLoader.java:40) at WrongClassLoader.loadClass(WrongClassLoader.java:29) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at java.lang.ClassLoader.defineClass(ClassLoader.java:400) at WrongClassLoader.findClass(WrongClassLoader.java:43) at WrongClassLoader.loadClass(WrongClassLoader.java:29) at WrongClassLoaderTest.main(WrongClassLoaderTest.java:27) Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: java/lang/Object at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at java.lang.ClassLoader.defineClass(ClassLoader.java:400) at WrongClassLoader.findClass(WrongClassLoader.java:43) at WrongClassLoader.loadClass(WrongClassLoader.java:29) at WrongClassLoaderTest.main(WrongClassLoaderTest.java:27) 这说明，连要加载的类型的超类型java.lang.Object都加载不到了。这里列举的由于覆写loadClass()引起的逻辑错误明显是比较简单的，实际引起的逻辑错误可能复杂的多。 //问题5测试二 //用户自定义类加载器WrongClassLoader.Java(不覆写loadClass逻辑) public class WrongClassLoader extends ClassLoader { protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { //假设此处只是到工程以外的特定目录D:\\library下去加载类 //具体实现代码省略 } } 将自定义类加载器代码WrongClassLoader.Java做以上修改后，再运行测试代码，输出结果如下：beans.AccountWrongClassLoader@1c78e57 正确设置父类加载器通过上面问题4和问题5的分析我们应该已经理解，个人觉得这是自定义用户类加载器时最重要的一点，但常常被忽略或者轻易带过。有了前面JDK代码的分析作为基础，我想现在大家都可以随便举出例子了。 保证findClass(String name)方法的逻辑正确性事先尽量准确理解待定义的类加载器要完成的加载任务，确保最大程度上能够获取到对应的字节码内容。 4.6 如何在运行时判断系统类加载器能加载哪些路径下的类？ 一是可以直接调用ClassLoader.getSystemClassLoader()或者其他方式获取到系统类加载器（系统类加载器和扩展类加载器本身都派生自URLClassLoader），调用URLClassLoader中的getURLs()方法可以获取到。 二是可以直接通过获取系统属性java.class.path来查看当前类路径上的条目信息 ：System.getProperty(“java.class.path”)。 4.7 如何在运行时判断标准扩展类加载器能加载哪些路径下的类？方法之一： import java.net.URL; import java.net.URLClassLoader; public class ClassLoaderTest { /** * @param args the command line arguments */ public static void main(String[] args) { try { URL[] extURLs = ((URLClassLoader) ClassLoader.getSystemClassLoader().getParent()).getURLs(); for (int i = 0; i &lt; extURLs.length; i++) { System.out.println(extURLs[i]); } } catch (Exception e) { //… } } } 本机对应输出如下： file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/access-bridge-64.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/cldrdata.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/dnsns.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/jaccess.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/jfxrt.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/localedata.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/nashorn.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunec.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunjce_provider.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunmscapi.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/sunpkcs11.jar file:/C:/Program%20Files/Java/jdk1.8.0_05/jre/lib/ext/zipfs.jar 五、开发自己的类加载器在前面介绍类加载器的代理委派模式的时候，提到过类加载器会首先代理给其它类加载器来尝试加载某个类。这就意味着真正完成类的加载工作的类加载器和启动这个加载过程的类加载器，有可能不是同一个。真正完成类的加载工作是通过调用defineClass来实现的；而启动类的加载过程是通过调用loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在Java虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。 类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 在绝大多数情况下，系统默认提供的类加载器实现已经可以满足需求。但是在某些情况下，您还是需要为应用开发出自己的类加载器。比如您的应用通过网络来传输Java类的字节代码，为了保证安全性，这些字节代码经过了加密处理。这个时候您就需要自己的类加载器来从某个网络地址上读取加密后的字节代码，接着进行解密和验证，最后定义出要在Java虚拟机中运行的类来。下面将通过两个具体的实例来说明类加载器的开发。 5.1 文件系统类加载器第一个类加载器用来加载存储在文件系统上的Java字节代码。完整的实现如下所示。 package classloader; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; // 文件系统类加载器 public class FileSystemClassLoader extends ClassLoader { private String rootDir; public FileSystemClassLoader(String rootDir) { this.rootDir = rootDir; } // 获取类的字节码 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); // 获取类的字节数组 if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { // 读取类文件的字节 String path = classNameToPath(className); try { InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; // 读取类文件的字节码 while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { // 得到类文件的完全路径 return rootDir + File.separatorChar + className.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;; } } 如上所示，类 FileSystemClassLoader继承自类java.lang.ClassLoader。在java.lang.ClassLoader类的常用方法中，一般来说，自己开发的类加载器只需要覆写 findClass(String name)方法即可。java.lang.ClassLoader类的方法loadClass()封装了前面提到的代理模式的实现。该方法会首先调用findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。 类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。 加载本地文件系统上的类，示例如下： package com.example; public class Sample { private Sample instance; public void setSample(Object instance) { System.out.println(instance.toString()); this.instance = (Sample) instance; } } package classloader; import java.lang.reflect.Method; public class ClassIdentity { public static void main(String[] args) { new ClassIdentity().testClassIdentity(); } public void testClassIdentity() { String classDataRootPath = &quot;C:\\\\Users\\\\JackZhou\\\\Documents\\\\NetBeansProjects\\\\classloader\\\\build\\\\classes&quot;; FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); String className = &quot;com.example.Sample&quot;; try { Class&lt;?&gt; class1 = fscl1.loadClass(className); // 加载Sample类 Object obj1 = class1.newInstance(); // 创建对象 Class&lt;?&gt; class2 = fscl2.loadClass(className); Object obj2 = class2.newInstance(); Method setSampleMethod = class1.getMethod(&quot;setSample&quot;, java.lang.Object.class); setSampleMethod.invoke(obj1, obj2); } catch (Exception e) { e.printStackTrace(); } } } 运行输出： com.example.Sample@7852e922 5.2 网络类加载器下面将通过一个网络类加载器来说明如何通过类加载器来实现组件的动态更新。即基本的场景是：Java 字节代码（.class）文件存放在服务器上，客户端通过网络的方式获取字节代码并执行。当有版本更新的时候，只需要替换掉服务器上保存的文件即可。通过类加载器可以比较简单的实现这种需求。 类 NetworkClassLoader负责通过网络下载Java类字节代码并定义出Java类。它的实现与FileSystemClassLoader类似。 package classloader; import java.io.ByteArrayOutputStream; import java.io.InputStream; import java.net.URL; public class NetworkClassLoader extends ClassLoader { private String rootUrl; public NetworkClassLoader(String rootUrl) { // 指定URL this.rootUrl = rootUrl; } // 获取类的字节码 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { byte[] classData = getClassData(name); if (classData == null) { throw new ClassNotFoundException(); } else { return defineClass(name, classData, 0, classData.length); } } private byte[] getClassData(String className) { // 从网络上读取的类的字节 String path = classNameToPath(className); try { URL url = new URL(path); InputStream ins = url.openStream(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; // 读取类文件的字节 while ((bytesNumRead = ins.read(buffer)) != -1) { baos.write(buffer, 0, bytesNumRead); } return baos.toByteArray(); } catch (Exception e) { e.printStackTrace(); } return null; } private String classNameToPath(String className) { // 得到类文件的URL return rootUrl + &quot;/&quot; + className.replace(&#39;.&#39;, &#39;/&#39;) + &quot;.class&quot;; } } 在通过NetworkClassLoader加载了某个版本的类之后，一般有两种做法来使用它。第一种做法是使用Java反射API。另外一种做法是使用接口。需要注意的是，并不能直接在客户端代码中引用从服务器上下载的类，因为客户端代码的类加载器找不到这些类。使用Java反射API可以直接调用Java类的方法。而使用接口的做法则是把接口的类放在客户端中，从服务器上加载实现此接口的不同版本的类。在客户端通过相同的接口来使用这些实现类。我们使用接口的方式。示例如下： 客户端接口： package classloader; public interface Versioned { String getVersion(); } package classloader; public interface ICalculator extends Versioned { String calculate(String expression); } 网络上的不同版本的类： package com.example; import classloader.ICalculator; public class CalculatorBasic implements ICalculator { @Override public String calculate(String expression) { return expression; } @Override public String getVersion() { return &quot;1.0&quot;; } } package com.example; import classloader.ICalculator; public class CalculatorAdvanced implements ICalculator { @Override public String calculate(String expression) { return &quot;Result is &quot; + expression; } @Override public String getVersion() { return &quot;2.0&quot;; } } 在客户端加载网络上的类的过程： package classloader; public class CalculatorTest { public static void main(String[] args) { String url = &quot;http://localhost:8080/ClassloaderTest/classes&quot;; NetworkClassLoader ncl = new NetworkClassLoader(url); String basicClassName = &quot;com.example.CalculatorBasic&quot;; String advancedClassName = &quot;com.example.CalculatorAdvanced&quot;; try { Class&lt;?&gt; clazz = ncl.loadClass(basicClassName); // 加载一个版本的类 ICalculator calculator = (ICalculator) clazz.newInstance(); // 创建对象 System.out.println(calculator.getVersion()); clazz = ncl.loadClass(advancedClassName); // 加载另一个版本的类 calculator = (ICalculator) clazz.newInstance(); System.out.println(calculator.getVersion()); } catch (Exception e) { e.printStackTrace(); } } } 参考文献http://www.blogjava.net/zhuxing/archive/2008/08/08/220841.html http://www.ibm.com/developerworks/cn/java/j-lo-classloader/","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--虚拟机字节码执行引擎","slug":"深入理解JVM之--虚拟机字节码执行引擎","date":"2020-05-30T08:52:38.000Z","updated":"2023-04-30T10:21:41.374Z","comments":true,"path":"2020/05/30/深入理解JVM之--虚拟机字节码执行引擎/","link":"","permalink":"/2020/05/30/深入理解JVM之--虚拟机字节码执行引擎/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 知识点回顾：javac编译器通过对程序代码进行词法分析、语法分析、生成抽象语法树、遍历抽象语法树等复杂的编译过程，最终，将程序代码变成了Class字节码文件。然后，生成的Class字节码文件在经历过加载、验证、准备、解析、初始化等阶段之后才能被使用/卸载。 运行时栈帧结构栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。 栈帧存储了方法的局部变量表、 操作数栈、 动态连接和方法返回地址等信息。 每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。 一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。 对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current StackFrame），与这个栈帧相关联的方法称为当前方法（Current Method）。 执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图所示。 局部变量表局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。 在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。 局部变量表的容量以变量槽（Variable Slot，下称Slot）为最小单位，在基本数据类型中，64 位长度的long 和double 类型的数据会占用2 个连续局部变量空间（高位对齐），其余的数据类型只占用1 个。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问。 在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。 其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。 为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。在某些情况下，Slot的复用会影响垃圾收集器的行为，例如：被复用的Slot中所引用的变量在超出变量的作用域后，但该Slot空间还没有被其他变量所占用，会导致作为GC Roots一部分的局部变量表仍然保持着对旧变量的关联，进而导致旧变量无法被回收。 操作数栈操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out,LIFO）栈。 同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。 操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。 32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。 在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作，而且操作数栈中元素的数据类型必须与字节码指令的序列严格匹配。 举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。 动态连接每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。 Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。 这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。 另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 方法返回地址当一个方法开始执行后，只有两种方式可以退出这个方法。 第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。 一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。 方法调用方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。 Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于之前说的直接引用）。 这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。 解析所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 换句话说，调用目标在程序代码写好、 编译器进行编译时就必须确定下来。 这类方法的调用称为解析（Resolution）。 在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。 与之相对应的是，在Java虚拟机里面提供了5条方法调用字节码指令，分别如下。 invokestatic：调用静态方法。 invokespecial：调用实例构造器＜init＞方法、 私有方法和父类方法。 invokevirtual：调用所有的虚方法。 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，在此之前的4条调用指令，分派逻辑是固化在Java虚拟机内部的，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。 只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、 私有方法、 实例构造器、 父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。 这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除去final方法）。 Java中的非虚方法除了使用invokestatic、 invokespecial调用的方法之外还有一种，就是被final修饰的方法。 虽然final方法是使用invokevirtual指令来调用的，但是由于它无法被覆盖，没有其他版本，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。 解析调用一定是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。 分派静态分派Object obj=new String(); 形如上面这行代码，我们把代码中的“Object ”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“String”则称为变量的实际类型（Actual Type）。 静态类型和实际类型的区别在于：一个变量的静态类型是不会被改变的，并且其最终的静态类型是在编译期可知的；而实际类型变化的结果要到运行期才能确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。 虚拟机（准确地说是编译器）在重载方法选择时是通过参数的静态类型而不是实际类型作为判定依据的，我们把这种依赖静态类型来定位方法执行版本的分派动作称为静态分派。 /** * 方法静态分派演示 */ public class StaticDispatch { static abstract class Human { } static class Man extends Human { } static class Woman extends Human { } public void sayHello(Human guy) { System.out.println(&quot;hello,guy！&quot;); } public void sayHello(Man guy) { System.out.println(&quot;hello,gentleman！&quot;); } public void sayHello(Woman guy) { System.out.println(&quot;hello,lady！&quot;); } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); StaticDispatch sr = new StaticDispatch(); sr.sayHello(man); sr.sayHello(woman); } } 动态分派所有依赖实际类型来定位方法执行版本的分派动作称为动态分派，比较典型的一个体现就是重写（Override）。 /** * 方法动态分派演示 */ public class DynamicDispatch { static abstract class Human { protected abstract void sayHello(); } static class Man extends Human { @Override protected void sayHello() { System.out.println(&quot;man say hello&quot;); } } static class Woman extends Human { @Override protected void sayHello() { System.out.println(&quot;woman say hello&quot;); } } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); } } 单分派与多分派方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。 基于栈的解释器执行过程通过一段Java代码，看看在虚拟机中实际是如何执行的。 package com.pengjunlee; public class Test { public int calc() { int a = 100; int b = 200; int c = 300; return (a + b) * c; } } 使用javap命令看看它的字节码指令，如下图所示。 javap提示这段代码需要深度为2的操作数栈和4个Slot的局部变量空间，下面的7张图，用它们来描述代码执行过程中的指令、 操作数栈和局部变量表的变化情况。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--虚拟机类加载机制","slug":"深入理解JVM之--虚拟机类加载机制","date":"2020-05-30T08:51:38.000Z","updated":"2023-04-30T10:21:41.374Z","comments":true,"path":"2020/05/30/深入理解JVM之--虚拟机类加载机制/","link":"","permalink":"/2020/05/30/深入理解JVM之--虚拟机类加载机制/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、 转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、 验证（Verification）、 准备（Preparation）、 解析（Resolution）、 初始化（Initialization）、 使用（Using）和卸载（Unloading）7个阶段。 其中验证、 准备、 解析3个部分统称为连接（Linking），这7个阶段的发生顺序如下图。 Java虚拟机规范中并没有明确指明在什么情况下需要加载（Loading）类，各个虚拟机可自由把握。 但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、 验证、 准备自然需要在此之前开始）： 遇到new、 getstatic、 putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。 生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、 读取或设置一个类的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、 REF_putStatic、 REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。 对于这5种会触发类进行初始化的场景，虚拟机规范中使用了一个很强烈的限定语：“有且只有”，这5种场景中的行为称为对一个类进行主动引用。 除此之外，所有引用类的方式都不会触发初始化，称为被动引用。 以下是三个被动引用的代码示例。 /** * 被动使用类字段演示一： 通过子类引用父类的静态字段，不会导致子类初始化 **/ public class SuperClass { static { System.out.println(&quot;SuperClass init！&quot;); } public static int value = 123; } public class SubClass extends SuperClass { static { System.out.println(&quot;SubClass init！&quot;); } } public class NotInitialization { public static void main(String[] args) { System.out.println(SubClass.value); } } 执行结果： /** * 被动使用类字段演示二： 通过数组定义来引用类，不会触发此类的初始化 **/ public class NotInitialization { public static void main(String[] args) { SuperClass[] sca = new SuperClass[10]; } } 执行结果：未执行SuperClass的类初始化，即未打印任何文字。 /** * 被动使用类字段演示三： 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 **/ public class ConstantClass { static{ System.out.println(&quot;ConstClass init！&quot;); } public static final String HELLOWORLD=&quot;hello world&quot;; } /** * 非主动使用字段演示 **/ public class NotInitialization { public static void main(String[] args) { System.out.println(ConstantClass.HELLOWORLD); } } 执行结果： 类加载的过程加载在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。 然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。 加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 从整体上来看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、 字节码验证、 符号引用验证。 文件格式验证第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 元数据验证第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。 字节码验证第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、 符合逻辑的。 符号引用验证最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。 准备准备阶段是正式为类变量分配内存并设置类变量初始值（“通常情况”下是数据类型的零值）的阶段，这些变量所使用的内存都将在方法区中进行分配。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。 各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用（Direct References）：直接引用可以是直接指向目标的指针、 相对偏移量或是一个能间接定位到目标的句柄。 直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。 如果有了直接引用，那引用的目标必定已经在内存中存在。 虚拟机规范之中并未规定解析阶段发生的具体时间，只要求了在执行anewarray、checkcast、 getfield、 getstatic、 instanceof、 invokedynamic、 invokeinterface、 invokespecial、invokestatic、 invokevirtual、 ldc、 ldc_w、 multianewarray、 new、 putfield和putstatic这16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。 除invokedynamic指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。 初始化类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。 到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。 在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器＜clinit＞（）方法的过程。 ＜clinit＞（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如以下代码所示。 public class Test { static { i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示&quot;非法向前引用&quot; } static int i = 1; } ＜clinit＞（）方法与类的构造函数（或者说实例构造器＜init＞（）方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的＜clinit＞（）方法执行之前，父类的＜clinit＞（）方法已经执行完毕。 因此在虚拟机中第一个被执行的＜clinit＞（）方法的类肯定是java.lang.Object。 ＜clinit＞（）方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成＜clinit＞（）方法。 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成＜clinit＞（）方法。 但接口与类不同的是，执行接口的＜clinit＞（）方法不需要先执行父接口的＜clinit＞（）方法。 只有当父接口中定义的变量使用时，父接口才会初始化。 另外，接口的实现类在初始化时也一样不会执行接口的＜clinit＞（）方法。 虚拟机会保证一个类的＜clinit＞（）方法在多线程环境中被正确地加锁、 同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的＜clinit＞（）方法，其他线程都需要阻塞等待，直到活动线程执行＜clinit＞（）方法完毕。 类加载器虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。 实现这个动作的代码模块称为“类加载器”。 类与类加载器类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。 这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。 import java.io.IOException; import java.io.InputStream; import com.pengjunlee.MyClass; /** * 类加载器与instanceof关键字演示 */ public class ClassLoaderTest { public static void main(String[] args) { ClassLoader myLoader = new ClassLoader() { public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException { try { String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1) + &quot;.class&quot;; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) { return super.loadClass(name); } byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); } catch (IOException e) { throw new ClassNotFoundException(name); } } }; try { Object obj = myLoader.loadClass(&quot;jvm.ClassLoaderTest&quot;) .newInstance(); System.out.println(obj.getClass()); System.out.println(obj instanceof jvm.ClassLoaderTest); System.out.println(obj.getClass().getClassLoader().getClass()); System.out.println(jvm.ClassLoaderTest.class.getClassLoader() .getClass()); } catch (Exception e) { e.printStackTrace(); } } } 执行结果： 双亲委派模型从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。 启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。 启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher $AppClassLoader实现。 由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。 它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。 这些类加载器之间的关系一般如图所示。 图中展示的类加载器之间的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。 双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 java.lang.ClassLoader的loadClass（）方法之中实现双亲委派的相关代码如下。 protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { //首先，检查请求的类是否已经被加载过了 Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //如果父类加载器抛出ClassNotFoundException //说明父类加载器无法完成加载请求 } if (c == null) { //在父类加载器无法加载的时候 //再调用本身的findClass方法来进行类加载 c = findClass(name); } } if (resolve) { resolveClass(c); } return c; }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--性能监控与故障诊断","slug":"深入理解JVM之--性能监控与故障诊断","date":"2020-05-30T08:50:38.000Z","updated":"2023-04-30T10:21:41.372Z","comments":true,"path":"2020/05/30/深入理解JVM之--性能监控与故障诊断/","link":"","permalink":"/2020/05/30/深入理解JVM之--性能监控与故障诊断/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 SUN公司在JDK的bin目录中为Java开发人员提供的命令行工具，除了大家熟知的java.exe、javac.exe和javap.exe之外，还包含一些功能强大且稳定的虚拟机性能监控与故障处理工具，能在处理应用程序性能问题、 定位故障时发挥很大的作用，例如下面这几个。 还是先来看看它们都是干什么用的吧，稍后再对各个工具的作用及用法进行详细介绍。 jps：查看虚拟机进程状况jps（JVM Process Status Tool）的作用是：列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class,main（）函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier,LVMID），对于本地虚拟机进程来说，LVMID与操作系统的进程ID（Process Identifier,PID）是一致的。 # jps 命令格式： jps [options] [hostid] jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。 jps的其他常用选项见下表。 jps执行样例： 在Eclipse IDE中将main()方法传入参数及JVM启动参数进行如下设置，并执行自定义类jvm.JpsTest中的main()方法。 使用命令 jps -mlv 查看所有的JVM进程、main()方法传入参数、JVM启动参数，并显示类的包全名。 jstat：监视虚拟机运行状态jstat（JVM Statistics Monitoring Tool）是用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程虚拟机进程中的类装载、 内存、 垃圾收集、 JIT编译等运行数据，在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。 # jstat 命令格式为： jstat [ option vmid [ interval[s|ms] [count]] ] 对于命令格式中的VMID与LVMID需要特别说明一下：如果是本地虚拟机进程，VMID与LVMID是一致的，如果是远程虚拟机进程，那VMID的格式应当是：[protocol：][//]lvmid[@hostname[：port]/servername] 参数interval和count代表查询间隔和次数，如果省略这两个参数，说明只查询一次。 假设需要每250毫秒查询一次进程2764垃圾收集状况，一共查询20次，那命令应当是：jstat -gc 2764 250 20 选项option代表着用户希望查询的虚拟机信息，主要分为3类：类装载、 垃圾收集、 运行期编译状况，具体选项及作用如下表。 jstat执行样例： 我们以监视Java堆的状况为例，使用命令：jstat -gcutil [进程ID] 监视结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了6.01%的空间，两个Survivor区（S0、 S1，表示Survivor0、 Survivor1）里面都是空的，老年代（O，表示Old）和永久代（P，表示Permanent）则分别使用了1.88%和14.28%的空间。 程序运行以来共发生Minor GC（YGC，表示Young GC）14次，总耗时0.037秒，发生Full GC（FGC，表示FullGC）0次，Full GC总耗时（FGCT，表示Full GC Time）为0.000秒，所有GC总耗时（GCT，表示GC Time）为0.037秒。 jinfo：管理JVM配置信息jinfo（Configuration Info for Java）的作用是实时地查看和调整虚拟机各项参数。 # jinfo 命令格式： jinfo [option] pid 选项option的基本用法如下表。 jinfo执行样例： jmap：Java内存映像工具jmap（Memory Map for Java）命令用于生成堆转储快照（一般称为heapdump或dump文件） # jmap 命令格式： jmap [option] vmid 具体选项及作用如下表。 jmap执行样例：生成一个正在执行的eclipse进程的dump快照文件。 使用 clstats 参数，以ClassLoader为统计口径显示永久代内存状态 jhat：JVM快照分析工具Sun JDK提供jhat（JVM Heap Analysis Tool）命令与jmap搭配使用，来分析jmap生成的堆转储快照。 jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，可以在浏览器中查看。 jhat执行样例：使用jhat分析上例中采用jmap生成的Eclipse IDE的内存快照文件。 屏幕显示“Server is ready.”的提示后，用户在浏览器中键入http://localhost：7000/就可以看到分析结果，分析结果默认是以包为单位进行分组显示，如下图所示。 jstack：Java堆栈跟踪工具jstack（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、 死循环、 请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者等待着什么资源。 # jstack 命令格式： jstack [option] vmid option选项的合法值与具体含义下表。 jstack执行样例：使用jstack查看一个java线程的堆栈。 在JDK 1.5中，java.lang.Thread类新增了一个getAllStackTraces（）方法用于获取虚拟机中所有线程的StackTraceElement对象。 import java.util.Map; public class JstackTrace { public void printThreadTrace() { for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread .getAllStackTraces().entrySet()) { Thread thread = (Thread) stackTrace.getKey(); StackTraceElement[] stack = (StackTraceElement[]) stackTrace .getValue(); if (thread.equals(Thread.currentThread())) { continue; } System.out.print(&quot;\\n线程:&quot; + thread.getName() + &quot;\\n&quot;); for (StackTraceElement element : stack) { System.out.print(&quot;\\t&quot; + element + &quot;\\n&quot;); } } } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--Java内存模型与线程","slug":"深入理解JVM之--Java内存模型与线程","date":"2020-05-30T08:49:38.000Z","updated":"2023-04-30T10:21:41.369Z","comments":true,"path":"2020/05/30/深入理解JVM之--Java内存模型与线程/","link":"","permalink":"/2020/05/30/深入理解JVM之--Java内存模型与线程/","excerpt":"","text":"参考书籍：《Java特种兵（上册）》 硬件的效率与一致性众所周知，现代计算机的运算速度已经远高于它的存储和通信子系统的速度，并且计算机中绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个I/O操作是很难消除的（无法仅靠寄存器来完成所有运算任务），这就意味着，计算机在执行运算任务时，大量的时间都会花费在等待磁盘I/O、网络通信或者数据库访问上，这会对处理器的运算能力造成很大的浪费，一个有效的改善手段就是让计算机同时处理几项任务（即多线程技术），因此，多任务处理在现代计算机操作系统中几乎已是一项必备的功能了。 由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。 基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是也引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。 Java内存模型Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的并发效果。 Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。 Java内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存仅是虚拟机内存的一部分），每条线程还有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对所有变量的操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下图。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外）。 lock（锁定）：作用于主内存的变量，它把主内存该变量标识为一条线程独占的状态。 unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 assgin（赋值）：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。 Store（存储）：作用于工作内存中的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 的write操作使用。 Write（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，那就要按顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要按顺序的执行store和write操作。这两个操作必须按顺序执行，而没有保证是连续执行，也就是说read与load之间、store与write之间是可插入其他指令的。除此之外，Java内存模型还规定了在执行上述八种基本操作时必须满足如下规则： 不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，就是对一个变量执行use和store之前必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。 这8种内存访问操作以及上述规定限定，再加上稍后介绍的对volatile的一些特殊规定，就已经完全确定了Java程序中哪些内存访问操作在并发下是安全的。 对于volatile型变量的特殊规则关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有的“可见性”，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 变量不需要与其他的状态变量共同参与不变约束。 下类场景很适合使用volatile变量来控制并发，当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下来。 volatile boolean shutdownRequested; public void shutdown(){ shutdownRequested=true; } public void doWork(){ while(!shutdownRequested){ //do stuff } } 使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 下面是Java内存模型中对volatile变量定义的特殊规则。假定T表示一个线程，V和W分别表示两个volatile变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则： 只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联，必须连续一起出现（这条规则要求在工作内存中，每次使用volatile变量前都必须从主内存中刷新最新的值，用于保证能看到其他线程对变量V所做的修改后的值）。 只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign操作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联，必须连续一起出席（这条规则要求在工作内存中，每次修改后的值都必须立刻同步回主内存中，用于保证其他线程可以看到自己对变量V所做的修改）。 假定动作A是线程T对变量V实施的use或assign动作，假定动作F是和动作A相关联的load或store动作，假定动作P是和动作F相应的对变量V的read或write动作；类似的，假定动作B是线程T对变量W实施的use或assign动作，假定动作G是和动作B相关联的load或store动作，假定动作Q是和动作G相应的对变量W的read或write动作，如果A先于B，那么P先于Q（这条规则要求volatile修饰的变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同）。 对于long和double型变量的特殊规则Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这四个操作的原子性，这点就是所谓的long和double的非原子性协定（Nonatomic Treatment of double and long Variables）。 注意：目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。 先行发生原则java语言中有一个先行发生（Happens-Before）原则，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。 先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意进行重排序。 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。 volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则（Thread Start Rule）：线程的Thread.start()必须在该线程所有其他操作之前发生。 线程终止规则（Thread Termination Rule）：线程中所有操作都先行发生于该线程的终止检测。我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那么就可以得出操作A先行发生于操作C的结论。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--Java对象的内存结构","slug":"深入理解JVM之--Java对象的内存结构","date":"2020-05-30T08:47:38.000Z","updated":"2023-04-30T10:21:41.369Z","comments":true,"path":"2020/05/30/深入理解JVM之--Java对象的内存结构/","link":"","permalink":"/2020/05/30/深入理解JVM之--Java对象的内存结构/","excerpt":"","text":"参考书籍：《Java特种兵（上册）》 对象内存结构Class文件以字节码的形式存储在方法区当中，用来描述一个类本身的内存结构。当使用Class文件新建对象时，对象实例的内存结构又究竟是个什么样子呢？ 如图所示，为了表示对象的属性、方法等信息，HotSpot VM使用对象头部的一个指针指向Class区域的方式来找到对象的Class描述，以及内部的方法、属性入口。除此之外，还在对象的头部划分了部分空间（Mark Word），用于描述与对象相关的其他信息，例如：是否加锁、GC标志位、Minor GC次数、对象默认的hashCode（System.identityHashCode(object)可获取对象的这个值）。 在32位系统下，存放Class指针的空间大小是4字节，Mark Word空间大小也是4字节，因此就是8字节的头部，如果是数组还需要增加4字节来表示数组的长度。 在64位系统及64位JVM下，开启指针压缩（参数是 -XX:+UseCompressedOops），那么头部存放Class指针的空间大小还是4字节，而Mark Word区域会变大，变成8字节，也就是头部最少为12字节。若未开启指针压缩，那么保存Class指针的空间大小也会变成8字节，那么对象头部会变成16字节。另外，在64位模式下，若未开启压缩，引用也会变成8字节。 此外，Java对象将以8字节对齐在内存中，也就是对象占用的空间不是8字节的倍数，将会被补齐为8字节的倍数，这样做的好处是，在对象分配和查找的过程中不用考虑过多的偏移量问题。 以下是在32位系统下一些常见对象占用的空间大小示例。 没有继承的对象属性排布在默认情况下，HotSpot VM会按照一个顺序排布对象的内部属性，这个顺序是，long/double–&gt;int/float–&gt;short/char–&gt;byte/boolean–&gt;Reference（与对象本身的属性顺序无关）。 有继承的对象属性排布在HotSpot VM中，有继承关系的对象在创建时，父类的属性会被分配到相应的对象中，由于父类的属性不能和子类混用，所以它们必须单独排布在一个地方，可以认为它们就是从上到下的一个顺序。以两重继承为例，对象继承属性排布规则如下图所示。 这里的对齐有两种：一是整个对象的8字节对齐；二是父类到子类的属性对齐。在32位及64位压缩模式下，会按照4字节对齐。 例如下面的例子： class A {byte b;}class B extends A {byte b;}class C extends B {byte b;} 如何计算对象大小有时，我们需要知道Java对象到底占用多少内存，有人通过连续调用两次System.gc()比较两次gc前后内存的使用量在计算java对象的大小，也有人根据Java虚拟机规范中的Java对象内存排列估算对象的大小，这两种方法或多或少都有问题，因为System.gc()并不一定促发GC，同一个类型的对象在32位与64位JVM中使用的内存会不一样，在64位虚拟机中是否开启指针压缩也会影响Java对象在内存中的大小。 那么有没有一种既准确又方便的方法计算对象的大小呢？答案是肯定的。在Java 5中引入了Instrumentation类，这个类提供了计算对象内存占用量的方法；Hotspot支持instrumentation框架，其他的虚拟机也提供了类似的框架。 使用Instrumentation类计算Java对象大小的过程如下： 创建一个含有premain()方法的Java 类。package sizeof; import java.lang.instrument.Instrumentation; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.IdentityHashMap; import java.util.Map; import java.util.Stack; public class DeepObjectSizeOf { private static Instrumentation inst; public static void premain(String agentArgs, Instrumentation instP) { inst = instP; } public static long sizeOf(Object object) { //计算当前对象的内存大小，不包含引用对象 return inst.getObjectSize(object); } public static long deepSizeOf(Object obj) {//深入检索对象，并计算大小 Map&lt;Object, Object&gt; visited = new IdentityHashMap&lt;Object, Object&gt;(); Stack&lt;Object&gt; stack = new Stack&lt;Object&gt;(); long result = internalSizeOf(obj, stack, visited); while (!stack.isEmpty()) {//通过栈进行遍历 result += internalSizeOf(stack.pop(), stack, visited); } visited.clear(); return result; } private static boolean needSkipObject(Object obj, Map&lt;Object, Object&gt; visited) { if (obj instanceof String) { if (obj == ((String) obj).intern()) { return true; } } return (obj == null) || visited.containsKey(obj); } private static long internalSizeOf(Object obj, Stack&lt;Object&gt; stack, Map&lt;Object, Object&gt; visited) { if (needSkipObject(obj, visited)) { return 0; } visited.put(obj, null);//将当前对象放入栈中 long result = 0; result += sizeOf(obj); Class &lt;?&gt;clazz = obj.getClass(); if (clazz.isArray()) {//如果数组 if(clazz.getName().length() != 2) {//如果primitive type array，Class的name为2位 int length = Array.getLength(obj); for (int i = 0; i &lt; length; i++) { stack.add(Array.get(obj, i)); } } return result; } return getNodeSize(clazz , result , obj , stack); } //这个方法获取非数组对象自身的大小，并且可以向父类进行向上搜索 private static long getNodeSize(Class &lt;?&gt;clazz , long result , Object obj , Stack&lt;Object&gt; stack) { while (clazz != null) { Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) { if (!Modifier.isStatic(field.getModifiers())) {//这里抛开静态属性 if (field.getType().isPrimitive()) {//这里抛开基本关键字（因为基本关键字在调用java默认提供的方法就已经计算过了） continue; }else { field.setAccessible(true); try { Object objectToAdd = field.get(obj); if (objectToAdd != null) { stack.add(objectToAdd);//将对象放入栈中，一遍弹出后继续检索 } } catch (IllegalAccessException ex) { assert false; } } } } clazz = clazz.getSuperclass();//找父类class，直到没有父类 } return result; } } JVM会在应用程序运行之前调用这个Java 类的premain()方法（也就是在执行应用程序的main方法之前），JVM会在调用该方法时传入一个实现Instrumentation接口的实例，通过调用此接口实例的getObjectSize()方法可以计算出对象的大小（只计算当前对象的大小，不会进一步计算内部引用对象的大小）。 将创建好的Java类打成一个jar包在打包之前先创建一个MANIFEST.txt文件作为这个jar包的清单文件，其内容如下： Manifest-Version: 1.0 Premain-Class: sizeof.DeepObjectSizeOf 按照Java类文件的包路径创建好目录（DeepObjectSizeOf.class文件放在sizeof文件夹中）。 使用用如下命令创建jar包： jar -cmf MANIFEST.txt java_sizeof.jar sizeof/* 修改JVM启动配置修改Eclipse IDE的JVM启动配置，增加-javaagent启动参数： -javaagent:jar文件路径 我创建的 java_sizeof.jar放在D:\\sizeof目录下，设置参数如下。 测试样例创建一个测试类SizeOfMain.java，代码如下。 package sizeof; public class SizeOfMain { public static void main(String[] args) { System.out.println(&quot;new Integer(1) 对象大小：&quot; + DeepObjectSizeOf.deepSizeOf(new Integer(1))); System.out.println(&quot;new String(\\&quot;sizeof\\&quot;) 对象大小：&quot; + DeepObjectSizeOf.deepSizeOf(new String(&quot;sizeof&quot;))); } } 在64位机器上（不开启指针压缩）： 设置参数：-javaagent:d:\\sizeof/java_sizeof.jar -XX:-UseCompressedOops 执行结果： 在64位机器上（开启指针压缩）： 设置参数：-javaagent:d:\\sizeof/java_sizeof.jar -XX:+UseCompressedOops 执行结果：","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--垃圾收集器（下）","slug":"深入理解JVM之--垃圾收集器（下）","date":"2020-05-30T08:46:38.000Z","updated":"2023-04-30T10:21:41.372Z","comments":true,"path":"2020/05/30/深入理解JVM之--垃圾收集器（下）/","link":"","permalink":"/2020/05/30/深入理解JVM之--垃圾收集器（下）/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 在判定（可以通过引用计数算法或者根搜索算法）完哪些对象还活着，哪些对象可以被回收之后，GC究竟是如何进行垃圾回收的呢？ 垃圾收集算法标记-清除算法标记-清除（Mark-Sweep）算法是最基础的收集算法，如同它的名字一样，算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程其实就是通过引用计数算法或者根搜索算法来判断对象是否存活。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-清除算法的执行过程如下图所示。 复制算法为了解决效率问题，复制（Coping）算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把这块已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如下图所示。 标记-整理算法复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保（例如，在HotSpot虚拟中，如果Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代），以应对被使用的内存中所有对象都100%存活的极端情况，所以老年代一般不能直接选用复制收集算法。根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。这种方法既避免了内存碎片的产生，又不会像复制算法那样浪费过多的内存空间。 标记-整理算法示意图如下图所示。 分代收集算法当前商业虚拟机的垃圾收集都采用分代收集（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。 一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。 而老年代中因为对象存活率高、 没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、 不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。在此我们对基于JDK 1.7 Update 14之后的HotSpot虚拟机的垃圾收集器进行说明，这个虚拟机包含的所有收集器如下图所示。 图中展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。 虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。 Serial收集器Serial收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束，有点类似“Stop The World”。下图示意了Serial/Serial Old收集器的运行过程。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX：SurvivorRatio、 -XX：PretenureSizeThreshold、 -XX：HandlePromotionFailure等）、 收集算法、 Stop The World、 对象分配规则、 回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 ParNew收集器的工作过程如下图所示。 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。 Parallel Scavenge收集器Parallel Scavenge收集器与ParNew收集器存在很多相似之处，例如：新生代收集器，复制算法、并行的多线程收集器。同其它的收集器相比，Parallel Scavenge收集器的与众不同之处在于，它的运行目标是使系统达到一个可控制的吞吐量（Throughput）。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 CMS等收集器的目标是尽可能地缩短垃圾收集时用户线程的停顿时间，停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。 Serial Old收集器Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。 这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。 Serial Old收集器的工作过程如下图所示。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 Parallel Scavenge收集器和Parallel Old收集器组合在一起，形成了一个名副其实的“吞吐量优先”的应用组合，在注重吞吐量以及CPU资源敏感的场合，可以考虑优先使用。 Parallel Old收集器的工作过程如下图所示。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，使用“标记-清除”算法。 CMS收集器的完整运作过程分为以下四个步骤： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS remark） 并发清除（CMS concurrent sweep） 其中，初始标记、 重新标记这两个步骤仍然需要“Stop The World”。 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。 通过下图可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。 G1 收集器G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能充分利用多CPU、 多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保留。 虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、 熬过多次GC的旧对象以获取更好的收集效果。 空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。 这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。 使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。 G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。 这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。 G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中，如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。 当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking） 并发标记（Concurrent Marking） 最终标记（Final Marking） 筛选回收（Live Data Counting and Evacuation） 初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 通过下图可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。 垃圾收集相关的常用参数","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--垃圾收集器（上）","slug":"深入理解JVM之--垃圾收集器（上）","date":"2020-05-30T08:45:38.000Z","updated":"2023-04-30T10:21:41.371Z","comments":true,"path":"2020/05/30/深入理解JVM之--垃圾收集器（上）/","link":"","permalink":"/2020/05/30/深入理解JVM之--垃圾收集器（上）/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 Java语言出来之前，程序开发更多的是使用C或者C++语言，然而在C或者C++语言中存在一个很大的矛盾：创建对象时要不断地调用对象的构造方法来为对象开辟空间，对象用完之后又需要不断地去调用析构方法来释放它所占的内存空间，既要写构造方法，又要写析构方法，很多时候都是在做重复的工作。为了解决这一矛盾，垃圾收集器（Garbage Collection，GC）应运而生。 说起垃圾收集器（Garbage Collection，GC），大部分人都把这项技术当作Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。 当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情： 哪些内存需要回收？ 什么时候回收？ 如何回收？ 由于Java运行时数据区域中的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 垃圾收集器回收的重点区域是：Java堆和方法区 “存活”or“死去”垃圾收集器在对对象进行回收之前，需先判断对象是“存活”着，还是已经“死去”（即不可能再被任何途径使用的对象）。垃圾收集器只会对那些已经“死去”的对象进行回收。 常用的判断对象是否存活的算法有以下两种： 1. 引用计数算法引用计数（Reference Counting）算法是垃圾收集器中的早期策略。在这种算法中，堆中每个对象（不是引用）都有一个引用计数。对于一个对象 A，只要有任何一个对象引用了 A，则A 的引用计数器就加 1，当引用失效时，引用计数器就减 1。任何时刻引用计数为0的对象就是不可能再被使用的，即已经“死去”。 引用计数算法实现简单，判定效率也很高。但是这个算法有明显的缺陷，对于循环引用的情况下，循环引用的对象就不会被回收。如A=B,B=A, 此时，对象 A 和对象B 的引用计数器都不为 0。但是在系统中却不存在任何第 3 个对象引用了 A 或 B。也就是说，A 和 B 是应该被回收的垃圾对象，但由于垃圾对象间相互引用，从而使垃圾收集器无法识别，引起内存泄漏。 2. 根搜索算法这种算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，就证明此对象是不可用的。如下图所示（蓝色表示依然存活的对象，橙色表示可回收的对象），对象ObjD、ObjE虽然彼此有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。 在Java语言里，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中的类静态属性引用的对象。 方法区中的常量引用的对象。 本地方法栈中JNI（Native方法）引用的对象。 再谈引用无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，判断对象是否存活都与“引用有关”，所以我们在此再谈谈引用。 在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（ Strong Reference）、软引用（ Soft Reference）、弱引用（ Weak Reference）、虚引用（ Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如果不使用时，可以赋值obj=null，显示的设置obj为null，则GC认为该对象不存在引用，这时候就可以回收此对象。 软引用软引用用来描述一些还有用，但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在 JDK 1.2 之后，提供了 SoftReference 类来实现软引用。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。 软引用主要应用于内存敏感的高速缓存，在Android系统中经常使用到。一般情况下，Android应用会用到大量的默认图片，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软引用技术来避免这个问题发生。SoftReference可以解决oom的问题，每一个对象通过软引用进行实例化，这个对象就以cache的形式保存起来，当再次调用这个对象时，那么直接通过软引用中的get()方法，就可以得到对象中的资源数据，这样就没必要再次进行读取了，直接从cache中就可以读取得到，当内存将要发生OOM的时候，GC也能回收该内存，防止oom发生。 弱引用弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。，当JVM进行垃圾回收时，无论当前内存是否充足，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，用WeakReference类来实现弱引用。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。 以下代码用于对比在内存充足的情况下，调用System.gc()之后，软引用与弱引用关联对象的不同回收结果。 import java.lang.ref.WeakReference; /** * VM Args:-XX:+PrintHeapAtGC */ public class ReferenceTest { public static void main(String[] args) { byte[] bytes = new byte[1024 * 1024 * 5]; /** * 取消softBytes所在行注释，在内存充足的情况下，GC不会回收所关联的byte数组。 */ // SoftReference&lt;byte[]&gt; softBytes=new SoftReference&lt;byte[]&gt;(bytes); /** * 取消weakBytes所在行注释，在内存充足的情况下，GC也会成功回收所关联的byte数组。 */ // WeakReference&lt;byte[]&gt; weakBytes=new WeakReference&lt;byte[]&gt;(bytes); bytes = null; System.gc(); } } 执行程序，根据PrintHeapAtGC所打印出来的堆内存回收日志，可得出以下结论：软引用关联的对象未被回收，而弱引用关联的对象被成功回收了。 虚引用虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。和前面的软引用、弱引用不同，它并不影响对象的生命周期。在JDK 1.2之后，用PhantomReference类来实现虚引用。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。 死里逃生—-finalize()方法被判定为已经“死亡”的对象并不是一定会被JVM回收。一个对象在被回收之前，至少要经历两次标记过程：初次被判定为已经“死亡”后，对象将会被第一次标记并且进行一次筛选,筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法,或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”(即意味着直接回收)。 如果这个对象被判定为有必要执行finalize()方法,那么这个对象将会放置在一个叫做F-Queue的队列之中,并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法,但并不承诺会等待它运行结束,这样做的原因是,如果一个对象在finalize()方法中执行缓慢,或者发生了死循环(更极端的情况),将很可能会导致F-Queue队列中其他对象永久处于等待,甚至导致整个内存回收系统崩溃。 finalize()方法是对象逃脱死亡命运的最后一次机会,稍后GC将对F-Queue中的对象进行第二次小规模的标记,如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可,譬如把自己(this关键字)赋值给某个类变量或者对象的成员变量,那在第二次标记时它将被移除出“即将回收”的集合;如果对象这时候还没有逃脱,那基本上它就真的被回收了。 public class FinalizeEscapeGC { public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() { System.out.println(&quot;yes,i am still alive:)&quot;); } @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(&quot;finalize mehtod executed!&quot;); FinalizeEscapeGC.SAVE_HOOK = this; } public static void main(String[] args) throws Throwable { SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次成功拯救自己 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低,所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(&quot;no,i am dead:(&quot;); } // 下面这段代码与上面的完全相同,但是这次自救却失败了 SAVE_HOOK = null; System.gc(); // 因为finalize方法优先级很低,所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) { SAVE_HOOK.isAlive(); } else { System.out.println(&quot;no,i am dead:(&quot;); } } } 运行结果： finalize mehtod executed!yes,i am still alive:)no,i am dead:( 从运行结果来看SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，，并且在被收集前成功逃脱了。 另一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对面面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。 回收方法区很多人以为方法区（或者HotSopt VM中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且性价比一般较低，在对的新生代生一般能回收70%~95%的空间，而永久代远低于此。 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。 回收废弃常量与回收Java堆中的对象非常相似。以常量池中字面量的回收为例，若字符串“abc”已经进入常量池中，但当前系统没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用该字面量，若发生内存回收，且必要的话，该“abc”就会被系统清理出常量池。常量池中其他的类（接口）、方法、字段的符号引用与此类似。 无用的类需要满足3个条件： 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例； 加载该类的ClassLoader已经被回收； 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，此处仅仅是“可以”，而并不是和对象一样，不使用了就必然回收。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--JVM内存模型","slug":"深入理解JVM之--JVM内存模型","date":"2020-05-30T08:44:38.000Z","updated":"2023-04-30T10:21:41.369Z","comments":true,"path":"2020/05/30/深入理解JVM之--JVM内存模型/","link":"","permalink":"/2020/05/30/深入理解JVM之--JVM内存模型/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7 版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示： 一、运行时数据区域1、程序计数器程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 2、Java 虚拟机栈与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java 内存粗略地区分为堆内存（Heap）和栈内存（Stack），这里的“栈内存”就是指的虚拟机栈，或者说是虚拟机栈中的局部变量表部分。 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。 其中64 位长度的long 和double 类型的数据会占用2 个局部变量空间（Slot），其余的数据类型只占用1 个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 在Java 虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展（当前大部分的Java 虚拟机都可动态扩展，只不过Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError 异常。 3、本地方法栈本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。 4、Java 堆对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。 Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。从内存分配的角度来看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。 根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 5、方法区方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。 对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。 Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。 根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 6、运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常。 7、直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。 在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。 显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 二、OutOfMemoryError异常在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（OOM）异常的可能，以下将通过实例来模拟各个区域发生OOM异常的场景。 1、Java堆溢出Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出。 修改Eclipse IDE的虚拟机启动参数如下：-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 将Java堆的大小限制为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），其中年轻代大小为10M（-Xmn参数指定），Eden空间与单个Survivor空间（From Survivor空间或To Survivor空间）大小比值为 8:1。 此时JVM堆内存各个空间大小分配如下： （Heap总大小）20MB = （Eden空间）8MB+（Survivor空间）1MB*2+（老年代）10MB 测试代码如下： import java.util.ArrayList; import java.util.List; /** * VM Args:-Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 */ public class HeapOOM { static class OOMObject { } public static void main(String[] args) { List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;(); while (true) { list.add(new OOMObject()); } } } 运行结果： 2、虚拟机栈和本地方法栈溢出由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于hotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常： 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。 测试代码如下： /** * VM Args:-Xss128k */ public class JavaVMStackSOF { private int stackLength = 1; public void stackLeak() { stackLength++; stackLeak(); } public static void main(String[] args) throws Throwable { JavaVMStackSOF sof = new JavaVMStackSOF(); try { sof.stackLeak(); } catch (Throwable e) { System.out.println(&quot;stack length:&quot; + sof.stackLength); throw e; } } } 运行结果： 注意： 以上测试代码在单线程中进行操作，若使用-Xss参数减少栈内存容量或在方法中定义本地变量，均会导致抛出StackOverflowError异常时输出的堆栈深度减小。 在单线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。 理论上通过不断地创建线程的方式是可以产生内存溢出异常的，例如下面的测试代码，但是这样产生的内存溢出与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下为每个线程分配的内存越大，反而越容易产生内存溢出异常。 导致以上现象出现的原因如下：操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（Windows操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。 /** *VM Args:-Xss4M(这时候不妨设置大些) */ public class JavaVMStackOOM { private void dontStop() { while (true) { } } public void stackLeakByThread() { while (true) { Thread thread = new Thread(new Runnable() { public void run() { dontStop(); } }); thread.start(); System.out.println(Thread.activeCount()); } } public static void main(String[] args) throws Throwable { JavaVMStackOOM oom = new JavaVMStackOOM(); oom.stackLeakByThread(); } } 运行结果： 注意：由于Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，因此上述代码执行时有较大的风险，可能会导致操作系统假死，并不一定会抛出OutOfMemoryError异常。 3、方法区和运行时常量池溢出String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.６及以前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和 -XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量。 测试代码如下： import java.util.List; import java.util.ArrayList; /** * VM Args:-XX:PermSize=10M -XX:MaxPermSize=10M */ public class RuntimeConstantPoolOOM { public static void main(String[] args) { // 使用List保持常量池引用，避免Full GC回收常量池内的对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); int i = 0; while (true) { list.add(String.valueOf((i++)).intern()); } } } 运行结果： 方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本思路是运行时产生大量的类去填满方法区，直到溢出。以下示例代码借助CGLIB直接操作字节码运行时生成大量的动态类进行测试。 import java.lang.reflect.Method; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; /** * VM Args:-XX:PermSize=10M -XX:MaxPermSize=10M */ public class JavaMethodAreaOOM { static class OOMObject { } public static void main(String[] args) { while (true) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() { public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { return proxy.invokeSuper(obj, args); } }); enhancer.create(); } } } 运行结果： 4、本机直接内存溢出DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，测试代码越过了DirectByteBuffer类，直接通过反射获取Unsafe示例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。 测试代码如下： import java.lang.reflect.Field; import sun.misc.Unsafe; /** * VM Args:-Xmx20M -XX:MaxDirectMemorySize=10M */ public class DirectMemoryOOM { private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws Exception { Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) { unsafe.allocateMemory(_1MB); } } } 运行结果：","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--class类文件","slug":"深入理解JVM之--类文件结构","date":"2020-05-30T08:43:38.000Z","updated":"2023-04-30T10:21:41.373Z","comments":true,"path":"2020/05/30/深入理解JVM之--类文件结构/","link":"","permalink":"/2020/05/30/深入理解JVM之--类文件结构/","excerpt":"","text":"参考书籍：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》 Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：一次编写，到处运行（Write Once,Run Anywhere），这句话充分表达了软件开发人员对冲破平台界限的渴求。而实现这个“与平台无关”理想的基础就是虚拟机和字节码（ByteCode）格式存储。 Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、 Bytecodes）和符号表，还有一些其他辅助信息。使用不同语言所编写的代码只要能够被正确编译为符合虚拟机规范要求的Class文件，虚拟机就能够执行它，虚拟机并不关心Class文件的来源是何种语言。 一、Class类文件的结构Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、 语言无关两项特性的重要支柱。 Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。 当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。 根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。 无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾，用于描述有层次关系的复合结构的数据。 整个Class文件本质上就是一张表，它由下表所示的数据项构成。 样例源码： package jvm; public class SimpleClass implements Comparable&lt;SimpleClass&gt; { private static final int magic = 0xCAFEBABE; private int number; public void setNumber(int number) { this.number = number; } public int compareTo(SimpleClass o) { if (this.number == o.number) { return 0; } int ret = this.number &gt; o.number ? 1 : -1; return ret; } } 将以上代码使用JDK 1.6编译输出的Class文件在UltraEdit中打开，其前64个字节的内容如下图： 二、魔数与Class文件的版本每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。 很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。 使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。 如上图所示，Class文件的魔数值为：0xCAFEBABE。 紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version，图中为0x0000），第7和第8个字节是主版本号（Major Version，图中为0x0031）。 三、常量池由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。 与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，如上图所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0024，即十进制的36，这就代表常量池中有35项常量，索引值范围为1～35。 在Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、 字段表集合、 方法表集合等的容量计数都与一般习惯相同，是从0开始的。 常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符号引用则属于编译原理方面的概念，包括了下面三类常量： 类和接口的全限定名（Fully Qualified Name） 字段的名称和描述符（Descriptor） 方法的名称和描述符 常量池中每一项常量都是一个表，从JDK 1.7开始，共分为以下14种表类型。 还是以上面编译的class文件的UltraEdit截图进行示例。 UltraEdit截图中常量池的第一项常量的标志位（偏移地址：0x0000000a）是0x07，表示这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。 CONSTANT_Class_info的结构比较简单，见下表。 tag是标志位，用于区分常量类型；name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名，这里name_index值（偏移地址：0x0000000b）为0x0002，也即是指向了常量池中的第二项常量。 继续从UltraEdit截图中查找第二项常量，它的标志位（地址：0x0000000d）是0x01，表示这个常量属于CONSTANT_Utf8_info类型，CONSTANT_Utf8_info类型的结构见下表。 length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。 UTF-8缩略编码与普通UTF-8编码的区别是： 从’\\u0001’到’\\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示； 从’\\u0080’到’\\u07ff’之间的所有字符的缩略编码用两个字节表示； 从’\\u0800’到’\\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。 本例中这个字符串的length值（偏移地址：0x0000000e）为0x000F，也就是长15字节，往后15字节正好都在1～127的ASCII码范围以内，内容为“jvm/SimpleClass”，换算结果如下图选中的部分所示。 其余的34个常量，我们可以通过类似的方法计算出来，或使用javap工具帮助我们进行计算，以下是使用javap工具的-verbose参数输出的SimpleClass.class的常量池内容。 常量池中14种常量项的结构总表。 四、访问标志在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。 具体的标志位以及标志的含义下表。 access_flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。UltraEdit截图中的access_flags标志（偏移地址：0x000001b2）值为0x0021，代表SimpleClass是一个public访问权限的普通java类。 五、类索引、 父类索引与接口索引集合类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。 类索引、 父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。 SimpleClass类仅实现了一个Comparable接口，其接口计数器偏移地址：0x00001b07，其后紧跟0x0005指向一个CONSTANT_Class_info类型的索引值，从常量#6可以看出，这个索引指向的就是Comparable接口。 六、字段表集合字段表（field_info）用于描述接口或者类中声明的变量。 字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表结构如下表。 其中access_flag可以设置的访问标志位和含义见下表。 跟随access_flags标志的是两项索引值：name_index和descriptor_index。 它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。 所谓全限定，仅仅是把类全名中的.替换成了/而已，例如：“java/lang/Comparable”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个；表示全限定名结束。 简单名称是指没有类型和参数修饰的方法或者字段名称，例如，SimpleClass类中的setNumber()方法和magic字段的简单名称分别是“setNumber”和“magic”。 描述符的作用是用来描述字段的数据类型、 方法的参数列表（包括数量、 类型以及顺序）和返回值。 对于数组类型，每一维度将使用一个前置的[字符来描述，如一个定义为java.lang.String[][]类型的二维数组，将被记录为：[[Ljava/lang/String；，一个整型数组int[]将被记录为[I。 用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号（）之内。 如方法void inc()的描述符为（）V，方法java.lang.String toString()的描述符为（）Ljava/lang/String；，方法int indexOf（char[]source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex）的描述符为（[CII[CIII）I。 对于SimpleClass.class文件来说，字段表集合从地址0x000001bb开始，第一个u2类型的数据为容量计数器fields_count，如图所示，其值为0x0002，说明这个类有两个字段表数据。 接下来紧跟着容量计数器的是第一个字段的access_flags标志，值为0x001A，代表该字段被private+static+final修饰。 代表字段名称的name_index的值为0x0007，从常量池中可查得第7项常量名为magic，代表字段描述符的descriptor_index的值为0x0008，指向常量池的字符串I，即该字段为int类型。 字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。 七、方法表集合Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、 名称索引（name_index）、 描述符索引（descriptor_index）、 属性表集合（attributes）几项，见下表。 对于方法表，所有标志位及其取值可参见下表。 对于SimpleClass.class文件来说，方法表集合的入口地址为：0x00001d04，第一个u2类型的数据（即是计数器容量）的值为0x0004，代表集合中有四个方法（这四个方法为编译器添加的实例构造器＜init＞、Comparable接口的构造方法以及源码中的方法compareTo()和setNumber()方法）。 第一个方法的访问标志值为0x001，也就是只有ACC_PUBLIC标志为真，名称索引值为0x000C，从常量池中可查得第12项常量池的方法名为“＜init＞，描述符索引值为0x000D，对应常量为（）V，属性表计数器attributes_count的值为0x0001就表示此方法的属性表集合有一项属性，属性名称索引为0x000E，对应常量为Code，说明此属性是方法的字节码描述。 与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。 但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“＜clinit＞”方法和实例构造器“＜init＞”方法。 八、属性表集合属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class文件、 字段表、 方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。 属性表的预定义属性目前共有21项，例如：Code、ConstantValue、LocalVariableTable、LineNumberTable。 Code属性Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。 Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下表所示。 attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。 max_stack代表了操作数栈（Operand Stacks）深度的最大值。 在方法执行的任意时刻，操作数栈都不会超过这个深度。 虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。 max_locals代表了局部变量表所需的存储空间。 在这里，max_locals的单位是Slot,Slot是虚拟机为局部变量分配内存所使用的最小单位。 对于byte、 char、 float、 int、 short、 boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。 方法参数（包括实例方法中的隐藏参数“this”）、 显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、 方法体中定义的局部变量都需要使用局部变量表来存放。 另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。 code_length和code用来存储Java源程序编译后生成的字节码指令。 code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。 其中异常表的结构如下表。 Exceptions属性Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。 它的结构见下表。 LineNumberTable属性LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。 它的结构见下表。 LocalVariableTable属性LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。 它的结构见下表。 其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构下表。 ConstantValue属性ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。 只有被static关键字修饰的变量（类变量）才可以使用这项属性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--javac命令","slug":"深入理解JVM之--javac命令","date":"2020-05-30T08:42:38.000Z","updated":"2023-04-30T10:21:41.371Z","comments":true,"path":"2020/05/30/深入理解JVM之--javac命令/","link":"","permalink":"/2020/05/30/深入理解JVM之--javac命令/","excerpt":"","text":"javac命令用于将 .java 源文件编译成 .class 字节码文件，在windows命令行中使用”javac -help”命令查看其用法： 语法格式: javac &lt;options&gt; &lt;source files&gt; options # 命令行选项，可指定多个，多个选项可按任意顺序排列。 source files # 用于指定一个或多个要编译的 .java 源文件。 指定编译源文件如果需要编译的源文件数量较少，可以直接在命令行上将所有文件名（必要时包含路径）列出，多个文件名之间用空格分隔。 javac src/FirstClass.java src/SecondClass.java src/ThirdClass.java # 例1 注意：如果文件路径中包含有空格，需用双引号把该文件名括起来。 javac &quot;src/Program Files/MyClass.java&quot; 在没使用分号的情况下，对相同路径下的多个 .java 源码文件进行编译，可以使用*通配符，此时例1可以写成如下形式： javac src/*.java javac src/*Class.java 如果需要编译的 .java 源文件数量较多，为缩短和简化javac命令，可以把要编译的 .java 源文件的文件名（必要时包含路径）存储到一个文件中，多个 .java 源文件名之间用空格或回车进行分隔。然后在javac命令行中，用‘@’ 字符指定该文件。 比如，我们把例1中要编译的 .java 源码文件名写到classes.txt文件中，classes.txt文件内容如下： src\\FirstClass.java src\\SecondClass.java src\\ThirdClass.java 我们也可以在classes.txt中用双引号把单个要编译的 .java 源文件名括起来，但是这时路径之间接的分隔符“\\”就要写成”\\“的形式了。classes.txt文件内容如下： &quot;src\\\\FirstClass.java&quot; &quot;src\\\\SecondClass.java&quot; &quot;src\\\\ThirdClass.java&quot; 此时，执行如下的javac命令： javac @classes.txt 命令选项-d &lt;目录&gt; # 指定放置生成的类文件的位置 该选项用于指定生成的.class文件存放的位置。如果某个类是一个包的组成部分，则javac将把生成的.class文件放入反映包名的子目录中，必要时创建目录。 package com.pengjunlee; public class MyClass { } 使用命令：**javac -d bin src\\MyClass.java**，对以上MyClass.java文件进行编译，将会将生成的MyClass.class文件存放到 bin\\com\\pengjunlee 目录下。 若未指定 -d 选项，则 javac 将把生成的 .class 文件放到与 .java 源文件相同的目录中。.class类文件的搜索路径 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;路径&gt; 覆盖所安装扩展的位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 JDK在编译一个java源文件时，搜索依赖的.class类文件的顺序如下： Bootstrap classes--&gt;Extension classes--&gt;User classes Bootstrap classes 默认的是JDK自带的jar或zip文件，它包括jre\\lib下rt.jar等文件，JDK首先搜索这些文件。可以通过-bootclasspath来设置它，文件之间用分号”;”进行分隔。 Extension classes 默认的是位于jre\\lib\\ext目录下的jar文件，JDK在搜索完Bootstrap后就搜索该目录下的jar文件.可以通过-extdirs来设置。文件之间用分号”;”来进行分隔。 User classes 搜索顺序为当前目录、环境变量 CLASSPATH、-classpath。 -cp 和 -classpath 是同义词，参数意义是一样的。classpath参数太长了，所以提供cp作为缩写形式。它们用于告知JDK搜索目录名、jar文档名、zip文档名，用分号”;”进行分隔。例如当你自己开发了公共类并包装成一个common.jar包，在使用 common.jar中的类时，就需要用-classpath common.jar告诉JDK从common.jar中查找该类，否则JDK就会抛出java.lang.NoClassDefFoundError异常，表明未找到类定义。 使用-classpath后JDK将不再使用CLASSPATH中的类搜索路径，如果-classpath和CLASSPATH都没有设置，则JDK使用当前路径(.)作为类搜索路径。 推荐使用-classpath来定义JDK要搜索的类路径，而不要使用环境变量 CLASSPATH的搜索路径，以减少多个项目同时使用CLASSPATH时存在的潜在冲突。例如应用1要使用a1.0.jar中的类G，应用2要使用a2.0.jar中的类G,a2.0.jar是a1.0.jar的升级包，当a1.0.jar，a2.0.jar都在CLASSPATH中，JDK搜索到第一个包中的类G时就停止搜索，如果应用1应用2的虚拟机都从CLASSPATH中搜索，就会有一个应用得不到正确版本的类G。 javac -cp bin -d bin MyClass.java javac -classpath bin -d bin MyClass.java 如果需要指定各个JAR文件具体的存放路径，相同路径有多个可使用通配符。 -sourcepath &lt;路径&gt; # 指定查找输入源文件的位置 在编译时，JDK需要两方面的路径，一个是查找java源码文件的路径，一个是查找 .class（类）文件的路径。 关于.class文件的路径上文已经已经介绍过，可以通过-bootclasspath，-extdirs，-classpath和-cp来设定。java源码文件的路径则可以通过-sourcepath来设定，默认情况下-sourcepath和-classpath的路径一样。在编译的过程中，若需要相关java类的则首先在sourcefiles或@files列出的java源码文件中查找并编译，如果没找到，就在-sourcepath指定的路径中查找java源码文件，这时无论找没找到都会继续在类路径中进行查找。如果在sourcepath中找到了java源码文件，但是在类路径中没有找到了相关的类，或找的类位于包文件（jar或zip）中,或找的类并不是在包文件中，但源码文件比该类文件新，这时会对源码文件进行编译，而且编译生成的类文件将会和你指定要进行编译的java源码所生成的类文件位于同一根目录。否则，除了既没找到java源码文件也没找到相关类就编译失败外，直接载入相关类就可以了。因此你得至少要指定一个要编译的java源文件。它并不是指定sourecfiles或@files中指定的要编译的java源码文件的根目录。与类路径一样，java源码路径项用分号 (;) 进行分隔，它们可以是class文件的根目录、JAR 归档文件或 ZIP 归档文件。 javac -sourcepath src -d bin MyClass.java -source &lt;发行版&gt; # 提供与指定发行版的源兼容性 当你从sun安装了某个版本的JDK，而其实该JDK却包含多个版本的编译器。-source参数就是指定用哪个版本的编译器对java源码进行编译。如果你的java源码不符合该版本编译器的规范的话，当然就不能编译通过。 -target &lt;发行版&gt; # 生成特定 VM 版本的类文件 -target 命令用于指定生成的class文件将保证和哪个版本的虚拟机进行兼容。我们可以通过-target 1.2来保证生成的class文件能在1.2虚拟机上进行运行，但是1.1的虚拟机就不能保证了。因为java虚拟机的向前兼容行，1.5的虚拟机当然也可以运行通过-target 1.2生成的class文件。每个版本编译器的默认-target版本是不太一样的。 javac -source 1.2 -target 1.1 -sourcepath src -d bin MyClass.java javac -source 1.2 -target 1.5 -sourcepath src -d bin MyClass.java -deprecation # 输出使用已过时的 API 的源位置 如果java源码中使用了不鼓励使用的类或方法，那么如果使用了该参数，将显示关于此警告的详细信息,否则只有个简单的Note. public class MyClass { public static void main(String[] args) { String str=new String(new byte[3],100); } } -verbose # 输出有关编译器正在执行的操作的消息 使用该参数，你可以看到编译器编译java源文件的详细过程。 -encoding&lt;编码&gt; ＃ 指定源文件使用的字符编码 设置源文件编码名称，例如UTF-8。若未指定 -encoding 选项，则使用平台缺省的编码方式。 -g ＃ 生成所有调试信息 生成所有的调试信息，包括局部变量。缺省情况下，只生成行号和源文件信息。 -g:none ＃ 不生成任何调试信息 -g:{lines,vars,source} ＃ 只生成某些调试信息 -nowarn ＃ 禁用警告信息。 非标准选项 -X使用该参数，可以显示所有的非标准选项的有关信息。 -Xlint ＃ 启用建议的警告 -Xlint:{all,none，其他选项} ＃ 启用或禁用特定的警告 通过该命令我们将看到你java源码文件的一些危险代码，关键字有： {all,auxiliaryclass,cast,classfile,deprecation,dep-ann,divzero,empty,fallthrough,finally,options,overloads, overrides,path,processing,rawtypes,serial,static,try,unchecked,varargs, -auxiliaryclass,-cast,-classfile,-deprecation,-dep-ann,-divzero,-empty,-fallthrough,-finally,-options,-overloads,-overrides,-path,-processing,-rawtypes,-serial,-static,-try,-unchecked,-varargs,none} 没有”-“前缀的表示开启，有的该前缀的表示关闭，all表示开启所有，none表示都不开启。 public class MyClass { public static void main(String[] args) { String str=new String(new byte[3],100); } } -Xstdout &lt;文件名&gt; ＃ 重定向标准输出 javac命令执行信息默认将在当前控制台进行显示，我们可以用该参数进行重新定义。比如将前一示例的编译过程信息输出到”stdout.log”文件中： javac -Xstdout stdout.log -Xlint:all MyClass.java 命令执行完成后，查看stdout.log中内容如下： -Xmaxerrs &lt;编号&gt; ＃ 设置要输出的错误的最大数目 -Xmaxwarns &lt;编号&gt; ＃ 设置要输出的警告的最大数目","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"深入理解JVM系列之--字节码指令表","slug":"深入理解JVM之--字节码指令表","date":"2020-05-30T08:41:38.000Z","updated":"2023-04-30T10:21:41.372Z","comments":true,"path":"2020/05/30/深入理解JVM之--字节码指令表/","link":"","permalink":"/2020/05/30/深入理解JVM之--字节码指令表/","excerpt":"","text":"《深入理解Java虚拟机JVM高级特性与最佳实践》附录B 虚拟机字节码指令表","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"JVM,Java,虚拟机","slug":"JVM-Java-虚拟机","permalink":"/tags/JVM-Java-虚拟机/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--解释器模式","slug":"Java设计模式之--解释器模式","date":"2020-05-24T09:03:28.000Z","updated":"2023-04-30T10:21:41.361Z","comments":true,"path":"2020/05/24/Java设计模式之--解释器模式/","link":"","permalink":"/2020/05/24/Java设计模式之--解释器模式/","excerpt":"","text":"一、什么是解释器模式解释器(Interpreter)模式是一种对象的行为模式。给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 所谓“语言”，指的是使用规定格式和文法的一类字符组合。 所谓“文法”，简单点说就是我们俗称的“语法规则”。 以java语言为例，其变量声明文法为：[public|protected|private] + [static] + [final] + 变量类型 + 变量名 + [=初始值]，以下这条字符串变量声明语句就是该文法的一种表示：private static final String sql = “ select * from user where 1=1” 。 解释器模式的本质：分离实现，解释执行 设计意图：为语言中的不同的文法表示，分别定义一个与该文法表示相对应的的解释器，然后通过这个解释器来对该文法表示进行解释。 二、解释器模式的结构 解释器模式涉及的角色及其职责如下： 抽象表达式(AbstractExpression)角色：约定解释器的解释操作，主要是一个interpret()方法。 终结符表达式(TerminalExpression)角色：用来实现文法中和终结符相关的解释操作，不再包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的叶子对象，可以有多种终结符解释器。 非终结符表达式(NonterminalExpression)角色：用来实现文法中和非终结符相关的解释操作，通常一个解释器对应一个语法规则，可以包含其它的解释器，如果用组合模式来构建抽象语法树的话，就相当于组合模式中的组合对象，可以有多种非终结符解释器。 环境(Context)角色：也称“上下文”，常用HashMap来代替，通常包含解释器之外的一些全局信息（解释器需要的数据，或是公共的功能）。 客户端(Client)角色：构建文法表示的抽象语法树（Abstract Syntax Tree，该抽象语法树由终结符表达式和非终结符表达式的实例装配而成），并调用解释操作interpret()方法。 解释器模式结构示意源代码如下：首先定义一个抽象表达式(AbstractExpression)角色，并在其中定义一个执行解释操作的接口，示例代码如下。 /** * 抽象表达式 */ public abstract class AbstractExpression { /** * 解释的操作 * @param ctx 上下文对象 */ public abstract void interpret(Context ctx); } 抽象表达式(AbstractExpression) 的具体实现分两种：终结符表达式(TerminalExpression)和非终结符表达式 /** * 终结符表达式 */ public class TerminalExpression extends AbstractExpression { @Override public void interpret(Context ctx) { // 实现与语法规则中的终结符相关联的解释操作 } } /** * 非终结符表达式 */ public class NonterminalExpression extends AbstractExpression { @Override public void interpret(Context ctx) { // 实现与语法规则中的非终结符相关联的解释操作 } } 再来看看环境(Context)的定义，示例代码如下。 /** * 上下文，包含解释器之外的一些全局信息 */ public class Context { } 最后来看看客户端的定义，示例代码如下。 /** * 使用解释器的客户 */ public class Client { /** * 主要按照语法规格对特定的句子构建抽象语法树 * 然后调用解释操作 */ } 以上示例代码很简单， 只是为了说明解释器模式实现的基本结构和各个角色的功能， 实际的解释逻辑并未写出。 三、解释器模式应用举例假如我们要实现这么一个功能：加减法计算器。计算器中参与运算的元素为a、b、c、d等…，这些元素都与具体的业务相关，我们不细追究其所代表的意义。现要实现：客户端指定一个公式，如“a+b-c”，“a+b+c-d”，计算器就可以计算出结果。 设计好的类图结构示意如下： 源代码如下。 import java.util.HashMap; /** * 抽象表达式,声明解释操作 */ public interface AbstractExpression { // 每个表达式都必须有一个解释操作 public int interprete(HashMap&lt;String, Integer&gt; var); } import java.util.HashMap; /** * 终结符表达式,代表参加运算的元素对象 */ public class VarExpression implements AbstractExpression { private String key; public VarExpression(String key) { this.key = key; } public int interprete(HashMap&lt;String, Integer&gt; var) { return (Integer) var.get(this.key); } } /** * 非终结符表达式,运算符（此处为加法和减法）的抽象父类,真正的解释操作由其子类来实现 */ public abstract class SymbolExpression implements AbstractExpression { protected AbstractExpression left; protected AbstractExpression right; // 非终结符表达式的解释操作只关心自己左右两个表达式的结果 public SymbolExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } } import java.util.HashMap; /** * 加法表达式 */ public class AddExpression extends SymbolExpression { public AddExpression(AbstractExpression left, AbstractExpression right) { super(left, right); } // 把左右两个表达式运算的结果加起来 public int interprete(HashMap&lt;String, Integer&gt; var) { return super.left.interprete(var) + super.right.interprete(var); } } import java.util.HashMap; /** * 减法表达式 */ public class SubExpression extends SymbolExpression { public SubExpression(AbstractExpression left, AbstractExpression right) { super(left, right); } // 左右两个表达式相减 public int interprete(HashMap&lt;String, Integer&gt; var) { return super.left.interprete(var) - super.right.interprete(var); } } import java.util.HashMap; import java.util.Stack; public class Calculator { private AbstractExpression expression; /** * 对公式进行解析操作 * * @param expStr * 输入的公式 */ public Calculator(String expStr) { // 定义一个堆栈，安排运算的先后顺序 Stack&lt;AbstractExpression&gt; stack = new Stack&lt;AbstractExpression&gt;(); // 表达式拆分为字符数组 char[] charArray = expStr.toCharArray(); // 运算 AbstractExpression left = null; AbstractExpression right = null; for (int i = 0; i &lt; charArray.length; i++) { switch (charArray[i]) { case &#39;+&#39;: // 加法 left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new AddExpression(left, right)); break; case &#39;-&#39;: // 减法 left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: // 公式中的变量 stack.push(new VarExpression(String.valueOf(charArray[i]))); } } // 把运算结果抛出来 this.expression = stack.pop(); } // 计算结果 public int calculate(HashMap&lt;String, Integer&gt; var) { return this.expression.interprete(var); } } import java.util.HashMap; public class Client { public static void main(String[] args) { // 构造运算元素的值列表 HashMap&lt;String, Integer&gt; ctx = new HashMap&lt;String, Integer&gt;(); ctx.put(&quot;a&quot;, 10); ctx.put(&quot;b&quot;, 20); ctx.put(&quot;c&quot;, 30); ctx.put(&quot;d&quot;, 40); ctx.put(&quot;e&quot;, 50); ctx.put(&quot;f&quot;, 60); Calculator calc = new Calculator(&quot;a+b-c&quot;); int result = calc.calculate(ctx); System.out.println(&quot;Result of a+b-c: &quot; + result); calc = new Calculator(&quot;d-a-b+c&quot;); result = calc.calculate(ctx); System.out.println(&quot;Result of d-a-b+c: &quot; + result); } } 运行程序打印结果如下： Result of a+b-c: 0Result of d-a-b+c: 40 该加减法计算器示例与解释器模式组成元素对照如下： 给定一种语言， 本例中就是一个简单的加减运算。 定义一种文法表示，本例中就是指定的参与运算的元素(abcdef)以及运算符(+-)，以及由它们构造而成的公式，如 d-a-b+c。 给定一个解释器来解释语言中的句子：本例中的解释器是多个类的组合,包括Calculator和AbstractExpression 。 TerminalExpression表示终结符表达式，相当于本例中的VarExpression。 NonterminalExpression是非终结符表达式，相当于本例中的加法、减法。 四、解释器模式的适用性解释器模式似乎使用面不是很广，它描述了一个语言解释器是如何构成的，在实际应用中，我们可能很少去构造一个语言的文法。 建议在以下情况中选用解释器模式：当有一个语言需要解释执行，并且可以将语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式。 五、解释器模式的优缺点解释器模式有以下优点: 易于实现语法在解释器模式中，一条语法规则用一个解释器对象来解释执行。对于解释器的实现来讲，功能就变得比较简单，只需要考虑这一条语法规则的实现就可以了，其他的都不用管。 易于扩展新的语法正是由于采用一个解释器对象负责一条语法规则的方式，使得扩展新的语法非常容易。扩展了新的语法，只需要创建相应的解释器对象，在创建抽象语法树的时候使用这个新的解释器对象就可以了。 解释器模式有以下缺点: 不适合复杂的语法如果语法特别复杂，构建解释器模式需要的抽象语法树的工作是非常艰巨的，再加上有可能会需要构建多个抽象语法树。所以解释器模式不太适合于复杂的语法，对于复杂的语法，使用语法分析程序或编译器生成器可能会更好一些。 六、相关模式 解释器和组合模式这两种模式可以组合使用。通常解释器模式都会使用组合模式来实现，这样能够方便地构建抽象语法树。一般非终结符解释器相当于组合模式中的组合对象，终结符解释器相当于叶子对象。 解释器模式和迭代器模式这两种模式可以组合使用。由于解释器模式通常使用组合模式来实现，因此在遍历整个对象结构时，可以使用迭代器模式。 解释器模式和享元模式这两种模式可以组合使用。在使用解释器模式的时候，可能会造成多个细粒度对象，如各式各样的终结符解释器，而这些终结符解释器对不同的表达式来说是一样的，是可以共用的，因此可以引入享元模式来共享这些对象。 解释器模式和访问者模式这两种模式可以组合使用。在解释器模式中，语法规则和解释器对象是有对应关系的。语法规则的变动意味着功能的变化。自然会导致使用不同的解释器对象；而且一个语法规则可以被不同的解释器解释执行。因此在构建抽象语法树的时候，如果每个节点所对应的解释器对象是固定的，这意味着该节点对应的功能是固定的，那么就不得不根据需要来构建不同的抽象语法树。为了让构建的抽象语法树较为通用，那就要求解释器的功能不要那么固定，要能很方便地改变解释器的功能，这个时候就变成了如何能够很方便地更改树形结构中节点对象的功能了，访问者模式可以很好的实现这个功能。 七、总结解释器模式通过一个解释器对象处理一个语法规则的方式，把复杂的功能分离开；然后选择需要被执行的功能，并把这些功能组合成为需要被解释执行的抽象语法树；再按照抽象语法树来解释执行，实现相应的功能。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"解释器模式,Java,设计模式","slug":"解释器模式-Java-设计模式","permalink":"/tags/解释器模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--外观模式","slug":"Java设计模式之--外观模式","date":"2020-05-24T09:02:28.000Z","updated":"2023-04-30T10:21:41.357Z","comments":true,"path":"2020/05/24/Java设计模式之--外观模式/","link":"","permalink":"/2020/05/24/Java设计模式之--外观模式/","excerpt":"","text":"一、什么是外观模式外观(Facade)模式是一种对象的结构型模式。为子系统中的一组接口提供一个一致的界面， Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式的本质：封装交互，简化调用 设计意图：隐藏系统的复杂性，并向客户端提供一个可以访问系统的简单接口，以降低用户使用系统的复杂性。 将一个系统划分成为若干个子系统有利于降低系统的复杂性。一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，达到该目标的途径之一就是引入一个外观(Facade)对象，它为子系统中较一般的设施提供了一个单一而简单的界面。 如图所示，引入外观角色之后，用户只需要直接与外观角色交互，用户与子系统之间的复杂关系由外观角色来实现，从而降低了系统的耦合度。 二、外观模式的结构 外观模式没有一个一般化的类图表示，下图仅是一个功能示意。 外观模式涉及的角色及其职责如下： 外观(Facade)角色：定义整个系统对外的高层接口，通常需要调用内部多个子系统，从而把客户的请求代理给适当的子系统对象。 子系统(Subsystem)角色：接受Facade对象的委派，真正实现功能，各个子系统对象之间可能有交互。但是请注意，Facade对象知道各个子系统，但是各个子系统不应该知道Facade对象。 此处为了示意，我们举一个简单的例子：汽车停车起步。 汽车停车起步简化之后一般会包括以下几个操作步骤：发动汽车–&gt;踩下离合–&gt;挂档–&gt;松开离合–&gt;踩油门。当然这只是一个极简化了的步骤，真实的操作步骤可能比这还要复杂得多(还要配合刹车等操作)。然而，即便就是这经过简化的步骤，也经常会把许多学车的新手搞得手忙脚乱、连连憋熄火。 这是一个典型的用户与一个系统（汽车）中的多个子系统（动力系统，离合器，变速器，油门）进行交互的情形，用户需要和所有的子系统交互，才能完成自己想要实现的功能，这其实是极不合理的，也极容易出错，毕竟并非所有的用户都是“老司机”，你说是吧！ 接下来我们使用外观模式来改造，实现以上的功能，类图结构如下： 下面是其实现的源代码：首先来看看各个子系统的定义，包括：动力系统、离合器、加速器、变速器四个子系统。 /** * 动力系统 */ public class PowerSystem { /** * 汽车发动 */ public void startUp() { System.out.println(&quot;汽车发动。。。。&quot;); } /** * 汽车熄火 */ public void closeDown() { System.out.println(&quot;汽车熄火。。。。&quot;); } } /** * 离合器 */ public class ClutchSystem { /** * 踩下离合 */ public void press() { System.out.println(&quot;踩下离合。。。。&quot;); } /** * 松开离合 */ public void release() { System.out.println(&quot;松开离合。。。。&quot;); } } /** * 变速器 */ public class TransmissionSystem { /** * 挂挡操作 * @param gear 所挂档位 */ public void shift(int gear) { switch (gear) { case -1: System.out.println(&quot;挂倒档。。。。&quot;); break; case 0: System.out.println(&quot;挂空档。。。。&quot;); break; case 1: System.out.println(&quot;挂一档。。。。&quot;); break; case 2: System.out.println(&quot;挂二档。。。。&quot;); break; case 3: System.out.println(&quot;挂三档。。。。&quot;); break; case 4: System.out.println(&quot;挂四档。。。。&quot;); break; case 5: System.out.println(&quot;挂五档。。。。&quot;); break; } } } /** * 加速器，即油门 */ public class AcceleratorSystem { /** * 踩下油门 */ public void press() { System.out.println(&quot;踩下油门。。。。&quot;); } /** * 松开油门 */ public void release() { System.out.println(&quot;松开油门。。。。&quot;); } } 接下来该看看外观的定义了，示例代码如下。 /** * 外观类 */ public class Facade { /** * 示意方法，停车起步 */ public void parkingStart() { // 创建需要转调的子系统对象实例 ClutchSystem clutchSystem = new ClutchSystem(); TransmissionSystem transmissionSystem = new TransmissionSystem(); AcceleratorSystem acceleratorSystem = new AcceleratorSystem(); // 转调子系统的功能 clutchSystem.press(); transmissionSystem.shift(1); clutchSystem.release(); acceleratorSystem.press(); System.out.println(&quot;汽车开始动了。。。。&quot;); } } 创建一个客户端类测试一下，示例代码如下。 public class Client { public static void main(String[] args) { PowerSystem powerSystem = new PowerSystem(); // 发动汽车 // 此处作为示意，用户可以跳过外观，直接与子系统进行交互 powerSystem.startUp(); // 创建外观实例 Facade facade = new Facade(); // 停车起步 facade.parkingStart(); } } 运行程序打印结果如下： 汽车发动。。。。踩下离合。。。。挂一档。。。。松开离合。。。。踩下油门。。。。汽车开始动了。。。。 在以上代码示例中，为简明起见，只为Facade对象添加了一个“停车起步”的功能，事实上它还可以有更多其他的功能，Facade对象这个“停车起步”的功能其实就相当于是为已经发动了的汽车增加了一个“一键停车起步”的功能。并未把“发动汽车”这个步骤一并加入的Facade对象中，主要是为了作一个示意：根据实际需要，用户是可以越过Facade层，直接与子系统进行交互的。 三、外观模式的适用性在以下条件下可以考虑使用外观模式： 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过facade层。 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 当你需要构建一个层次结构的子系统时，使用 facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过facade进行通讯，从而简化了它们之间的依赖关系。 四、外观模式和中介者模式外观模式和中介者模式非常类似，但是却有本质的区别。 中介者模式主要用来封装多个对象之间相互的交互，多用在系统内部的多个模块之间；而外观模式封装的是单向的交互，是从客户端访问系统的调用，没有从系统中来访问客户端的调用。 在中介者模式的实现里面，是需要实现具体的交互功能的；而外观模式的实现里面，一般是组合调用或是转调内部实现的功能，通常外观模式本身并不实现这些功能。 中介者模式的目的主要是松散多个同事之间的耦合，把这些耦合关系全部放到中介者中去实现；而外观模式的目的是简化客户端的调用，这点和中介者模式也不同。 五、外观模式的优缺点使用外观模式的优点： 松散耦合外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 简单易用外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观交互就可以了，相当于外观类为外部客户端使用子系统提供了一站式服务。 更好地划分访问的层次通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是在系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好地隐藏了内部的细节。 使用外观模式的缺点 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。 六、总结Facade封装了子系统外部和子系统内部多个模块的交互过程，从而简化了外部的调用。通过外观，子系统为外部提供一些高层的接口，以方便它们的使用。 外观模式很好地体现了“最少知识原则”。 如果不使用外观模式，客户端通常需要和子系统内部的多个模块交互，也就是说客户端会和这些模块之间都有依赖关系，任意一个模块的变动都可能会引起客户端的变动。 使用外观模式后，客户端只需要和外观类交互，即只和这个外观类有依赖关系，不需要再去关心子系统内部模块的变动情况了。 这样一来，客户端不但简单，而且这个系统会更有弹性。当系统内部多个模块发生变化的时候，这个变化可以被这个外观类吸收和消化，并不需要影响到客户端，换句话说就是：可以在不影响客户端的情况下，实现系统内部的维护和扩展。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"外观模式,Java,设计模式","slug":"外观模式-Java-设计模式","permalink":"/tags/外观模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--中介者模式","slug":"Java设计模式之--中介者模式","date":"2020-05-24T09:01:24.000Z","updated":"2023-04-30T10:21:41.354Z","comments":true,"path":"2020/05/24/Java设计模式之--中介者模式/","link":"","permalink":"/2020/05/24/Java设计模式之--中介者模式/","excerpt":"","text":"一、什么是中介者模式中介者(Mediator)模式（亦被称为调停者模式）是一种对象的行为模式。用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式的本质：封装交互 设计意图：面向对象设计鼓励将行为分布到各个对象中。这种分布可能会导致多个对象之间需要相互交互，从而形成紧密耦合，不利于对象的修改和维护。在最坏的情况下,每一个对象都需要知道其他所有对象，如下图所示。 虽然将一个系统分割成许多对象通常可以增强可复用性，但是对象间相互连接的激增又会降低其可复用性。大量的相互连接使得一个对象似乎不太可能在没有其他对象的支持下工作—-系统表现为一个不可分割的整体。而且，对系统的行为进行任何较大的改动都十分困难，因为行为被分布在许多对象中。结果是：你可能不得不定义很多子类以定制系统的行为。 中介者模式通过引入一个中介对象，形成了一个以中介者为中心的星形结构，如下图所示。某一个对象不再通过直接的联系与另一个对象发生相互作用，而是让所有的对象都只和中介者对象进行交互，从而实现了对象之间的解耦。中介者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。 二、中介者模式的结构 中介者模式涉及的角色及其职责如下： 抽象中介者(Mediator)角色：一般定义为接口，用来定义各个同事之间交互需要的方法，可以是公共的通信方法，比如 changed()方法，大家都用，也可以是小范围的交互方法。 具体中介者(ConcreteMediator)角色：实现Mediator中定义的接口，它需要了解并维护各个同事对象，并负责具体的协调各同事对象的交互关系。 抽象同事(Colleague)角色：通常实现成为抽象类，主要负责约束同事对象的类型，并实现一些具体同事类之间的公共功能，比如，每个具体同事类都应该知道中介者对象，也就是具体同事类都会持有中介者对象，都可以定义到这个类里面。 具体同事(ConcreteColleague)角色：继承自Colleague，实现自己的业务，在需要与其他同事通信的时候，就与持有的中介者通信，中介者负责与他的同事交互。 中介者模式结构示意源代码如下：先来看看所有同事的父类的定义。 /** * 同事类的抽象父类 */ public abstract class Colleague { /** * 持有中介者对象，每一个同事类都知道它的中介者对象 */ private Mediator mediator; public Colleague(Mediator mediator) { this.mediator = mediator; } /** * 获取当前同事类对应的中介者对象 */ public Mediator getMediator() { return mediator; } } 再来看看具体的同事类，在示意中它们的实现是差不多的，示例代码如下。 /** * 具体的同事类A */ public class ConcreteColleagueA extends Colleague { public ConcreteColleagueA(Mediator mediator) { super(mediator); } public void someOperation() { // 在需要跟其他同事通信的时候，通知中介者对象 getMediator().changed(this); } } /** * 具体的同事类B */ public class ConcreteColleagueB extends Colleague { public ConcreteColleagueB(Mediator mediator){ super(mediator); } public void someOperation(){ //在需要跟其他同事通信的时候，通知中介者对象 getMediator().changed(this); } } 接下来看看中介者接口的定义，示例代码如下。 /** * 中介者，定义各个同事对象通信的接口 */ public interface Mediator { /** * 同事对象在自身改变的时候来通知中介者的方法，让中介者负责相应的与其他同事对象的交互 */ public void changed(Colleague colleague); } 最后来看看具体的中介者实现，示例代码如下。 /** * 具体的中介者实现 */ public class ConcreteMediator implements Mediator { /** * 持有并维护同事A */ private ConcreteColleagueA colleagueA; /** * 持有并维护同事B */ private ConcreteColleagueB colleagueB; /** * 设置中介者需要了解并维护的同事A对象 */ public void setConcreteColleagueA(ConcreteColleagueA colleagueA) { this.colleagueA = colleagueA; } /** * 设置中介者需要了解并维护的同事B对象 */ public void setConcreteColleagueB(ConcreteColleagueB colleagueB) { this.colleagueB = colleagueB; } @Override public void changed(Colleague colleague) { // 某个同事类发生了变化，通常需要与其他同事交互 // 具体协调相应的同事对象来实现协作行为 } } 三、中介者模式应用举例《研磨设计模式》中给出这么一个场景：使用电脑来看电影。在日常生活中，我们经常使用电脑来看电影，把这个过程描述出来，简化后假定会有如下的交互过程： 首先是光驱要读取光盘上的数据，然后告诉主板，它的状态改变了。 主板去得到光驱的数据，把这些数据交给CPU进行分析处理。 CPU处理完后，把数据分成了视频数据和音频数据，通知主板，它处理完了。 主板去得到CPU处理过后的数据，分别把数据交给显卡和声卡，去显示视频和播放声音。 如果使用调停者模式把这个过程描述出来，该如何具体实现呢？ 要使用调停者模式来实现示例，首先要区分出同事对象和调停者对象。很明显，主板是中介者，而光驱、声卡、CPU、显卡等配件，都是作为同事对象。 根据中介者模式的知识，设计出的程序类图结构如下。 下面来看看代码实现，会更清楚。 抽象同事类的定义跟标准的实现是差不多的，示例代码如下。 /** * 抽象同事类 */ public abstract class Colleague { // 持有一个中介者对象 private Mediator mediator; /** * 构造函数 */ public Colleague(Mediator mediator) { this.mediator = mediator; } /** * 获取当前同事类对应的中介者对象 */ public Mediator getMediator() { return mediator; } } 定义众多的同事类，示例代码如下。 /** * 光驱类，一个同事类 */ public class CDDriver extends Colleague { // 光驱读取出来的数据 private String data = &quot;&quot;; /** * 构造函数 */ public CDDriver(Mediator mediator) { super(mediator); } /** * 获取光盘读取出来的数据 */ public String getData() { return data; } /** * 读取光盘 */ public void readCD(String data) { // 逗号前是视频显示的数据，逗号后是声音 this.data = data; // 通知主板，自己的状态发生了改变 getMediator().changed(this); } } /** * CPU类，一个同事类 */ public class CPU extends Colleague { // 分解出来的视频数据 private String videoData = &quot;&quot;; // 分解出来的声音数据 private String audioData = &quot;&quot;; /** * 构造函数 */ public CPU(Mediator mediator) { super(mediator); } /** * 获取分解出来的视频数据 */ public String getVideoData() { return videoData; } /** * 获取分解出来的声音数据 */ public String getAudioData() { return audioData; } /** * 处理数据，把数据分成视频和音频的数据 */ public void processData(String data) { // 把数据分解开，前面是视频数据，后面是音频数据 String[] array = data.split(&quot;,&quot;); this.videoData = array[0]; this.audioData = array[1]; // 通知主板，CPU完成工作 getMediator().changed(this); } } /** * 显卡类，一个同事类 */ public class VideoCard extends Colleague { /** * 构造函数 */ public VideoCard(Mediator mediator) { super(mediator); } /** * 显示视频数据 */ public void display(String data) { System.out.println(&quot;您正在观看的是：&quot; + data); } } /** * 声卡类，一个同事类 */ public class AudioCard extends Colleague { /** * 构造函数 */ public AudioCard(Mediator mediator) { super(mediator); } /** * 播放音频数据 */ public void play(String data) { System.out.println(&quot;画外音：&quot; + data); } } 接下来看看抽象中介者的定义，此处仅定义一个让同事对象在自身改变的时候来通知中介者的接口，示例代码如下。 /** * 中介者接口 */ public interface Mediator { /** * 同事对象在自身改变的时候来通知中介者的方法 让中介者去负责相应的与其他同事对象的交互 */ public void changed(Colleague c); } 再来看看具体中介者的实现，示例代码如下。 /** * 主板类，实现中介者接口 */ public class MainBoard implements Mediator { // 需要知道要交互的同事类——光驱类 private CDDriver cdDriver = null; // 需要知道要交互的同事类——CPU类 private CPU cpu = null; // 需要知道要交互的同事类——显卡类 private VideoCard videoCard = null; // 需要知道要交互的同事类——声卡类 private AudioCard audioCard = null; public void setCdDriver(CDDriver cdDriver) { this.cdDriver = cdDriver; } public void setCpu(CPU cpu) { this.cpu = cpu; } public void setVideoCard(VideoCard videoCard) { this.videoCard = videoCard; } public void setAudioCard(AudioCard audioCard) { this.audioCard = audioCard; } @Override public void changed(Colleague c) { if (c instanceof CDDriver) { // 表示光驱已经读取数据了 this.afterCDDriverReadData((CDDriver) c); } else if (c instanceof CPU) { // 表示CPU已经处理数据了 this.afterCPUProcessData((CPU) c); } } /** * 光驱读取数据以后与其他对象的交互 */ private void afterCDDriverReadData(CDDriver cd) { // 先获取光驱读取的数据 String data = cd.getData(); // 把这些数据传递给CPU进行处理 cpu.processData(data); } /** * CPU处理完数据后与其他对象的交互 */ private void afterCPUProcessData(CPU cpu) { // 先获取CPU处理后的数据 String videoData = cpu.getVideoData(); String audioData = cpu.getAudioData(); // 把这些数据传递给显卡和声卡展示出来 videoCard.display(videoData); audioCard.play(audioData); } } 大功告成，在客户端中测试一下，示例代码如下。 public class Client { public static void main(String[] args) { // 创建中介者——主板 MainBoard mediator = new MainBoard(); // 创建同事类 CDDriver cdDriver = new CDDriver(mediator); CPU cpu = new CPU(mediator); VideoCard videoCard = new VideoCard(mediator); AudioCard audioCard = new AudioCard(mediator); // 让中介者知道所有同事 mediator.setCdDriver(cdDriver); mediator.setCpu(cpu); mediator.setVideoCard(videoCard); mediator.setAudioCard(audioCard); // 开始看电影，把光盘放入光驱，光驱开始读盘 cdDriver.readCD(&quot;东京热,真的好热！&quot;); } } 运行程序打印结果如下： 您正在观看的是：东京热画外音：真的好热！ 如上例所示，对于光驱对象、CPU对象、显卡对象和声卡对象，需要相互交互，虽然只是简单演示，但是也能看出来，它们的交互是比较麻烦的，于是定义一个中介者对象—-主板对象，来维护它们之间的交互关系，从而使得这些对象松散耦合。如果这个时候需要修改它们的交互关系，直接到中介者里面修改就好了，也就是说它们的关系已经独立封装到中介者对象里面了，可以独立地改变它们之间的交互关系，而不用去修改这些同事对象。 四、广义中介者在实际应用开发中，经常会使用简化版的中介者模式进行开发，被称为广义中介者，常有如下简化: 通常会去掉同事对象的父类，这样可以让任意的对象，只要需要相互交互，就可以成为同事。 通常不定义Mediator接口，把具体的中介者对象实现成为单例。 同事对象不再持有中介者，而是在需要的时候直接获取中介者对象并调用；中介者也不再持有同事对象，而是在具体处理方法里面去创建，或者获取，或者从参数传入需要的同事对象。 五、中介者模式的优缺点使用中介者模式的优点： 松散耦合中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。 集中控制交互多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。 多对多变成一对多没有使用中介者模式的时候，同事对象之间的关系通常是多对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对多，这会让对象的关系更容易理解和实现。 使用中介者模式的缺点： 中介者模式的一个潜在缺点是，过度集中化。如果同事对象的交互非常多，而且比较复杂，当这些复杂性全部集中到中介者的时候，会导致中介者对象变得十分复杂，而且难于管理和维护。 六、中介者模式的适用性在以下条件下可以考虑使用中介者模式： 如果一组对象之间的通信方式比较复杂，导致相互依赖、结构混乱，可以采用中介者模式，把这些对象相互的交互管理起来，各个对象都只需要和中介者交互，从而使得各个对象松散耦合，结构也更清晰易懂。 如果一个对象引用很多的对象，并直接跟这些对象交互，导致难以复用该对象，可以采用中介者模式，把这个对象跟其他对象的交互封装到中介者对象里面，这个对象只需要和中介者对象交互就可以了。 七、总结中介者模式通过引入一个中介对象，让其他的对象都只和中介对象交互，而中介对象知道如何和其他所有的对象交互，这样对象之间的交互关系就没有了，从而实现了对象之间的解耦。 对于中介对象而言，所有相互交互的对象，被视为同事类，中介对象就是来维护各个同事之间的关系，而所有的同事类都只是和中介对象交互。 每个同事对象，当自己发生变化的时候，不需要知道这会引起其他对象有什么变化，它只需要通知中介者就可以了，然后由中介者去与其他对象交互。这样松散耦合带来的好处是，除了让同事对象之间相互没有关联外，还有利于功能的修改和扩展。 有了中介者以后，所有的交互都封装到中介者对象里面，各个对象就不再需要维护这些关系了。扩展关系的时候也只需要扩展或修改中介者对象就可以了。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"中介者模式,Java,设计模式","slug":"中介者模式-Java-设计模式","permalink":"/tags/中介者模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--命令模式","slug":"Java设计模式之--命令模式","date":"2020-05-24T09:00:17.000Z","updated":"2023-04-30T10:21:41.357Z","comments":true,"path":"2020/05/24/Java设计模式之--命令模式/","link":"","permalink":"/2020/05/24/Java设计模式之--命令模式/","excerpt":"","text":"一、什么是命令模式命令(Command)模式又叫作动作(Action)模式或事务(Transaction)模式，是一种对象的行为模式。将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。 命令模式的本质：封装请求 设计意图：命令模式通过将请求封装到一个命令(Command)对象中，实现了请求调用者和具体实现者之间的解耦。 二、命令模式的适用性在以下条件下可以考虑使用命令模式： 如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式。将这些需要执行的动作抽象成为命令，然后实现命令的参数化配置。 如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式。将这些请求封装成为命令对象，然后实现将请求队列化。 如果需要支持取消操作，可以选用命令模式，通过管理命令对象，能很容易地实现命令的恢复和重做功能。 如果需要支持当系统崩溃时，能将系统的操作功能重新执行一遍，可以选用命令模式。将这些操作功能的请求封装成命令对象，然后实现日志命令，就可以在系统恢复以后，通过日志获取命令列表，从而重新执行一遍功能。 在需要事务的系统中，可以选用命令模式。命令模式提供了对事务进行建模的方法。命令模式有一个别名就是Transaction。 三、命令模式的结构 命令模式涉及的角色及其职责如下： 抽象命令(Command)角色：一般定义为接口，用来定义执行命令的接口。 具体命令(ConcreteCommand)角色：通常会持有接收者对象，并调用接收者对象的相应功能来完成命令要执行的操作。 接收者(Receiver)角色：真正执行命令的对象。任何类都可能成为接收者，只要它能够实现命令要求实现的相应功能。 调用者(Invoker)角色：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。 客户端(Client)角色：创建具体的命令对象，并且设置命令对象的接收者。 命令模式结构示意源代码如下：先来看看抽象命令接口的定义。示例代码如下： /** * 命令接口 */ public interface Command { /** * 执行命令 */ public void execute(); } 接下来看看具体命令是如何实现的。示例代码如下： /** * 具体的命令实现 */ public class ConcreteCommand implements Command { /** * 持有相应的接收者对象 */ private Receiver receiver = null; /** * 构造方法，传入相应的接收者对象 * * @param receiver 相应的接收者对象 */ public ConcreteCommand(Receiver receiver) { this.receiver = receiver; } /** * 执行命令 */ @Override public void execute() { // 通常会转调接收者对象的相应方法，让接收者来真正执行功能 receiver.action(); } } 再来看看接收者的定义。示例代码如下： /** * 命令的接收者 */ public class Receiver { /** * 示意方法，真正执行命令相应的操作 */ public void action() { System.out.println(&quot;接收者开始行动。。。&quot;); } } 下面该来看看调用者如何实现的了。示例代码如下： /** * 命令的调用者 */ public class Invoker { /** * 持有命令对象 */ private Command command = null; /** * 设置调用者持有的命令对象 * * @param command 命令对象 */ public void setCommand(Command command) { this.command = command; } /** * 示意方法，调用命令执行请求 */ public void invoke() { command.execute(); } } 再来看看客户端的实现。 public class Client { public static void main(String[] args) { // 创建接收者 Receiver receiver = new Receiver(); // 创建命令对象，设定它的接收者 Command command = new ConcreteCommand(receiver); // 创建调用者，把命令对象设置进去 Invoker invoker = new Invoker(); invoker.setCommand(command); // 调用者调用命令 invoker.invoke(); } } 四、命令模式的优点 更松散的耦合命令模式使得发起命令的对象——客户端，和具体实现命令的对象——接收者对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 更动态的控制命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 很自然的复合命令命令模式中的命令对象能够很容易地组合成复合命令，如宏命令，从而使系统操作更简单，功能更强大。 更好的扩展性由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 五、认识命令模式 参数化配置 所谓命令模式的参数化配置，指的是：可以用不同的命令对象，去参数化配置客户的请求。即：对于Invoker的同一个请求，为其配置不同的Command对象，就会执行不同的功能。 可撤销的操作 可撤销操作的意思就是：放弃该操作，回到未执行该操作前的状态。有两种基本的思路来实现可撤销的操作，一种是补偿式，又称反操作式，比如要撤销的操作是加的功能，那么可以用相反的操作即减的功能去实现，撤销加多少就减多少。使用命令模式可以实现补偿式的可撤销操作，首先需要把操作过的命令记录下来，形成命令的历史列表，撤销的时候就从最后一个开始执行撤销。同样的方式，还可以实现恢复的功能。另外一种实现可撤销操作的方式是存储恢复式，意思就是把操作前的状态记录下来，然后要撤销操作的时候就直接恢复回去就可以了（可以使用备忘录模式实现）。 宏命令 什么是宏命令呢？简单点说就是包含多个命令的命令，是一个命令的组合。以去饭店吃饭为例，一般的流程都是：选座位–&gt;点菜–&gt;上菜–&gt;享用美食–&gt;结账，如果将这几个步骤中涉及的命令打包一起执行的话，就可以看作是一个宏命令。 队列请求 所谓队列请求，就是对命令对象进行排队，组成命令队列，然后依次取出命令对象来执行。还是以去饭店吃饭为例，已经点菜的顾客可能有很多人，点的每一道菜都可以看成是一条命令（需要厨师去做菜，服务员上菜），这些被点的菜就构成了一个命令队列。厨师一般都会按照点菜的先后顺序去做菜，谁的菜先点，就先做谁的。 日志请求 所谓日志请求，就是把请求的历史纪录保存下来，一般是采用永久存储的方式。如果在运行请求的过程中，系统崩溃了，那么当系统再次运行时，就可以从保存的历史记录中获取日志请求，并重新执行命令。日志请求的实现有两种方案：一种是直接使用Java中的序列化方法；另外一种就是在命令对象中添加上存储和装载的方法，其实就是让命令对象自己实现类似序列化的功能。 六、总结命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"命令模式,Java,设计模式","slug":"命令模式-Java-设计模式","permalink":"/tags/命令模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--迭代器模式","slug":"Java设计模式之--迭代器模式","date":"2020-05-24T08:59:16.000Z","updated":"2023-04-30T10:21:41.363Z","comments":true,"path":"2020/05/24/Java设计模式之--迭代器模式/","link":"","permalink":"/2020/05/24/Java设计模式之--迭代器模式/","excerpt":"","text":"一、什么是迭代器模式迭代器(Iterator)模式又叫作游标(Cursor)模式，是一种对象的行为模式。提供一种方法顺序访问一个聚合（指一组对象的组合结构，如：Java中的集合、数组等）对象中各个元素，而又不需暴露该对象的内部表示。 迭代器模式的本质：控制访问聚合对象中的元素 设计意图：无须暴露聚合对象的内部实现，就能够访问到聚合对象中的各个元素。 二、迭代器模式的结构 迭代器模式涉及的角色及其职责如下： 抽象迭代器(Iterator)角色：一般定义为接口，用来定义访问和遍历元素的接口。 具体迭代器(ConcreteIterator)角色：实现对聚合对象的遍历，并跟踪遍历时的当前位置。 抽象聚合(Aggregate)角色：定义创建相应迭代器对象的接口。 具体聚合(ConcreteAggregate)角色：实现创建相应的迭代器对象。 迭代器模式结构示意源代码如下：先来看看抽象迭代器接口的定义。示例代码如下： /** * 迭代器接口，定义访问和遍历元素的操作 */ public interface Iterator { /** * 移动到聚合对象中第一个元素 */ public void first(); /** * 移动到聚合对象中下一个元素 */ public void next(); /** * 判断是否已经移动到聚合对象的最后一个元素 */ public boolean isDone(); /** * 获取迭代的当前元素 */ public Object currentItem(); } 接下来看看具体迭代器是如何实现的。示例代码如下： /** * 具体的迭代器实现类，不同的聚合对象所对应的迭代器实现是不一样的 以下示意的是数组聚合对象的迭代器 */ public class ConcreteIterator implements Iterator { /** * 持有被迭代的具体的聚合对象 */ private ConcreteAggregate aggregate; /** * 内部索引，记录当前迭代到的位置 */ private int index = -1; /** * 构造方法，传入被迭代的具体的聚合对象 * * @param aggregate 被迭代的具体的聚合对象 */ public ConcreteIterator(ConcreteAggregate aggregate) { this.aggregate = aggregate; } /** * 移动到聚合对象中第一个元素 */ @Override public void first() { index = 0; } /** * 移动到聚合对象中下一个元素 */ @Override public void next() { if (index &lt; this.aggregate.size()) { index += 1; } } /** * 判断是否已经移动到聚合对象的最后一个元素 */ @Override public boolean isDone() { if (index == this.aggregate.size()) { return true; } return false; } /** * 获取迭代的当前元素 */ @Override public Object currentItem() { return this.aggregate.get(index); } } 再来看看抽象聚合类的定义。示例代码如下： /** * 聚合对象的接口，定义创建相应的迭代器对象的接口 */ public abstract class Aggregate { /** * 工厂方法，创建相应的迭代器对象的接口 */ public abstract Iterator createIterator(); } 下面该来看看具体聚合类是如何实现的了，这里以数组聚合对象的迭代器实现为例。示例代码如下： /** * 具体的聚合对象，实现创建相应迭代器对象的功能 * */ public class ConcreteAggregate extends Aggregate { /** * 示意，表示聚合对象具体的内容 */ private String[] ss = null; /** * 构造方法，传入聚合对象具体的内容 * * @param ss 聚合对象具体的内容 */ public ConcreteAggregate(String[] ss) { super(); this.ss = ss; } /** * 工厂方法，创建相应的迭代器对象的接口 */ @Override public Iterator createIterator() { // 实现创建迭代器的工厂方法 return new ConcreteIterator(this); } /** * 根据索引位置，获取所对应的元素 */ public Object get(int index) { Object retObj = null; if (index &lt; ss.length) { retObj = ss[index]; } return retObj; } /** * 获取聚合对象的容量大小 */ public int size() { return this.ss.length; } } 在客户端中测试一下，示例代码如下。 public class Client { public void someOperation() { // 创建一个数组 String[] names = { &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot; }; // 创建聚合对象 ConcreteAggregate aggregate = new ConcreteAggregate(names); // 获取聚合对象的迭代器 Iterator iterator = aggregate.createIterator(); // 移动到聚合对象中第一个元素 iterator.first(); int index = 1; // 循环输出聚合对象中的值 while (!iterator.isDone()) { Object obj = iterator.currentItem(); System.out.println(&quot;聚合对象中第&quot; + (index++) + &quot;个元素是：&quot; + obj); iterator.next(); } } public static void main(String[] args) { Client client = new Client(); client.someOperation(); } } 运行程序打印结果如下： 聚合对象中第1个元素是：张三聚合对象中第2个元素是：李四聚合对象中第3个元素是：王五 从以上示例可以看出，迭代器模式为客户端提供了一个统一访问聚合对象的接口，通过这个接口就可以顺序地访问聚合对象的元素。对于客户端而言，只是面向这个接口在访问，根本不知道聚合对象内部的实现细节（聚合对象可以是集合，也可以是数组，客户端无从得知）。 使用迭代器模式，还可以实现很多更加丰富的功能。比如： 以不同的方式遍历聚合对象，比如向前、向后等。 对同一个聚合同时进行多个遍历。 以不同的遍历策略来遍历聚合，比如是否需要过滤等。 多态迭代，含义是：为不同的聚合结构提供统一的迭代接口，也就是说通过一个迭代接口可以访问不同的聚合结构。（多态迭代可能会带来类型安全的问题，可以考虑使用泛型） 三、翻页迭代在实际开发中，经常会碰到需要一次迭代多条数据的情况，比如常用的翻页功能。翻页功能有如下几种实现方式。 （1）纯数据库实现依靠SQL提供的功能实现翻页，用户每次请求翻页的数据，就会到数据库中获取相应的数据。 （2）纯内存实现就是一次性从数据库中把需要的所有数据都取出来放到内存中，然后用户请求翻页时，从内存中获取相应的数据。 两种方案各有优缺点： 第一种方案明显是时间换空间的策略，每次获取翻页的数据都要访问数据库，运行速度相对比较慢，而且很耗数据库资源，但是节省了内存空间。 第二种方案是典型的空间换时间，每次是直接从内存中获取翻页的数据，运行速度快，但是很耗内存。 （3）纯数据库实现+纯内存实现思路是这样的：如果每页显示10条记录，根据判断，用户很少翻到10页以后，那好，第一次访问的时候，就一次性从数据库中获取前10页的数据，也就是100条记录，把这100条记录放在内存里面。这样一来，当用户在前10页内进行翻页操作的时候，就不用再访问数据库了，而是直接从内存中获取数据，速度就快了。当用户想要获取第11页的数据时，才会再次访问数据库。 四、迭代器模式的适用性在以下条件下可以考虑使用迭代器模式： 如果你希望提供访问一个聚合对象的内容，但是又不想暴露它的内部表示的时候，可以使用迭代器模式来提供迭代器接口，从而让客户端只是通过迭代器的接口来访问聚合对象，而无须关心聚合对象的内部实现。 如果你希望有多种遍历方式可以访问聚合对象，可以使用迭代器模式。 如果你希望为遍历不同的聚合对象提供一个统一的接口，可以使用迭代器模式。 五、迭代器模式的优点更好的封装性 迭代器模式可以让你访问一个聚合对象的内容，而无须暴露该聚合对象的内部细节，从而提高聚合对象的封装性。 可以以不同的遍历方式来遍历一个聚合 使用迭代器模式，使得聚合对象的内容和具体的迭代算法分离开。这样就可以通过使用不同的迭代器的实例、不同的遍历方式来遍历一个聚合对象了。 实现功能分离、简化聚合的接口 有了迭代器的接口，则聚合对象只需要实现自身的基本功能，把迭代的功能委让给外部的迭代器去实现，实现了功能分离，符合“单一职责”原则。 简化客户端调用 迭代器为遍历不同的聚合对象提供了一个统一的接口，一方面方便调用；另一方面使得客户端不必关注迭代器的实现细节。 同一个聚合上可以有多个遍历 每个迭代器保持它自己的遍历状态，比如前面示例中的迭代索引位置，因此可以对同一个聚合对象同时进行多个遍历。 六、总结聚合对象的类型很多，如果对聚合对象的迭代访问跟聚合对象本身融合在一起的话，会严重影响到聚合对象的可扩展性和可维护性。 迭代器模式通过把对聚合对象的遍历和访问从聚合对象中分离出来，放入到单独的迭代器中，使得聚合对象变得简单；而且迭代器和聚合对象可以独立地变化和发展，大大加强了系统的灵活性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"迭代器模式,Java,设计模式","slug":"迭代器模式-Java-设计模式","permalink":"/tags/迭代器模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--模板方法模式","slug":"Java设计模式之--模板方法模式","date":"2020-05-24T08:58:19.000Z","updated":"2023-04-30T10:21:41.358Z","comments":true,"path":"2020/05/24/Java设计模式之--模板方法模式/","link":"","permalink":"/2020/05/24/Java设计模式之--模板方法模式/","excerpt":"","text":"一、什么是模板方法模式模板方法(TemplateMethod)模式是一种对象的行为模式。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 模版方法模式的本质：固定算法骨架 二、模板方法模式的结构 模板方法模式涉及的角色及其职责如下： 抽象类(AbstractClass)角色：用来定义算法骨架(template method)和原语操作(primitive operation)，具体的子类通过重定义这些原语操作来实现一个算法的各个步骤。在这个类里面，还可以提供算法中通用的实现(general operation)。 具体实现类(ConcreteClass)角色：用来实现算法骨架中的某些步骤，完成与实现类自身相关的某些功能。 模板方法模式结构示意源代码如下：先看看抽象类的写法，示例代码如下。 public abstract class AbstractClass { /** * 模板方法 */ public void templateMethod() { // 调用原语操作和通用操作 generalOperation(); primitiveOperationA(); primitiveOperationB(); } // 原语操作A，算法中的必要步骤，父类无法确定如何真正实现，需要子类来实现 public abstract void primitiveOperationA(); // 原语操作B，算法中的必要步骤，父类无法确定如何真正实现，需要子类来实现 public abstract void primitiveOperationB(); protected void generalOperation() { System.out.println(&quot;执行通用操作...&quot;); } } 再来看看具体实现类写法，示例代码如下。 /** * 具体实现类，实现原语操作，并可以添加与自身功能相关的其他操作 */ public class ConcreteClass extends AbstractClass { // 具体的实现 @Override public void primitiveOperationA() { System.out.println(&quot;执行原语操作A...&quot;); } // 具体的实现 @Override public void primitiveOperationB() { System.out.println(&quot;执行原语操作B...&quot;); } } 接下来看看客户端的示例，示意代码如下。 public class Client { public static void main(String[] args) { // 创建一个模板实例 AbstractClass abstractClass = new ConcreteClass(); // 执行实例的模板方法 abstractClass.templateMethod(); } } 运行程序打印结果如下： 执行通用操作…执行原语操作A…执行原语操作B… 三、模板方法模式相关知识点抽象类和接口： 接口是一种特殊的抽象类，所有接口中的属性自动是常量，也就是public final static的，而所有接口中的方法必须是抽象的。 抽象类，简单点说是用abstract修饰的类。这里要特别注意的是抽象类和抽象方法的关系，记住两句话：抽象类不一定包含抽象方法；有抽象方法的类一定是抽象类。 抽象类和接口相比较，最大的特点就在于抽象类中是可以有具体的实现方法的，而接口中所有的方法都是没有具体的实现的。 通常在“既要约束子类的行为，又要为子类提供公共功能”的时候使用抽象类。 变与不变： 程序设计的一个很重要的思考点就是“变与不变”，也就是分析程序中哪些功能是可变的，哪些功能是不变的，然后把不变的部分抽象出来，进行公共的实现，把变化的部分分离出去，用接口来封装隔离，或者是用抽象类来约束子类行为。 模板方法模式很好地体现了这一点。模板类实现的就是不变的方法和算法的骨架，而需要变化的地方，都通过抽象方法，把具体实现延迟到子类中了，而且还通过父类的定义来约束了子类的行为，从而使系统能有更好的复用性和扩展性。 好莱坞法则： 什么是好莱坞法则呢？简单点说，就是“不要找我们， 我们会联系你”。 模板方法模式很好地体现了这一点。作为父类的模板会在需要的时候，调用子类相应的方法，也就是由父类来找子类，而不是让子类来找父类。 这其实也是一种反向的控制结构。按照通常的思路，是子类找父类才对，也就是应该子类来调用父类的方法，因为父类根本就不知道子类，而子类是知道父类的，但是在模板方法模式里面，是父类来找子类，所以是一种反向的控制结构。 “后期绑定”技术： 在Java语言中，对于出现子类覆盖父类方法的情况，在编译时是看数据类型，运行时则看实际的对象类型（new谁就调用谁的方法）。 在使用模板方法模式的时候，虽然用的数据类型是模板类型，但是在创建类实例的时候是创建的具体的子类的实例，在调用的时候，会被动态绑定到子类的方法上，从而实现反向控制。其实在写父类的时候，它调用的方法是父类自己的抽象方法，只是在运行的时候被动态绑定到了子类的方法上。 四、模板方法模式的适用性在面向对象系统的分析与设计过程中经常会遇到这样一种情况： 对于某一个业务逻辑（算法实现）在不同的对象中有不同的细节实现， 但是逻辑（算法）的框架（或通用的应用算法）是相同的。模板方法提供了这种情况的一个实现框架。 模版方法模式是采用继承的方式实现这一点： 将逻辑（算法）框架放在抽象基类中， 并定义好细节的接口，子类中实现细节。 策略模式解决的是和模板方法模式类似的问题， 但是策略模式是将逻辑（算法）封装到一个类中，并采取组合（委托）的方式解决这个问题。 模板方法应用于下列情况： 固定定义算法骨架，实现一个算法的不变的部分，并把可变的行为留给子类来实现。 各子类中具有公共行为，应被提取出来，集中到一个公共父类中去实现，以避免代码重复，即“重分解以一般化”。 控制子类扩展。模板方法模式只在特定点调用子类的方法，这样就只允许在这些点进行扩展。 五、模板方法模式的优缺点使用模板方法模式的优点： 模板方法模式是一种实现代码复用的很好的手段。通过把子类的公共功能提炼和抽取，把公共部分放到模板中去实现。 使用模板方法模式的缺点： 模板方法模式最基本的功能就是通过模板的制定，把算法骨架完全固定下来。事实上模板和子类是非常耦合的，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。所以抽象算法骨架的时候要特别小心，尽量确保是不会变化的部分才放到模板中。 六、总结模板方法模式主要是通过制定模板，把算法步骤固定下来，至于谁来实现，模板可以自己提供实现，也可以由子类去实现，还可以通过回调机制让其他类来实现。 通过固定算法骨架来约束子类的行为，并在特定的扩展点来让子类进行功能扩展，从而让程序既有很好的复用性，又有较好的扩展性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"模板方法模式,Java,设计模式","slug":"模板方法模式-Java-设计模式","permalink":"/tags/模板方法模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--状态模式","slug":"Java设计模式之--状态模式","date":"2020-05-24T08:57:11.000Z","updated":"2023-04-30T10:21:41.359Z","comments":true,"path":"2020/05/24/Java设计模式之--状态模式/","link":"","permalink":"/2020/05/24/Java设计模式之--状态模式/","excerpt":"","text":"一、什么是状态模式状态(State)）模式，又称状态对象(Pattern of Objects for States)模式，是一种对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。 状态模式的本质：根据状态来分离和选择行为 二、状态模式的结构 状态模式涉及的角色及其职责如下： 环境(Context)角色:也称上下文,通常用来定义客户端感兴趣的接口，同时维护一个来具体处理当前状态的对象示例。 抽象状态(State)角色：定义一个接口，用来封装与环境（Context）对象的一个特定的状态所对应的行为。 具体状态(ConcreteState)角色：每一个具体状态类都实现了一个跟环境（Context）相关的状态的具体处理。 状态模式结构示意源代码如下： /** * 抽象状态(State)角色，用来封装与环境（Context）对象的一个特定的状态所对应的行为 */ public interface State { /** * 状态对应的处理 * * @param sampleParameter 示例参数 */ public void handle(String sampleParameter); } /** * 具体状态(ConcreteState)角色，实现一个与Context的一个特定状态相关的行为 */ public class ConcreteStateA implements State { @Override public void handle(String sampleParameter) { // 实现具体的处理 } } /** * 具体状态(ConcreteState)角色，实现一个与Context的一个特定状态相关的行为 */ public class ConcreteStateB implements State { @Override public void handle(String sampleParameter) { // 实现具体的处理 } } /** * 环境(Context)角色 */ public class Context { // 持有一个State类型的对象实例 private State state; public void setState(State state) { this.state = state; } public void request(String sampleParameter) { // 处理操作，会转调State来处理 state.handle(sampleParameter); } } 三、状态模式应用举例《研磨设计模式》中给出这么一个场景：实现在线投票。 考虑一个在线投票的应用，要实现控制同一个用户只能投一票，如果一个用户重复投票，而且投票次数超过5次，则判定为恶意刷票，要取消该用户投票的资格，当然同时也要取消他所投的票；如果一个用户的投票次数超过8次，将进入黑名单，禁止再登录和使用系统。 以上功能我们使用状态模式来实现： 首先需要把投票过程的各种状态定义出来，根据以上描述大致分为四种状态：正常投票、重复投票、恶意刷票、进入黑名单。 设计好的程序结构如图所示： 先来看看状态接口的代码实现，示例代码如下。 public interface VoteState { /** * 处理状态对应的行为 * * @param user * 投票人 * @param voteItem * 投票项 * @param voteManager * 投票上下文，用来在实现状态对应的功能处理的时候， 可以回调上下文的数据 */ public void vote(String user, String voteItem, VoteManager voteManager); } 接下来看看各个状态对应的处理，示例代码如下。 /** * 正常投票状态 */ public class NormalVoteState implements VoteState { @Override public void vote(String user, String voteItem, VoteManager voteManager) { // 正常投票，记录到投票记录中 voteManager.getMapVote().put(user, voteItem); System.out.println(&quot;恭喜您，投票成功。&quot;); } } /** * 重复投票状态 */ public class RepeatVoteState implements VoteState { @Override public void vote(String user, String voteItem, VoteManager voteManager) { // 重复投票，此处仅打印一个警告作为示意 System.out.println(&quot;警告：请不要重复投票!&quot;); } } /** * 恶意刷票状态 */ public class SpiteVoteState implements VoteState { @Override public void vote(String user, String voteItem, VoteManager voteManager) { // 恶意投票，取消用户的投票资格，并取消投票记录 String str = voteManager.getMapVote().get(user); if (str != null) { voteManager.getMapVote().remove(user); } System.out.println(&quot;你有恶意刷屏行为，取消投票资格！&quot;); } } /** * 黑名单状态 */ public class BlackVoteState implements VoteState { @Override public void vote(String user, String voteItem, VoteManager voteManager) { // 记录在黑名单中，禁止登录系统 System.out.println(&quot;提示：您已进入投票黑名单，禁止登录和使用本系统！&quot;); } } 最后看看投票管理，相当于状态模式中的上下文，示例代码如下。 import java.util.HashMap; import java.util.Map; public class VoteManager { // 持有状体处理对象实例 private VoteState state = null; // 记录用户投票的结果，Map&lt;String,String&gt;对应Map&lt;用户名称，投票的选项&gt; private Map&lt;String, String&gt; mapVote = new HashMap&lt;String, String&gt;(); // 记录用户投票次数，Map&lt;String,Integer&gt;对应Map&lt;用户名称，投票的次数&gt; private Map&lt;String, Integer&gt; mapVoteCount = new HashMap&lt;String, Integer&gt;(); /** * 获取用户投票结果的Map */ public Map&lt;String, String&gt; getMapVote() { return mapVote; } /** * 投票 * * @param user * 投票人 * @param voteItem * 投票的选项 */ public void vote(String user, String voteItem) { // 1.为该用户增加投票次数 // 从记录中取出该用户已有的投票次数 Integer oldVoteCount = mapVoteCount.get(user); if (oldVoteCount == null) { oldVoteCount = 0; } oldVoteCount += 1; mapVoteCount.put(user, oldVoteCount); // 2.判断该用户的投票类型，就相当于判断对应的状态 // 到底是正常投票、重复投票、恶意投票还是上黑名单的状态 if (oldVoteCount == 1) { state = new NormalVoteState(); } else if (oldVoteCount &gt; 1 &amp;&amp; oldVoteCount &lt; 5) { state = new RepeatVoteState(); } else if (oldVoteCount &gt;= 5 &amp;&amp; oldVoteCount &lt; 8) { state = new SpiteVoteState(); } else if (oldVoteCount &gt; 8) { state = new BlackVoteState(); } // 3.然后转调状态对象来进行相应的操作 state.vote(user, voteItem, this); } } 写个客户端来测试一下，示例代码如下。 public class Client { public static void main(String[] args) { // 创建一个投票管理对象实例 VoteManager vm = new VoteManager(); // 通过一个循环操作来模仿用户连续投票9次的行为 for (int i = 0; i &lt; 9; i++) { vm.vote(&quot;u1&quot;, &quot;A&quot;); } } } 运行程序打印结果如下： 恭喜您，投票成功。警告：请不要重复投票!警告：请不要重复投票!警告：请不要重复投票!你有恶意刷屏行为，取消投票资格！你有恶意刷屏行为，取消投票资格！你有恶意刷屏行为，取消投票资格！你有恶意刷屏行为，取消投票资格！提示：您已进入投票黑名单，禁止登录和使用本系统！ 四、理解状态模式状态和行为所谓对象的状态，通常指的就是对象实例的属性的值；而行为指的就是对象的功能，再具体点说，行为大多可以对应到方法上。 状态模式的功能就是分离状态的行为，通过维护状态的变化，来调用不同状态对应的不同功能。也就是说，状态和行为是相关联的，它们的关系可以描述为：状态决定行为。 由于状态是在运行期间被改变的，因此行为也会在运行期间根据状态的改变而改变，看起来，同一个对象，在不同的运行时刻，行为是不一样的，就像是类被修改了一样。 行为的平行性注意平行性而不是平等性。所谓平行性指的是各个状态的行为所处的层次是一样的，相互独立的、没有关联的，是根据不同的状态来决定到底走平行线的哪一条。行为是不同的，当然对应的实现也是不同的，相互之间是不可替换的，如下图所示。 而平等性强调的是可替换性，大家是同一行为的不同描述或实现，因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理，如下图所示。 大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，状态模式的行为是平行性的，不可相互替换的；而策略模式的行为是平等性的，是可以相互替换的。 环境和状态处理对象在状态模式中，环境(Context)是持有状态的对象，但是环境自身并不处理跟特定的状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 在具体的状态处理类中经常需要获取环境自身的数据，甚至在必要的时候会回调环境的方法，因此，通常将环境自身当作一个参数传递给具体的状态处理类。 客户端一般只和环境交互。客户端可以用状态对象来配置一个环境，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。 五、状态模式的适用性在以下条件下可以考虑使用状态模式： 一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变它的行为。 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。 六、状态模式的优缺点使用状态模式的优点： 简化应用逻辑控制状态模式使用单独的类来封装一个状态的处理，可以把负责逻辑控制的代码分散到单独的状态类中去，这样就把着眼点从执行状态提高到整个对象的状态，使得代码结构化和意图更清晰，从而简化应用的逻辑控制。 更好地分离状态和行为状态模式通过设置所有状态类的公共接口，把状态和状态对应的行为分离开，把所有与一个特定的状态相关的行为都放入一个对象中，使得应用程序在控制的时候，只需要关心状态的切换，而不用关心这个状态对应的真正处理。 更好的扩展性引入了状态处理的公共接口后，使得扩展新的状态变得非常容易，只需要新增加一个实现状态处理的公共接口的实现类，然后在进行状态维护的地方，设置状态变化到这个新的状态即可。 显式化进行状态转换状态模式为不同的状态引入独立的对象，使得状态的转换变得更加明确。而且状态对象可以保证上下文不会发生内部状态不一致的情况，因为上下文中只有一个变量来记录状态对象，只要为这一个变量赋值就可以了。 使用状态模式的缺点：一个状态对应一个状态处理类，会使得程序引入太多的状态类，这样程序变得杂乱。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"状态模式,Java,设计模式","slug":"状态模式-Java-设计模式","permalink":"/tags/状态模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--组合模式","slug":"Java设计模式之--组合模式","date":"2020-05-24T08:56:11.000Z","updated":"2023-04-30T10:21:41.360Z","comments":true,"path":"2020/05/24/Java设计模式之--组合模式/","link":"","permalink":"/2020/05/24/Java设计模式之--组合模式/","excerpt":"","text":"一、什么是组合模式组合(Composite)模式是一种对象的行为模式。将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。 组合模式的本质：统一叶子对象和组合对象 组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。 二、组合模式的适用性在开发中， 我们经常可能要递归构建树状的组合结构，比如以下的商品类别树： 仔细观察上面的商品类别树，有以下几个明显的特点。 有一个根节点，比如“服装”，它没有父节点，它可以包含其他的节点。 树枝节点，有一类节点可以包含其他的节点，称之为树枝节点，比如“男装”、“女装”和“母婴”。 叶子节点，有一类节点没有子节点，称之为叶子节点，比如“衬衣”、“夹克”、“裙子”、“套装”等。 如果碰到类似上面这种，需使用对象树来描述或实现的功能，都可以考虑使用组合模式，比如读取XML文件，或是对语句进行语法解析等。 三、组合模式的结构 组合模式涉及的角色及其职责如下： 抽象组件(Component)角色：为组合对象和叶子对象声明公共的接口，让客户端可以通过这个接口来访问和管理整个对象树，并可以为这些定义的接口提供缺省的实现。 组合对象(Composite)角色：通常会存储子组件(组合对象、叶子对象)，定义包含子组件的那些组件的行为，并实现在抽象组件中定义的与子组件有关的操作，例如子组件的添加(addChild)和删除(removeChild)等。 叶子对象(Leaf)角色：定义和实现叶子对象的行为，并且它不再包含其他的子节点对象。 客户端(Client)角色：通过Component接口来统一操作组合对象和叶子对象，以创建出整个对象树结构。 组合模式结构示意源代码如下：先看看抽象组件类的定义，示例代码如下。 /** * 抽象的组件对象，为组合中的对象声明接口，实现接口的缺省行为 */ public abstract class Component { // 示意方法，子组件对象可能有的功能方法 public abstract void someOperation(String preStr); public void addChild(Component child) { // 缺省的实现，抛出异常，因为叶子对象没有这个功能，或子类未实现这个功能 throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } public void removeChild(Component child) { // 缺省的实现，抛出异常，因为叶子对象没有这个功能，或子类未实现这个功能 throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } public Component getChildren(int index) { // 缺省的实现，抛出异常，因为叶子对象没有这个功能，或子类未实现这个功能 throw new UnsupportedOperationException(&quot;对象不支持此功能&quot;); } } 接下来看看组合类的定义，示意代码如下。 import java.util.ArrayList; import java.util.List; public class Composite extends Component { /** * 示意属性，组件的名字 */ private String name = &quot;&quot;; public Composite(String name) { this.name = name; } /** * 用来存储组合对象中包含的子组件对象 */ private List&lt;Component&gt; childComponents = null; /** * 示意方法，此处用于输出组件的树形结构，通常在里面需要实现递归的调用 */ @Override public void someOperation(String preStr) { // 先把自己输出 System.out.println(preStr + &quot;+&quot; + name); // 如果还包含其他子组件，那么就输出这些子组件对象 if (null != childComponents) { // 添加一个空格，表示向后缩进一个空格 preStr += &quot; &quot;; // 输出当前对象的子组件对象 for (Component component : childComponents) { // 递归地进行子组件相应方法的调用，输出每个子组件对象 component.someOperation(preStr); } } } /** * 向组合对象中添加组件对象 */ public void addChild(Component child) { // 延迟初始化 if (null == childComponents) { childComponents = new ArrayList&lt;Component&gt;(); } childComponents.add(child); } /** * 从组合对象中移除组件对象 */ public void removeChild(Component child) { if (null != childComponents) { childComponents.remove(child); } } /** * 根据索引获取组合对象中对应的组件对象 */ public Component getChildren(int index) { if (null != childComponents) { if (index &gt;= 0 &amp;&amp; index &lt; childComponents.size()) { return childComponents.get(index); } } return null; } } 再来看看叶子类的定义，示例代码如下。 public class Leaf extends Component { /** * 示意属性，组件的名字 */ private String name = &quot;&quot;; public Leaf(String name) { this.name = name; } /** * 示意方法，此处用于输出组件的树形结构 */ @Override public void someOperation(String preStr) { System.out.println(preStr + &quot;-&quot; + name); } } 在客户端中使用Component接口来操作组合对象结构，示意代码如下。 public class Client { public static void main(String[] args) { // 定义多个Composite组合对象 Component root = new Composite(&quot;服装&quot;); Component c1 = new Composite(&quot;男装&quot;); Component c2 = new Composite(&quot;女装&quot;); Component c3 = new Composite(&quot;母婴&quot;); // 定义多个Leaf叶子对象 Component leaf1 = new Leaf(&quot;西服&quot;); Component leaf2 = new Leaf(&quot;夹克&quot;); Component leaf3 = new Leaf(&quot;衬衫&quot;); Component leaf4 = new Leaf(&quot;裙子&quot;); Component leaf5 = new Leaf(&quot;套装&quot;); Component leaf6 = new Leaf(&quot;鞋袜&quot;); Component leaf7 = new Leaf(&quot;孕妇装&quot;); Component leaf8 = new Leaf(&quot;婴儿装&quot;); // 组合成为树形的对象结构 root.addChild(c1); root.addChild(c2); root.addChild(leaf6); c1.addChild(leaf1); c1.addChild(leaf2); c1.addChild(leaf3); c2.addChild(leaf4); c2.addChild(leaf5); c2.addChild(c3); c3.addChild(leaf7); c3.addChild(leaf8); // 调用根对象的输出功能输出整棵树 root.someOperation(&quot;&quot;); } } 运行程序打印结果如下： +服装&emsp;&emsp;+男装&emsp;&emsp;&emsp;&emsp;-西服&emsp;&emsp;&emsp;&emsp;-夹克&emsp;&emsp;&emsp;&emsp;-衬衫&emsp;&emsp;+女装&emsp;&emsp;&emsp;&emsp;-裙子&emsp;&emsp;&emsp;&emsp;-套装&emsp;&emsp;&emsp;&emsp;+母婴&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-孕妇装&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-婴儿装&emsp;&emsp;-鞋袜 从以上的示例可以看出，组合模式的关键就在于抽象组件角色，作为组合对象和叶子对象的父类，这个抽象组件类既可以代表叶子对象，也可以代表组合对象，这样用户在操作的时候，始终是在操作组件对象，不必再去区分是在操作组合对象还是叶子对象，从而使得对叶子对象和组合对象的使用具有了一致性。 四、组合模式的安全性和透明性 组合模式的安全性是指：从客户使用组合模式上看是否更安全。如果是安全的，那么就不会有发生误操作的可能，能访问的方法都是被支持的功能。 组合模式的透明性是指：从客户使用组合模式上看是否需要区分到底是组合对象还是叶子对象。如果是透明的，那就不用再区分，对于客户而言，都是组件对象，具体的类型对于客户而言是透明的，是客户无须关心的。 透明性的实现： 如果把管理子组件的操作定义在Component中，那么客户端只需要面对Component，而无须关心具体的组件类型，这种实现方式就是透明性的实现。前面结构示意代码中就是采用的这一实现方式。 但是透明性的实现是以安全性为代价的，因为在Component中定义的一些方法，对于叶子对象来说是没有意义的，比如增加、删除子组件对象。但这些方法对客户却是透明的，因此客户可能会对叶子对象调用这种增加或删除子组件的方法，这样的操作是不安全的。 组合模式的透明性实现，通常的方式是：在Component中声明管理子组件的操作，并在Component中为这些方法提供默认的实现，对于叶子对象不支持的功能，可以直接抛出一个异常，来表示不支持这个功能。 安全性的实现： 如果把管理子组件的操作定义在Composite中，那么客户端在使用叶子对象的时候，就不会发生使用添加子组件或是删除子组件的操作了，因为压根就没有这样的功能，这种实现方式是安全的。 但是这样一来，客户端在使用的时候，就必须区分到底使用的是Composite对象，还是叶子对象，不同对象的功能是不一样的。 两种实现方式的选择： 对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。 因此，在使用组合模式的时候，应多采用透明性的实现方式，少用安全性的实现方式。 五、组合模式的优缺点使用组合模式的优点： 统一了组合对象和叶子对象。 简化了客户端调用，无须区分操作的是组合对象还是叶子对象。 更容易扩展，有了Component的约束，新定义的Composite或Leaf子类能够很容易地与已有的结构一起工作。 使用组合模式的缺点： 很难限制组合中的组件类型。 六、总结组合模式通过把叶子对象当成特殊的组合对象看待，从而对叶子对象和组合对象一视同仁，全部当成了Component对象，有机地统一了叶子对象和组合对象。 正是因为统一了叶子对象和组合对象，在将对象构建成树形结构的时候，才不需要做区分，反正是组件对象里面包含其他的组件对象，如此递归下去：也才使得对于树形结构的操作变得简单，不管对象类型，统一操作。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"组合模式,Java,设计模式","slug":"组合模式-Java-设计模式","permalink":"/tags/组合模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--备忘录模式","slug":"Java设计模式之--备忘录模式","date":"2020-05-24T08:54:51.000Z","updated":"2023-04-30T10:21:41.357Z","comments":true,"path":"2020/05/24/Java设计模式之--备忘录模式/","link":"","permalink":"/2020/05/24/Java设计模式之--备忘录模式/","excerpt":"","text":"一、什么是备忘录模式备忘录(Memento)模式又叫作快照(Snapshot)模式或Token模式，是一种对象的行为模式。在备忘录模式里，一个备忘录是一个对象，它存储另一个对象（备忘录的原发器）在某个瞬间的内部状态。备忘的目的就是为了以后在需要的时候，可以将原发器对象的状态恢复（undo/rollback）到备忘录所保存的状态。 备忘录的本质：保存和恢复状态 设计意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复（undo/rollback）到原先保存的状态了。 二、备忘录模式的结构 备忘录模式涉及的角色及其职责如下： 原发器(Originator)角色：原发器根据需要决定将自己的哪些内部状态保存到备忘录中，并可以使用备忘录来恢复内部状态。 备忘录(Memento)角色：负责存储原发器对象的内部状态，但是具体需要存储哪些状态是由原发器对象来决定的。另外备忘录应该只能由原发器对象来访问它内部的数据，原发器外部的对象不应该访问到备忘录对象的内部数据。 &emsp;&emsp;为了控制对备忘录对象的访问，备忘录模式中出现了窄接口和宽接口的概念。 窄接口：管理者只能看到备忘录的窄接口，窄接口的实现中通常没有任何的方法，只是一个类型标识。窄接口使得管理者只能将备忘录传递给其他对象。 宽接口：原发器能够看到备忘录的宽接口，从而可以从备忘录中获取到所需的数据，来将自己恢复到备忘录中所保存的状态。理想情况是：只允许生成备忘录的原发器来访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类。 管理者(Caretaker)角色:备忘录管理者，或者称为备忘录负责人。主要负责保存好备忘录对象，但是不能对备忘录对象的内容进行操作或检查。 备忘录模式结构示意源代码如下：先来看看备忘录窄接口的定义。 /** * 备忘录的窄接口，没有任何方法定义 */ public interface Memento { } 再看看原发器角色，它里面会有备忘录对象的实现，此处将真正的备忘录对象当作原发器对象的一个私有内部类来实现。示例代码如下： public class Originator { /** * 示意，表示原发器的状态 */ private String state = &quot;&quot;; /** * 创建备忘录，保存原发器的状态 * * @return 创建好的备忘录对象 */ public Memento createMemento() { return new MementoImpl(state); } /** * 将原发器恢复到备忘录中保存的状态 * * @param 保存有原发器状态的备忘录对象 */ public void recoverFromMemento(Memento memento) { MementoImpl mementoImpl = (MementoImpl) memento; this.state = mementoImpl.getState(); } public String getState() { return state; } public void setState(String state) { this.state = state; } /** * 真正的备忘录对象，实现了备忘录窄接口 实现成私有的内部类，不让外部访问 */ private static class MementoImpl implements Memento { /** * 示意，表示需要保存的状态 */ private String state = &quot;&quot;; public MementoImpl(String state) { super(); this.state = state; } public String getState() { return state; } } } 接下来是备忘录管理者的示例代码。 public class Caretaker { /** * 记录被保存的备忘录对象 */ private Memento memento = null; public Memento getMemento() { return memento; } public void setMemento(Memento memento) { this.memento = memento; } } 创建一个客户端来测试一下，示例代码如下。 public class Client { public static void main(String[] args) { // 创建一个原发器 Originator o = new Originator(); // 设置其初始状态 o.setState(&quot;state 0&quot;); // 打印原发器当前的状态 System.out.println(&quot;原发器的初始状态：&quot; + o.getState()); // 将原发器当前的状态保存到备忘录中 Memento memento = o.createMemento(); // 创建一个管理者 Caretaker c = new Caretaker(); // 将创建好的备忘录交给管理者进行管理 c.setMemento(memento); // 改变原发器的状态 o.setState(&quot;state 1&quot;); // 打印原发器当前的状态 System.out.println(&quot;原发器改變后状态：&quot; + o.getState()); // 将原发器状态恢复到备忘录保存的状态 o.recoverFromMemento(c.getMemento()); // 再次打印原发器当前的状态 System.out.println(&quot;原发器恢復后状态：&quot; + o.getState()); } } 运行程序打印结果如下： 原发器的初始状态：state 0原发器改變后状态：state 1原发器恢復后状态：state 0 在备忘录模式中，备忘录对象通常用来记录原发器中需要保存的内部状态，为了不破坏原发器对象的封装性，一般只让原发器自己来操作它的备忘录对象。为了保证这一点，通常会把备忘录对象作为原发器对象的内部类来实现，而且实现成私有的，这样就断了外部来访问这个备忘录对象的途径。 把备忘录对象设计成为一个私有的内部类，外部只能通过备忘录对象的窄接口来获取备忘录对象，而这个接口没有任何方法，仅仅起到了一个标识对象类型的作用，从而保证内部的数据不会被外部获取或是操作，保证了原发器对象的封装性，也就不再暴露原发器对象在内部结构了。 三、备忘录模式的适用性在以下条件下可以考虑使用备忘录模式： 如果必须保存一个对象在某一个时刻的全部或部分状态，方便在以后需要的时候，可以把该对象恢复到先前的状态。 如果需要保存一个对象的内部状态，但是如果用接口来让其它对象直接得到这些需要保存的状态，将会暴露对象的实现细节并破坏对象的封装性，这时可以使用备忘录模式，把备忘录对象实现成为原发器对象的私有内部类，从而保证只有原发器对象才能访问该备忘录对象。这样既保存了需要保存的状态，又不会暴露原发器对象的内部实现细节。 四、备忘录模式的实现 增量存储：如果需要频繁地创建备忘录对象，而且创建和应用备忘录对象来恢复状态的顺序是可控的，那么可以让备忘录进行增量存储，也就是备忘录可以仅仅存储原发器内部相对于上一次存储状态后的增量改变。 结合原型模式：在原发器对象创建备忘录对象的时候，如果原发器对象中全部或者大部分的状态都需要保存，一个简洁的方式就是直接克隆一个原发器对象。 离线存储：备忘录的数据可以实现成为离线存储，除了存储在内存中，还可以把备忘录数据存储到文件中、XML中、数据库中，从而支持跨越会话的备份和恢复功能。 五、备忘录模式的优缺点使用备忘录模式的优点： 更好的封装性备忘录模式通过使用备忘录对象，来封装原发器对象的内部状态，虽然这个对象是保存在原发器对象的外部，但是由于备忘录对象的窄接口并不提供任何方法。这样有效地保证了对原发器对象内部状态的封装，不把原发器对象的内部实现细节暴露给外部。 简化了原发器在备忘录模式中，原发器不再需要管理和保存其内部状态的一个个版本，而是交由管理者或客户端对这些状态的版本进行管理，从而让原发器对象得到简化。 窄接口和宽接口备忘录模式，通过引入窄接口和宽接口，使得不同的地方，对备忘录对象的访问是不一样的。窄接口保证了只有原发器才可以访问备忘录对象存储的状态。 使用备忘录模式的缺点： 标准的备忘录模式的实现机制是依靠缓存来实现的，因此，当需要备忘的数据量较大时，或者是存储的备忘录对象数据量不大但是数量很多的时候，或者是用户很频繁地创建备忘录对象的时候，这些都会导致非常大的开销。 管理者负责维护备忘录，然而，管理者并不知道备忘录中有多少个状态。因此当存储备忘录时，一个本来很小的管理者，可能会产生大量的存储开销。 六、总结备忘录模式的功能，首先是在不破坏封装性的前提下，捕获一个对象的内部状态。这里要注意两点，一个是不破坏封装性，也就是对象不能暴露它不应该暴露的细节；另外一个是捕获的是对象的内部状态，而且通常还是运行期间某个时刻对象的内部状态。 之所以要捕获这些内部状态，是为了在以后的某个时候，可以将该对象的状态恢复到备忘录所保存的状态，这才是备忘录真正的目的。前面保存状态就是为了后面恢复，虽然不是一定要恢复，但是目的是为了恢复。 在备忘录模式中，备忘录对象通常用来记录原发器中需要保存的内部状态，为了不破坏原发器对象的封装性，一般只让原发器自己来操作它的备忘录对象。为了保证这一点，通常会把备忘录对象作为原发器对象的内部类来实现，而且实现成私有的，这样就断了外部来访问这个备忘录对象的途径。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"备忘录模式,Java,设计模式","slug":"备忘录模式-Java-设计模式","permalink":"/tags/备忘录模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--职责链模式","slug":"Java设计模式之--职责链模式","date":"2020-05-24T08:53:40.000Z","updated":"2023-04-30T10:21:41.360Z","comments":true,"path":"2020/05/24/Java设计模式之--职责链模式/","link":"","permalink":"/2020/05/24/Java设计模式之--职责链模式/","excerpt":"","text":"一、什么是职责链模式职责链(Chain of Responsibility)模式是一种对象的行为模式。在职责链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配职责。 职责链模式的本质：分离职责、动态组合 设计意图：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 二、职责链模式的结构 职责链模式涉及的角色及其职责如下： 抽象处理者(Handler)角色：定义职责的接口，通常在这里定义处理请求的方法，如果需要，接口可以定义出一个方法以设定和返回对后继处理者的引用。 具体处理者(ConcreteHandler)角色：实现职责的类，在这个类中，实现对在它职责范围内请求的处理，如果不处理，就继续转发请求给后继处理者。 客户端(Client)角色：职责链的客户端，向链上的具体处理对象提交请求，让职责链负责处理。 职责链模式结构示意源代码如下：抽象处理者的示意代码如下。 /** * 抽象处理者，定义职责的接口，也就是处理请求的接口 */ public abstract class Handler { /** * 持有后继的处理者对象 */ protected Handler successor; /** * 赋值方法，设置后继的处理者对象 * * @param successor */ public void setSuccessor(Handler successor) { this.successor = successor; } /** * 示意处理请求的方法，虽然这个示意方法是没有传入参数的 但实际是可以传入参数的，根据具体需要来选择是否传递参数 */ public abstract void handleRequest(); } 具体处理者示意代码如下。 public class ConcreteHandlerA extends Handler { /** * 处理方法，调用此方法处理请求 */ @Override public void handleRequest() { // 根据某些条件来判断是否属于自己处理的职责范围,下面這句話只是个示意 boolean someCondition = false; if (someCondition) { // 如果属于自己处理的职责范围，就在这里处理请求 // 具体的处理代码 } else { // 如果不属于自己处理的职责范围，那就判断是否还有后继的职责对象 // 如果有，就转发请求给后继的职责对象 // 如果没有，什么都不做，自然结束 if (null != this.successor) { this.successor.handleRequest(); } } } } public class ConcreteHandlerB extends Handler { /** * 处理方法，调用此方法处理请求 */ @Override public void handleRequest() { // 根据某些条件来判断是否属于自己处理的职责范围,下面這句話只是个示意 boolean someCondition = false; if (someCondition) { // 如果属于自己处理的职责范围，就在这里处理请求 // 具体的处理代码 } else { // 如果不属于自己处理的职责范围，那就判断是否还有后继的职责对象 // 如果有，就转发请求给后继的职责对象 // 如果没有，什么都不做，自然结束 if (null != this.successor) { this.successor.handleRequest(); } } } } 客户端示意代码如下。 public class Client { public static void main(String[] args) { // 组装职责链 Handler handlerA = new ConcreteHandlerA(); Handler handlerB = new ConcreteHandlerB(); handlerA.setSuccessor(handlerB); // 提交请求 handlerA.handleRequest(); } } 三、职责链模式应用举例《研磨设计模式》中给出这么一个场景：申请聚餐费用。很多公司都有这样的福利，就是项目组或者是部门可以向公司申请一些聚餐费用，用于组织项目组成员或者是部门成员进行聚餐活动，以增进员工之间的感情，更有利于工作中的相互合作。 申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。 不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。 也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求，但是申请人并不知道应该由总经理来处理他的申请。 上述功能可以使用职责链模式来实现：当某人提出聚餐费用申请的请求后，该请求会在 项目经理—〉部门经理—〉总经理 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。 需要把每位领导的处理独立出来，实现成单独的职责处理对象，然后为它们提供一个公共的、抽象的父职责对象，这样就可以在客户端来动态地组合职责链，实现不同的功能要求了。 以下是使用职责链模式实现示例的类图结构。 先定义抽象处理者角色，在这个类中持有下一个处理请求的对象，同时还要定义业务处理方法，示例代码如下： /** * 抽象处理者，定义职责的接口，也就是处理请求的接口 */ public abstract class Handler { /** * 持有后继的处理者对象 */ protected Handler successor=null; /** * 赋值方法，设置后继的处理者对象 * * @param successor */ public void setSuccessor(Handler successor) { this.successor = successor; } /** * 处理聚餐费用的申请 * @param user 申请人 * @param fee 申请的钱数 */ public abstract String handleFeeRequest(String user,double fee); } 假设现在的费用申请处理流程如下：申请人提出的申请交给项目经理处理，项目经理的处理权限是500元内，超过500元，把申请转给部门经理处理，部门经理的处理权限是1000元以内，超过1000元，把申请转给总经理处理。具体处理者代码实现如下： public class ProjectManager extends Handler { public String handleFeeRequest(String user,double fee) { String str=&quot;&quot;; //项目经理处理权限比较小，只能处理500元以内的费用申请 if(fee&lt;500){ //为了测试，简单点，只同意小李的申请 if(&quot;小李&quot;.equals(user)){ str=&quot;项目经理同意&quot;+user+&quot;聚餐费用&quot;+fee+&quot;元的请求...&quot;; } else{ //其他人的申请一律不同意 str=&quot;项目经理不同意&quot;+user+&quot;聚餐费用&quot;+fee+&quot;元的请求...&quot;; } } else{ //超过500元的费用申请，继续传递给级别更高的人处理 if(this.successor!=null){ return successor.handleFeeRequest(user, fee); } } return str; } } public class DeptManager extends Handler { public String handleFeeRequest(String user, double fee) { String str = &quot;&quot;; // 部门经理只能处理500元以内的费用申请 if (fee &lt; 1000) { // 为了测试，简单点，只同意小李的申请 if (&quot;小李&quot;.equals(user)) { str = &quot;部门经理同意&quot; + user + &quot;聚餐费用&quot; + fee + &quot;元的请求...&quot;; } else { // 其他人的申请一律不同意 str = &quot;部门经理不同意&quot; + user + &quot;聚餐费用&quot; + fee + &quot;元的请求...&quot;; } } else { // 超过1000元的费用申请，继续传递给级别更高的人处理 if (this.successor != null) { return successor.handleFeeRequest(user, fee); } } return str; } } public class GeneralManager extends Handler { public String handleFeeRequest(String user,double fee) { String str=&quot;&quot;; //总经理的权限很大，只要请求到了这里，他都可以处理 if(fee&gt;=1000){ //为了测试，简单点，只同意小李的申请 if(&quot;小李&quot;.equals(user)){ str=&quot;总经理同意&quot;+user+&quot;聚餐费用&quot;+fee+&quot;元的请求...&quot;; } else{ //其他人的申请一律不同意 str=&quot;总经理不同意&quot;+user+&quot;聚餐费用&quot;+fee+&quot;元的请求...&quot;; } } else{ //如果还有后继的处理者对象，继续传递 if(this.successor!=null){ return successor.handleFeeRequest(user, fee); } } return str; } } 客户端示意代码如下： public class Client { public static void main(String[] args) { // 先要组装责任链 Handler h1 = new GeneralManager(); Handler h2 = new DeptManager(); Handler h3 = new ProjectManager(); h3.setSuccessor(h2); h2.setSuccessor(h1); // 开始测试 String ret1 = h3.handleFeeRequest(&quot;小李&quot;, 300); System.out.println(&quot;the ret1 = &quot; + ret1); String ret2 = h3.handleFeeRequest(&quot;小张&quot;, 300); System.out.println(&quot;the ret2 = &quot; + ret2); System.out.println(&quot;￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥&quot;); String ret3 = h3.handleFeeRequest(&quot;小李&quot;, 700); System.out.println(&quot;the ret3 = &quot; + ret3); String ret4 = h3.handleFeeRequest(&quot;小张&quot;, 700); System.out.println(&quot;the ret4 = &quot; + ret4); System.out.println(&quot;￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥&quot;); String ret5 = h3.handleFeeRequest(&quot;小李&quot;, 1500); System.out.println(&quot;the ret5 = &quot; + ret5); String ret6 = h3.handleFeeRequest(&quot;小张&quot;, 1500); System.out.println(&quot;the ret6 = &quot; + ret6); } } 运行程序打印结果如下： the ret1 = 项目经理同意小李聚餐费用300.0元的请求…the ret2 = 项目经理不同意小张聚餐费用300.0元的请求…￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥the ret3 = 部门经理同意小李聚餐费用700.0元的请求…the ret4 = 部门经理不同意小张聚餐费用700.0元的请求…￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥￥the ret5 = 总经理同意小李聚餐费用1500.0元的请求…the ret6 = 总经理不同意小张聚餐费用1500.0元的请求… 四、职责链模式的适用性在以下情况下可以考虑使用职责链模式： 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。 你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 可处理一个请求的对象集合应被动态指定。 五、职责链模式的优缺点职责链模式有以下优点： 责任的分担。每个类只需要处理自己该处理的工作（不该处理的传递给下一个对象完成），明确各类的责任范围，符合类的最小封装原则。 可以根据需要自由组合职责流程。如果职责流程发生变化，可以通过重新组装对象链便可适应新的职责流程。 请求者和处理者松散耦合。请求者并不知道他发起的请求的处理者是谁，也不知道请求是如何被处理的，他只是负责向职责链发出请求就可以了，实现了请求者和处理者之间的解耦。 职责链模式有以下缺点： 产生很多细粒度职责对象职责链模式把功能分散到单独的处理者对象中，也就是每个处理者只处理一部分的请求，在请求处理流程很复杂的情况下，这样会产生大量的细粒度职责对象。 不一定能被处理职责链模式的每个职责对象只负责处理自己职责范围内的请求，因此可能会出现某个请求，在整个职责链上传递完了，都没有职责对象处理它。 影响执行效率因为处理时以链的形式在对象间传递消息，根据实现方式不同，有可能会影响处理的速度。 六、总结职责链模式以分离职责为前提，将复杂的请求处理进行拆分，并分配给一个个的职责类。每个职责类只负责处理请求的一部分，在运行期间职责类进行动态组合，形成一个职责链，请求在链上进行传递和处理。 动态组合才是职责类模式的精华所在，因为要实现请求者和处理者的解耦，请求者不知道谁才是真正的处理者，因此要动态地把可能的处理者组合起来，由于组合的方式是动态的，这就意味着可以很方便地修改和添加新的处理者，从而让系统更加灵活和具有更好的扩展性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"职责链模式,Java,设计模式","slug":"职责链模式-Java-设计模式","permalink":"/tags/职责链模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--桥接模式","slug":"Java设计模式之--桥接模式","date":"2020-05-24T08:52:17.000Z","updated":"2023-04-30T10:21:41.358Z","comments":true,"path":"2020/05/24/Java设计模式之--桥接模式/","link":"","permalink":"/2020/05/24/Java设计模式之--桥接模式/","excerpt":"","text":"一、什么是桥接模式桥接(Bridge)模式是构造型的设计模式之一。桥接模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象(abstraction)与行为实现(implementation)分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。 二、桥接模式的应用场景《研磨设计模式》中给出这么一个场景：发送消息。 从消息的重要程度上来看，消息可以分为普通消息、加急消息两种，两种消息的业务功能处理是不一样的，比如普通消息直接发送即可，而加急消息除了需在发送的消息上添加加急标识外，还需提供监控功能，以方便客户端了解加急消息的处理进度。 从发送消息的方式上来看，消息又可以分为站内短消息和E-Mail两种。 在不使用设计模式的情况下，我们一般会这么做：考虑到普通消息和加急消息都各有站内短消息和E-Mail两种发送方式，为了让外部能统一操作，因此把消息设计成接口，普通消息的两种发送方式分别作为该接口的两个实现，但加急消息除了有基本的发送消息的功能，还需要添加监控功能，因此将加急消息也抽取为接口，加急消息的两种发送方式做为接口的两个实现。 这个时候，系统的类图结构设计如下。 仔细观察这个类图，会发现一个很明显的问题，通过这种继承的方式来扩展消息处理，会非常不方便。举个例子，假如我们要在此基础上添加一个特急消息的处理：特急消息不需要进行监控，只要没有完成，就直接催促，也就是说，对于特急消息，在普通消息的基础上，需要添加催促的功能。而特急消息的发送方式还是发送站内短消息和E-Mail两种，此时的类图结构如下。 从以上过程可以看到，我们在实现加急消息处理的时候，必须实现站内短消息和E-Mail两种处理方式；在实现特急消息处理的时候，又必须实现站内短消息和E-Mail两种处理方式。 这意味着，以后每次扩展一种消息处理，都必须要实现站内短消息和E-Mail两种处理方式，是不是很痛苦？ 这还不算完，如果要添加新的消息发送方式呢？继续扩展功能，添加手机短消息的发送方式，类图结构扩展如下。 仔细观察现在的实现，如果此时再添加一种消息处理，则需要添加系统内短消息、邮件和手机消息三个实现。按照这种实现方式继续扩展下去，消息类的数量会急剧增加，极易出现“类膨胀”。 遇到类似以上这种情况，应该如何解决呢？答案：使用桥接模式。 三、桥接模式的结构仔细分析上面的示例，会发现示例中消息的变化具有两个维度，一个维度是抽象的消息这边，包括普通消息、加急消息和特急消息；另一个维度是在消息的发送方式上，包括站内短消息、E-Mail和手机短消息。这两个维度一共可以组合出9种不同的可能性来，它们的关系如下。 现在出现问题的根本原因，就在于消息的抽象和实现是混杂在一起的，这就导致一个维度的变化会引起另一个维度进行相应的变化，从而使得程序扩展起来非常困难。 要解决这个问题，就必须把这两个维度分开，也就是将抽象部分和实现部分分开，让它们相互独立，这样就可以实现独立的变化，使扩展变得简单。桥接模式就可以达到这种效果，以下是桥接模式的结构示意图。 桥接模式涉及的角色及其职责如下： Abstraction：抽象部分的接口。通常在这个对象中，要维护一个实现部分的对象引用，抽象对象里面的方法，需要调用实现部分的对象来完成，这个对象中的方法，通常都是和具体的业务相关的方法。 RefinedAbstraction：扩展抽象部分的接口。通常在这些对象中，定义跟实际业务相关的方法，这些方法实现通常会使用Abstraction中定义的方法，也可能会调用实现部分的对象来完成。 Implementor：定义实现部分的接口。这个接口不用和Abstraction中定义的方法一致，通常是由Implementor接口提供基本的操作。而 Abstraction中定义的是基于这些基本操作的业务方法，也就是说 Abstraction定义了基于这些基本操作的较高层次的操作。 ConcreteImplementor：真正实现 Implementor接口的对象。 桥接模式结构示意源代码如下： public abstract class Abstraction { /** * 持有一个实现部分的对象 */ protected Implementor impl; /** * 构造方法，传入一个实现部分的对象 */ public Abstraction(Implementor impl) { this.impl = impl; } /** * 示例操作，实现一定的功能，可能需要调用实现部分的具体实现方法 */ public void operation() { impl.operationImpl(); } } public interface Implementor { /** * 示例方法，实现抽象部分需要的某些具体功能 */ public void operationImpl(); } public class RefinedAbstraction extends Abstraction { public RefinedAbstraction(Implementor impl) { super(impl); } /** * 示例操作，实现一定的功能 */ public void otherOperation() { // 实现一定的功能，可能会使用具体实现部分的实现方法 // 但是本方法更大的可能是使用Abstraction中定义的方法 // 通过组合使用Abstraction中定义的方法来完成更多的功能 } } public class ConcreteImplementorA implements Implementor { @Override public void operationImpl() { // 真正的实现 } } public class ConcreteImplementorB implements Implementor { @Override public void operationImpl() { // 真正的实现 } } 四、使用桥接模式重写消息先实现普通消息和加急消息的功能，发送方式先实现站内短消息和E-mail两种，使用桥接模式来实现这些功能的类图结构如下。 下面是各个类的实现代码。 /** * 抽象的消息对象 */ public abstract class AbstractMessage { /** * 持有一个实现部分的对象 */ protected MessageImplementor impl; /** * 构造方法，传入实现部分的对象 * @param impl 实现部分的对象 */ public AbstractMessage(MessageImplementor impl) { this.impl = impl; } /** * 发送消息，转调实现部分的方法 * @param message 消息的内容 * @param toUser 消息的接收人 */ public void sendMessage(String message, String toUser) { this.impl.send(message, toUser); } } /** * 实现发送消息的统一接口 */ public interface MessageImplementor { /** * 发送消息 * * @param message 消息的内容 * @param toUser 消息的接收人 */ public void send(String message, String toUser); } public class CommonMessage extends AbstractMessage { public CommonMessage(MessageImplementor impl) { super(impl); } public void sendMessage(String message, String toUser){ //对于普通消息，什么都不干，直接调用父类的方法，把消息发送出去 super.sendMessage(message, toUser); } } public class UrgencyMessage extends AbstractMessage { public UrgencyMessage(MessageImplementor impl) { super(impl); } public void sendMessage(String message, String toUser) { // 对于加急消息，在消息上添加“加急”标识，再调用父类的方法，把消息发送出去 message = &quot;[加急]&quot; + message; super.sendMessage(message, toUser); } /** * 扩展自己的新功能：监控某消息的处理过程 * @param message 被监控的消息 * @return 包含监控到的数据对象，此处用Object示意 */ public Object watch(AbstractMessage message) { return null; } } public class MessageSMS implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(&quot;使用站内短消息的方式，发送消息:&quot;+message+&quot;给&quot;+toUser); } } public class MessageEmail implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(&quot;使用E-mail的方式，发送消息:&quot; + message + &quot;给&quot; + toUser); } } 继续添加对特急消息的处理，同时添加发送手机消息的方式，该如何实现？ 很简单，只需要在抽象部分再添加一个特急消息的类，扩展抽象消息就可以把特急消息的处理功能加入到系统中；对于添加手机发送消息的方式也很简单，在实现部分新增加一个实现类，实现使用手机发送消息的方式就可以了。 新添加的两个类，代码如下。 public class SpecialUrgencyMessage extends AbstractMessage { public SpecialUrgencyMessage(MessageImplementor impl) { super(impl); } public void hurry(AbstractMessage message) { // 执行催促的功能，发出催促的信息 } public void sendMessage(String message, String toUser) { // 对于特急消息，在消息上添加“特急”标识，再调用父类的方法，把消息发送出去 message = &quot;[特急]&quot; + message; super.sendMessage(message, toUser); // 还需要增加一条待催促的信息 } } public class MessageMobile implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(&quot;使用手机短消息的方式，发送消息:&quot; + message + &quot;给&quot; + toUser); } } 写个客户端类来测试一下，代码如下。 public class Client { public static void main(String[] args) { // 创建具体的实现对象 MessageImplementor impl = new MessageSMS(); // 创建一个普通消息对象 AbstractMessage m = new CommonMessage(impl); m.sendMessage(&quot;今晚8点，时代广场，不见不散！&quot;, &quot;小乔&quot;); // 创建一个紧急消息对象 m = new UrgencyMessage(impl); m.sendMessage(&quot;半小时后召开紧急会议！&quot;, &quot;小周&quot;); // 创建一个特急消息对象 m = new SpecialUrgencyMessage(impl); m.sendMessage(&quot;领导过来视察了，速回！&quot;, &quot;小明&quot;); // 把发送方式切换成手机短消息，将以上内容重发一遍 impl = new MessageMobile(); // 创建一个普通消息对象 m = new CommonMessage(impl); m.sendMessage(&quot;今晚8点，时代广场，不见不散！&quot;, &quot;小乔&quot;); // 创建一个紧急消息对象 m = new UrgencyMessage(impl); m.sendMessage(&quot;半小时后召开紧急会议！&quot;, &quot;小周&quot;); // 创建一个特急消息对象 m = new SpecialUrgencyMessage(impl); m.sendMessage(&quot;领导过来视察了，速回！&quot;, &quot;小明&quot;); } } 运行程序打印结果如下： 使用站内短消息的方式，发送消息:今晚8点，时代广场，不见不散！给小乔使用站内短消息的方式，发送消息:[加急]半小时后召开紧急会议！给小周使用站内短消息的方式，发送消息:[特急]领导过来视察了，速回！给小明使用手机短消息的方式，发送消息:今晚8点，时代广场，不见不散！给小乔使用手机短消息的方式，发送消息:[加急]半小时后召开紧急会议！给小周使用手机短消息的方式，发送消息:[特急]领导过来视察了，速回！给小明 五、桥接模式的适用性在以下的情况下可以考虑使用桥接模式： 1．如果你不希望在抽象部分和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象部分和实现部分分开，然后在程序运行期间来动态地设置抽象部分需要用到的具体的实现，还可以动态地切换具体的实现。 2．如果出现抽象部分和实现部分都能够扩展的情况，可以采用桥接模式，让抽象部分和实现部分独立地变化，从而灵活地进行单独扩展，而不是搅在一起，扩展一边就会影响到另一边。 3．如果希望实现部分的修改不会对客户产生影响，可以采用桥接模式。由于客户是面向抽象的接口在运行，实现部分的修改可以独立于抽象部分，并不会对客户产生影响，也可以说对客户是透明的。 4．如果采用继承的实现方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看是否能分离成不同的维度，然后通过桥接模式来分离它们，从而减少子类的数目。 六、桥接模式的特点 分离抽象和实现部分 桥接模式分离了抽象部分和实现部分，从而极大地提高了系统的灵活性。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。 更好的扩展性 由于桥接模式把抽象部分和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大地提高了系统的可扩展性。 可动态地切换实现 桥接模式把抽象部分和实现部分分离开了，所以在实现桥接的时候，就可以实现动态地选择和使用具体的实现。也就是说一个实现不再是固定地绑定在一个抽象接口上了，可以实现运行期间动态地切换。 可减少子类的个数 对于有两个变化维度的情况，如果采用继承的实现方式，大约需要两个维度上的可变化数量的乘积个子类；而采用桥接模式来实现，大约需要两个维度上的可变化数量的和个子类。可以明显地减少子类的个数。 七、总结桥接模式很好地实现了面向对象设计中的开闭原则和多用对象组合、少用对象继承原则，它的本质是：分离抽象和实现。只有把抽象部分和实现部分分离开了，才能够让它们独立地变化；只有抽象部分和实现部分可以独立地变化，系统才会有更好的可扩展性和可维护性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"桥接模式,Java,设计模式","slug":"桥接模式-Java-设计模式","permalink":"/tags/桥接模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--访问者模式","slug":"Java设计模式之--访问者模式","date":"2020-05-24T08:51:11.000Z","updated":"2023-04-30T10:21:41.362Z","comments":true,"path":"2020/05/24/Java设计模式之--访问者模式/","link":"","permalink":"/2020/05/24/Java设计模式之--访问者模式/","excerpt":"","text":"一、什么是访问者模式访问者（Visitor）模式是一种对象的行为模式。在访问者模式里，每个访问者表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 在面向对象的系统开发和设计过程中，经常遇到的一种情况就是需求变更，针对已经开发完成的系统，客户又会提出新的需求。因此，我们不得不去修改已有的设计，最常见就是解决方案就是给已经设计、实现好的类添加新的方法去实现客户新的需求，这样就陷入了设计变更的梦魇：不停地打补丁，其最大的问题就是设计根本就不可能封闭。 访问者模式则为这种情况提供了一种解决方案：将更新（变更）封装到一个类中（访问操作），并由待更改类提供一个接收接口，则可达到效果。 二、访问者模式的结构 访问者模式涉及的角色及其职责如下： 抽象访问者(Visitor)角色：为该对象结构中具体元素角色声明一个访问操作接口，用来代表为对象结构添加的新功能，理论上可以代表任意的功能。 具体访问者(ConcreteVisitor)角色：实现每个由抽象访问者角色（Visitor）声明的操作接口。 抽象元素(Element)角色：定义一个accept()操作，它以一个访问者（Visitor）对象作为参数。 具体元素(ConcreteElement)角色：实现由抽象元素(Element)角色提供的accept()操作。 对象结构(ObjectStructure)角色：这是使用访问者模式必备的角色。一般具备以下特征： 能枚举它的元素。 可以提供一个高层的接口以允许该访问者访问它的元素。 可以是一个复合（组合模式）或是一个集合，如一个列表或一个无序集合。 访问者模式结构示意源代码如下： （1）首先定义一个接口来代表要新加入的功能，把它称作访问者（Visitor），访问谁呢？当然是访问对象结构中的对象了。 /** * 访问者接口 */ public interface Visitor { /** * 访问ConcreteElementA，相当于为ConcreteElementA添加的新功能 */ public void visitConcreteElementA(ConcreteElementA elementA); /** * 访问ConcreteElementB，相当于为ConcreteElementB添加的新功能 */ public void visitConcreteElementB(ConcreteElementB elementB); } （2）再看看访问者的具体实现(ConcreteVisitor)。 public class ConcreteVisitorA implements Visitor { @Override public void visitConcreteElementA(ConcreteElementA elementA) { /** * 把访问ConcreteElementA时，需要执行的功能在这里进行实现 可能需要访问元素已有的功能，比如：operationA() */ System.out.println(&quot;ConcreteVisitorA 访问 ==&gt; ConcreteElementA 对象。&quot;); } @Override public void visitConcreteElementB(ConcreteElementB elementB) { /** * 把访问ConcreteElementB时，需要执行的功能在这里进行实现 可能需要访问元素已有的功能，比如：operationB() */ System.out.println(&quot;ConcreteVisitorA 访问 ==&gt; ConcreteElementB 对象。&quot;); } } public class ConcreteVisitorB implements Visitor { @Override public void visitConcreteElementA(ConcreteElementA elementA) { /** * 把访问ConcreteElementA时，需要执行的功能在这里进行实现 可能需要访问元素已有的功能，比如：operationA() */ System.out.println(&quot;ConcreteVisitorB 访问 ==&gt; ConcreteElementA 对象。&quot;); } @Override public void visitConcreteElementB(ConcreteElementB elementB) { /** * 把访问ConcreteElementB时，需要执行的功能在这里进行实现 可能需要访问元素已有的功能，比如：operationB() */ System.out.println(&quot;ConcreteVisitorB 访问 ==&gt; ConcreteElementB 对象。&quot;); } } （3）抽象元素(Element)的定义。 public abstract class Element { // 接受访问者的访问 public abstract void accept(Visitor visitor); } （4）再看看元素对象的具体实现(ConcreteElement)。 public class ConcreteElementA extends Element { @Override public void accept(Visitor visitor) { // 回调访问者对象的相应方法 visitor.visitConcreteElementA(this); } /** * 示例方法，表示元素已有的功能实现 */ public void operationA() { System.out.println(&quot;执行ConcreteElementA已有的operationA方法.&quot;); } } public class ConcreteElementB extends Element { @Override public void accept(Visitor visitor) { // 回调访问者对象的相应方法 visitor.visitConcreteElementB(this); } /** * 示例方法，表示元素已有的功能实现 */ public void operationB() { System.out.println(&quot;执行ConcreteElementB已有的operationB方法.&quot;); } } ​（5）对象结构(ObjectStructure)示例代码如下。 import java.util.ArrayList; import java.util.Collection; /** * 对象结构，通常在这里对元素对象进行遍历，让访问者能够访问到所有的元素 */ public class ObjectStructure { /** * 示意,表示对象结构，可以是一个组合结构或者集合 */ private Collection&lt;Element&gt; col = new ArrayList&lt;Element&gt;(); /** * 示意方法，提供给客户端操作的高层接口，让访问者对对象结构中的所有元素进行访问 */ public void handleRequest(Visitor visitor) { // 循环对象结构中的元素，进行访问 for (Element element : col) { element.accept(visitor); } } /** * 示意方法，组建对象结构，向对象结构中添加元素 */ public void addElement(Element element) { this.col.add(element); } } （6）最后在客户端测试一下，示例代码如下。 public class Client { public static void main(String[] args) { // 创建对象结构 ObjectStructure os = new ObjectStructure(); // 为对象结构中添加元素对象 os.addElement(new ConcreteElementA()); os.addElement(new ConcreteElementB()); // 创建访问者 Visitor visitor = new ConcreteVisitorA(); // 调用对象结构的业务处理方法 os.handleRequest(visitor); } } 运行程序打印结果如下： ConcreteVisitorA 访问 ==&gt; ConcreteElementA 对象。ConcreteVisitorA 访问 ==&gt; ConcreteElementB 对象。 访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。 访问者模式在不破坏类的前提下，为类提供增加新的新操作，其实现的关键是双分派（ Double-Dispatch）的技术。 在访问者模式中 accept()操作是一个双分派的操作。具体调用哪一个具体的accept()操作，有两个决定因素： Element的类型。因为 accept()是多态的操作，需要具体的 Element 类型的子类才可以决定到底调用哪一个accept()实现； Visitor的类型。accept()操作有一个参数（ Visitor visitor），要决定了实际传进来的 Visitor 的实际类别才可以决定具体是调用哪个 VisitConcrete（）实现。 三、访问者模式的适用性从访问者模式的定义可以看出对象结构是使用访问者模式的先决条件，在以下情况可以考虑使用访问者模式： 对象结构内包含多种类型的对象，我们希望对这些对象实施一些依赖于其具体类型的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。 对象结构中对象的类型很少改变，但经常需要在此对象结构上定义新的操作。 四、 场景举例一个商场（SuperMarket），通常都会包括（当然还会包含一些其他的组成部分）：商店（Store）、监控室（MonitoringRoom）、卫生间（WaterCloset）。商场的访问者大致可以分为两大类：顾客（Customer）、商场工作人员（MarketStaff）。顾客可以逛商店、上卫生间，但却不能进入监控室；工作人员可以进入监控室、上卫生间，但却不能像顾客一样逛商店（除非他不想干了），也就是说对于商场的同一个地点，不同的访问者有不同的行为权限，而且访问者的种类很有可能需要根据时间的推移发生变化（没准哪天，工商局的人要来视察呢！此时就需要增加工商局人员的访问者了。）。 使用访问者模式实现，其类图如下： Place相当于访问者模式中的Element。 public abstract class Place { // 接受访问者的访问 public abstract void accept(Visitor visitor); } Place的具体实现类有三个，WaterCloset、Store和MonitoringRoom。 public class WaterCloset extends Place { @Override public void accept(Visitor visitor) { // 回调访问者对象的相应方法 visitor.visitWaterCloset(this); } public void washing() { // 卫生间已有的方法 System.out.println(&quot;洗洗手。。。*/&quot;); } } public class Store extends Place { @Override public void accept(Visitor visitor) { // 回调访问者对象的相应方法 visitor.visitStore(this); } public void shopping() { // 商店已有的方法 System.out.println(&quot;欢迎光临，祝您购物愉快。。。*/&quot;); } } public class MonitoringRoom extends Place { @Override public void accept(Visitor visitor) { // 回调访问者对象的相应方法 visitor.visitMonitoringRoom(this); } public void watching() { // 监控室已有的方法 System.out.println(&quot;查看监控录像...*/&quot;); } } 抽象访问者Visitor的代码如下。 public interface Visitor { // 进入卫生间 public void visitWaterCloset(WaterCloset wc); // 进入监控室 public void visitMonitoringRoom(MonitoringRoom mr); // 进入商店 public void visitStore(Store store); } Visitor的具体实现类，MarketStaff和Customer。 public class MarketStaff implements Visitor { @Override public void visitWaterCloset(WaterCloset wc) { System.out.println(&quot;/*工作人员来到卫生间。。。&quot;); wc.washing(); System.out.println(); } @Override public void visitMonitoringRoom(MonitoringRoom mr) { System.out.println(&quot;/*工作人员来到监控室。。。&quot;); mr.watching(); System.out.println(); } @Override public void visitStore(Store store) { System.out.println(&quot;/*工作人员来到商店。。。&quot;); System.out.println(&quot;现在是工作时间，请专心工作。。。*/&quot;); System.out.println(); } } public class Customer implements Visitor { @Override public void visitWaterCloset(WaterCloset wc) { System.out.println(&quot;/*顾客来到卫生间。。。&quot;); wc.washing(); System.out.println(); } @Override public void visitMonitoringRoom(MonitoringRoom mr) { System.out.println(&quot;/*顾客来到监控室。。。&quot;); System.out.println(&quot;非工作人员禁止入内。。。*/&quot;); System.out.println(); } @Override public void visitStore(Store store) { System.out.println(&quot;/*顾客来到商店。。。&quot;); store.shopping(); System.out.println(); } } SuperMarket就是结构对象。 import java.util.ArrayList; import java.util.Collection; public class SuperMarket { // 示意,表示对象结构，可以是一个组合结构或者集合 private Collection&lt;Place&gt; col = new ArrayList&lt;Place&gt;(); public void handleRequest(Visitor visitor) { // 循环对象结构中的元素，进行访问 for (Place place : col) { place.accept(visitor); } } // 示意方法，组建对象结构，向对象结构中添加元素 public void addPlace(Place place) { this.col.add(place); } } Client中测试代码如下。 public class Client { public static void main(String[] args) { SuperMarket superMarket = new SuperMarket(); superMarket.addPlace(new WaterCloset()); superMarket.addPlace(new Store()); superMarket.addPlace(new MonitoringRoom()); // 创建一个顾客访问者 Visitor customer = new Customer(); System.out.println(&quot;=====顾客来到商场=====&quot;); superMarket.handleRequest(customer); System.out.println(&quot;=====顾客离开商场=====&quot;); System.out.println(); // 创建一个商场工作人员访问者 Visitor visitor = new MarketStaff(); System.out.println(&quot;=====工作人员来到商场=====&quot;); superMarket.handleRequest(visitor); System.out.println(&quot;=====工作人员离开商场=====&quot;); } } 运行程序打印结果如下： =====顾客来到商场=====/顾客来到卫生间。。。洗洗手。。。/ /顾客来到商店。。。欢迎光临，祝您购物愉快。。。/ /顾客来到监控室。。。非工作人员禁止入内。。。/ =====顾客离开商场===== =====工作人员来到商场=====/工作人员来到卫生间。。。洗洗手。。。/ /工作人员来到商店。。。现在是工作时间，请专心工作。。。/ /工作人员来到监控室。。。查看监控录像…/ =====工作人员离开商场===== 五、访问者模式的特点访问者模式的优点 好的扩展性：能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。 好的复用性：可以通过访问者来定义整个对象结构通用的功能，从而提高复用程度。 分离无关行为：可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。 访问者模式的缺点 增加新的元素类很困难：在访问者类中，每一个元素类都有它对应的处理方法，也就是说，每增加一个元素类都需要修改访问者类（也包括访问者类的子类或者实现类），修改起来相当麻烦。 破坏封装：访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructrue，这破坏了对象的封装性。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"访问者模式,Java,设计模式","slug":"访问者模式-Java-设计模式","permalink":"/tags/访问者模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--享元模式","slug":"Java设计模式之--享元模式","date":"2020-05-24T08:50:10.000Z","updated":"2023-04-30T10:21:41.354Z","comments":true,"path":"2020/05/24/Java设计模式之--享元模式/","link":"","permalink":"/2020/05/24/Java设计模式之--享元模式/","excerpt":"","text":"一、什么是享元模式享元Flyweight模式是构造型模式之一，它通过共享数据使得相同对象在内存中仅创建一个实例，以降低系统创建对象实例的性能消耗。 以博客里写文章为例来说吧，把文章和文章中的文字看作对象，我们每在博客里写一个字就相当于是创建一个文字对象，假如我们写的文章有一万个字，那我们岂不是要创建一万次文字对象，如此频繁的创建对象势必会严重拖累系统的性能。 享元模式通过数据共享使得重复使用的相同对象在内存中仅创建一次：这就好比汉字中的 “的” 字虽然在文章中反复出现，但它仅在第一次被使用的时候创建 “的” (共享对象)并保存起来，之后再用到 “的” 字的话直接获取之前创建好的 “的” 对象即可，不需要再次创建了。 下面是两张使用享元模式前后的对比图，看完这两张图相信大家就能理解享元模式的作用了。 使用享元模式前： 使用享元模式后： 二、享元模式在Java中的典型应用在Java语言中，String类型就使用了享元模式。String对象是final类型，对象一旦创建就不可改变，同时JAVA会确保一个字符串常量（例如：”Flyweight”）在常量池中只能存在一份拷贝,例如下面这段简单代码： String str1=&quot;Flyweight&quot;; String str2=&quot;Flyweight&quot;; if(str1==str2){ System.out.println(&quot;str1与str2指向同一对象&quot;); } else { System.out.println(&quot;str1与str2指向不同对象&quot;); } 打印结果： str1与str2指向同一对象 在以上代码中if语句比较的是对象str1和str2中存储的内存地址是否相同，从最终的打印结果可以看出：两次创建的字符串常量”Flyweight”内存地址相同，即两个字符串其实是同一个对象。 三、享元模式的结构享元模式分为单纯享元模式和复合享元模式两种。 单纯享元模式 单纯享元模式涉及的角色及其职责如下： 抽象享元(Flyweight)角色：所有具体享元类的父类或实现的接口，以规定所有具体享元角色需要实现的方法。 具体享元(ConcreteFlyweight)角色：又叫单纯享元角色，是抽象享元角色的具体实现类，如果有内蕴状态的话，它负责为内蕴状态提供存储空间。具体享元对象的内蕴状态必须与对象所处的周围环境无关，从而使得享元对象可以在系统内共享。 享元工厂(FlyweightFactory)角色：负责创建和管理享元角色。本角色必须保证享元对象可以被系统适当地共享。当客户端调用某个享元对象的时候，享元工厂角色会检查系统中是否已经存在符合要求的享元对象，如果已经存在则直接提供，若不存在则新创建一个。 单纯享元模式结构示意源代码如下：在单纯的享元模式中，Flyweight接口用以规定出所有具体享元角色需要实现的方法。 public interface Flyweight { /** * 用以规定所有具体享元角色需要实现的方法. */ void operation(String extrinsicState); } 具体享元ConcreteFlyweight一方面要保存需共享的内蕴状态，另一方面将外蕴状态作为参数传入operation()方法中，可改变方法的行为，但并不改变对象的内蕴状态。 public class ConcreteFlyweight implements Flyweight { private String intrinsicState = null; /** * 构造函数中内蕴状态作为参数传入. */ public ConcreteFlyweight(String intrinsicState) { this.intrinsicState = intrinsicState; } /** * 外蕴状态作为参数传入方法中，可改变方法的行为，但并不改变对象的内蕴状态. */ @Override public void operation(String extrinsicState) { System.out.println(); System.out.println(&quot;内蕴状态：&quot; + intrinsicState); System.out.println(&quot;外蕴状态：&quot; + extrinsicState); System.out.println(&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&quot;); } public String toString() { return this.intrinsicState; } } 享元工厂FlyweightFactory负责维护一个享元对象存储池（Flyweight Pool）来存放内部状态的对象。为了调用方便，该工厂类一般使用单例模式来实现。 import java.util.HashMap; import java.util.Map; public class FlyweightFactory { // 用来登记和存储已经创建过的享元对象 private Map&lt;String, Flyweight&gt; flyweightMap = new HashMap&lt;String, Flyweight&gt;(); // 采用单例模式 private static FlyweightFactory flyweightFactory = new FlyweightFactory(); // 私有化享元工厂的构造方法 private FlyweightFactory() { } // 获取单例享元工厂的实例 public static FlyweightFactory getFlyweightFactory() { return flyweightFactory; } public Flyweight getFlyweight(String intrinsicState) { Flyweight flyweight = flyweightMap.get(intrinsicState); if (null == flyweight) { flyweight = new ConcreteFlyweight(intrinsicState); flyweightMap.put(intrinsicState, flyweight); } return flyweight; } public Map&lt;String, Flyweight&gt; getFlyweightMap() { return flyweightMap; } } 在Client类中创建的main()方法中进行测试。 import java.util.Map.Entry; public class Client { public static void main(String[] args) { FlyweightFactory flyweightFactory = FlyweightFactory.getFlyweightFactory(); flyweightFactory.getFlyweight(&quot;爱&quot;).operation(&quot;位置1&quot;); flyweightFactory.getFlyweight(&quot;我&quot;).operation(&quot;位置2&quot;); flyweightFactory.getFlyweight(&quot;的&quot;).operation(&quot;位置3&quot;); flyweightFactory.getFlyweight(&quot;人&quot;).operation(&quot;位置4&quot;); flyweightFactory.getFlyweight(&quot;和&quot;).operation(&quot;位置5&quot;); flyweightFactory.getFlyweight(&quot;我&quot;).operation(&quot;位置6&quot;); flyweightFactory.getFlyweight(&quot;爱&quot;).operation(&quot;位置7&quot;); flyweightFactory.getFlyweight(&quot;的&quot;).operation(&quot;位置8&quot;); flyweightFactory.getFlyweight(&quot;人&quot;).operation(&quot;位置9&quot;); System.out.println(&quot;已存储的享元对象个数：&quot;+flyweightFactory.getFlyweightMap().size()+&quot;个&quot;); for (Entry&lt;String, Flyweight&gt; entry : flyweightFactory.getFlyweightMap().entrySet()) { System.out.println(entry.getValue()); } } } 运行程序打印结果如下： 内蕴状态：爱外蕴状态：位置1&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：我外蕴状态：位置2&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：的外蕴状态：位置3&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：人外蕴状态：位置4&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：和外蕴状态：位置5&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：我外蕴状态：位置6&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：爱外蕴状态：位置7&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：的外蕴状态：位置8&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：人外蕴状态：位置9&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;已存储的享元对象个数：5个爱我的人和 从以上程序的运行结果不难看出，虽然我们新建了9个Flyweight对象，但在内存池中实际上只有5个，这就是共享的含义。 复合享元模式在单纯享元模式中，所有的享元对象都是单纯享元对象，也就是说都是可以直接共享的。还有一种较为复杂的情况，将一些单纯享元对象使用合成模式加以组合，形成复合享元对象。这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。 与单纯享元模式相比，复合享元模式增加了一个复合享元(UnsharedConcreteFlyweight)角色，复合享元角色所代表的对象是不可以共享的，又称作不可共享的享元对象。 复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法，这个方法有一个参数，代表复合享元对象的外蕴状态。一个复合享元对象的所有单纯享元对象的外蕴状态都是与复合享元对象的外蕴状态相等的；而一个复合享元对象所含有的单纯享元对象的内蕴状态一般是不相等的，不然就没有使用价值了。 复合享元模式本质上就相当于将原本掺杂在一起的单纯享元对象，根据不同的外蕴状态重新进行了二次分组。这就好比在饭店点餐时，饭店会将不同顾客点的菜记录在顾客自己的点菜单(账单)上一样，与将所有顾客点的菜都记录到一个点菜单上相比，分开记录很明显更便于管理、一目了然，接下来我们就以点餐为例来学习复合享元模式。 复合享元模式与单纯享元模式的差异代码如下：首先复合享元模式增加了一个不可共享的复合享元(UnsharedConcreteFlyweight)角色。 import java.util.HashMap; import java.util.Map; public class UnsharedConcreteFlyweight implements Flyweight { //用来登记和存储已经创建过的享元对象 private Map&lt;String, Flyweight&gt; flyweightMap = new HashMap&lt;String, Flyweight&gt;(); //指定所有享元对象的外蕴状态 private String extrinsicState = null; // 增加一个新的单纯享元对象到集合中 public void add(String intrinsicState, Flyweight flyweight) { flyweightMap.put(intrinsicState, flyweight); } @Override public void operation(String extrinsicState) { this.extrinsicState = extrinsicState; } public void getFlyweight(String intrinsicState){ Flyweight flyweight=flyweightMap.get(intrinsicState); if(null!=flyweight){ flyweight.operation(extrinsicState); } else{ System.out.println(); System.out.println(extrinsicState+&quot;未点过:&quot;+intrinsicState); System.out.println(&quot;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&quot;); } } public Map&lt;String, Flyweight&gt; getFlyweightMap() { return flyweightMap; } } 享元工厂FlyweightFactory仅需添加一个用于获取复合享元对象的getUnsharedFlyweight()方法，其他代码无需修改。 public class FlyweightFactory { /** * 此处省略单纯享元模式中享元工厂已有代码 * ... * ... * 原有代码不变，仅新增一个getUnsharedFlyweight()方法. */ public UnsharedConcreteFlyweight getUnsharedFlyweight(List&lt;String&gt; intrinsicStates) { UnsharedConcreteFlyweight unsharedFlyweight = new UnsharedConcreteFlyweight(); for (String intrinsicState : intrinsicStates) { unsharedFlyweight.add(intrinsicState, getFlyweight(intrinsicState)); } return unsharedFlyweight; } } 在Client客户端类进行测试，其修改后代码如下。 import java.util.ArrayList; import java.util.List; public class Client { public static void main(String[] args) { List&lt;String&gt; intrinsicStates = new ArrayList&lt;String&gt;(); intrinsicStates.add(&quot;木须肉&quot;); intrinsicStates.add(&quot;地三鲜&quot;); intrinsicStates.add(&quot;孜然牛肉&quot;); FlyweightFactory flyFactory =FlyweightFactory.getFlyweightFactory(); UnsharedConcreteFlyweight unsharedFlyweight1 = flyFactory.getUnsharedFlyweight(intrinsicStates); UnsharedConcreteFlyweight unsharedFlyweight2 = flyFactory.getUnsharedFlyweight(intrinsicStates); System.out.println(&quot;复合享元对象是否可以共享：&quot; + (unsharedFlyweight1 == unsharedFlyweight2)); unsharedFlyweight1.operation(&quot;一号桌&quot;); unsharedFlyweight2.operation(&quot;五号桌&quot;); //开始给一号桌上菜了 unsharedFlyweight1.getFlyweight(&quot;木须肉&quot;); unsharedFlyweight1.getFlyweight(&quot;地三鲜&quot;); unsharedFlyweight1.getFlyweight(&quot;孜然牛肉&quot;); unsharedFlyweight1.getFlyweight(&quot;霸王餐&quot;); System.out.println(); String intrinsicState =&quot;木须肉&quot;; Flyweight flyweight1 = unsharedFlyweight1.getFlyweightMap().get(intrinsicState); Flyweight flyweight2 = unsharedFlyweight2.getFlyweightMap().get(intrinsicState); System.out.println(&quot;不同复合享元对象中的单纯享元对象是否可以共享：&quot; + (flyweight1 == flyweight2)); } } 运行程序打印结果如下： 复合享元对象是否可以共享：false 内蕴状态：木须肉外蕴状态：一号桌&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：地三鲜外蕴状态：一号桌&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 内蕴状态：孜然牛肉外蕴状态：一号桌&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 一号桌未点过:霸王餐&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp; 不同复合享元对象中的单纯享元对象是否可以共享：true 四、享元模式应用举例场景：如下图所示，我们要做一个画图程序，为简单起见，假设该画图程序仅能画相同大小(直径20mm)的圆，但圆的颜色和位置可以不同。 如果想要使用享元模式来对该画图程序进行设计的话，首先要提取出享元对象(圆)的内蕴状态和外蕴状态。 内蕴状态：圆的颜色。 外蕴状态：圆的位置。 接下来，首先定义享元对象的抽象接口Circle，只含有一个draw()方法。 public interface Circle { //画圆方法，需传入绘制的坐标x,y void draw(int x,int y); } 然后再定义具体享元角色类ConcreteCircle。 import java.awt.Color; public class ConcreteCircle implements Circle { //内蕴状态，圆的颜色 private Color color; //构造函数中内蕴状态作为参数传入. public ConcreteCircle(Color color){ super(); this.color=color; } // 外蕴状态作为参数传入绘图方法中，用以指定绘图位置. @Override public void draw(int x, int y) { System.out.println(&quot;圆的颜色：&quot;+this.color+&quot;，坐标：X &quot;+x+&quot;,Y &quot;+y+&quot;。&quot;); } } 再定义享元工厂类CircleFactory。 import java.awt.Color; import java.util.HashMap; import java.util.Map; public class CircleFactory { private Map&lt;Color, Circle&gt; circleMap = new HashMap&lt;Color, Circle&gt;(); // 采用单例模式 private static CircleFactory circleFactory = new CircleFactory(); // 私有化享元工厂的构造方法 private CircleFactory() { } // 获取单例享元工厂的实例 public static CircleFactory getCircleFactory() { return circleFactory; } public Circle getCircle(Color color) { Circle circle = circleMap.get(color); if (null == circle) { circle = new ConcreteCircle(color); circleMap.put(color, circle); } return circle; } } 最后创建客户端Client类。 import java.awt.Color; public class Client { public static void main(String[] args) { /** * 7个红色圆的坐标：(0,0) (0,25) (0,50) (0,75) (0,100) (25,100) (50,100) * 11个蓝色圆的坐标：(100,0) (125,0) (150,0) (100,25) (100,50) (125,50) (150,50) (100,75) (100,100) (125,100) (150,100) * 11个绿色圆的坐标：(200,0) (225,0) (250,0) (200,25) (200,50) (225,50) (250,50) (200,75) (200,100) (225,100) (250,100) */ CircleFactory circleFactory=CircleFactory.getCircleFactory(); circleFactory.getCircle(Color.RED).draw(0, 0); circleFactory.getCircle(Color.RED).draw(0, 25); circleFactory.getCircle(Color.RED).draw(0, 50); circleFactory.getCircle(Color.RED).draw(0, 75); circleFactory.getCircle(Color.RED).draw(0, 100); circleFactory.getCircle(Color.RED).draw(25, 100); circleFactory.getCircle(Color.RED).draw(50, 100); /** * ...篇幅所限，蓝色圆和绿色圆的绘制代码此处省略... */ } } 运行程序打印结果如下： 圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 0,Y 0。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 0,Y 25。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 0,Y 50。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 0,Y 75。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 0,Y 100。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 25,Y 100。圆的颜色：java.awt.Color[r=255,g=0,b=0]，坐标：X 50,Y 100。 五、享元模式的适用性Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当出现下列情形时可以考虑使用Flyweight模式。 一个应用程序使用了大量的对象。 完全由于使用大量的对象，造成很大的存储开销。 对象的大多数状态都可变为外部状态。 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。 应用程序不依赖对象标识。 六、享元模式的特点享元模式的优点：减少对象数量，节省内存空间。享元模式的缺点： 享元模式使得系统更加复杂。为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。 享元模式的本质：分离与共享 七、总结享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享 元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"享元模式,Java,设计模式","slug":"享元模式-Java-设计模式","permalink":"/tags/享元模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--适配器模式","slug":"Java设计模式之--适配器模式","date":"2020-05-24T08:48:43.000Z","updated":"2023-04-30T10:21:41.363Z","comments":true,"path":"2020/05/24/Java设计模式之--适配器模式/","link":"","permalink":"/2020/05/24/Java设计模式之--适配器模式/","excerpt":"","text":"1、什么是适配器模式适配器(Adapter)模式又叫做包装( Wrapper )模式，是由GOF提出的23种设计模式中的一种结构型设计模式，Adapter模式的设计意图：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。 2、适配器模式的适用场景 如图所示，有时，为复用而设计的工具类常常会因为它的接口与专业应用领域所需要的接口不匹配而不能够被复用。 再举个Java界面程序开发中的真实案例：我们要设计一个绘图编辑器，这个编辑器允许用户绘制和排列基本图元(线、多边形、正文等)，图元对象的抽象我们用一个 Shape 接口来定义，所有的具体图元类型都要实现 Shape 接口：LineShape类对应于直线，PolygonShape类对应于多边形，TextShape类对应于正文，等等。 对于像LineShape和PolygonShape这样的基本图元类由于它们的编辑功能本来就很有限，我们很容易就能够实现。但是对于可以显示和编辑正文的TextShape子类来说，实现相当困难，因为即使是基本的正文编辑也要涉及到复杂的屏幕刷新和缓冲区管理。同时，外界可能已经存在了一个现成的工具类TextView可以用于显示和编辑正文。理想的情况是我们可以复用这个TextView类以实现TextShape类的功能，不巧的是这个TextView类的设计者当时并没有考虑 Shape 的存在，导致TextView类和 Shape的接口互不兼容。 类似地，像上面这种情况，我们希望能够复用TextView这样已经存在的类，但此类与我们系统要求的接口不匹配，我们该如何处理呢？ 我们可以改变TextView类使它兼容Shape接口，但前提是必须有这个TextView类的源代码。然而即使我们得到了这些源代码，修改TextView也是没有什么意义的：因为不应该仅仅为了实现一个应用，就去修改那些为复用而设计的工具箱类，迫使它们实现与特定领域相关的接口(此处是 Shape 接口)。 我们可以不用上面的方法，转而定义一个TextShape类，由它来适配TextView的接口和Shape的接口。我们可以用下面两种方法做成这件事： 将TextShape继承TextView并实现Shape接口 将一个TextView实例作为TextShape的组成部分，并且使用TextView的接口去实现TextShape接口。 以上两种方法恰恰对应于Adapter模式的两个版本：类的适配器模式和对象的适配器模式。我们将TextShape称之为适配器Adapter。 从以上案例可以看出，适配器模式其实是一种补偿型模式，在进行全新系统设计的时候很少会用到。而当你遇到以下情况，你或许可以考虑使用Adapter模式。 你想使用一个已经存在的类，而它的接口不符合你的需求。 你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。 （仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。 3、适配器模式的结构适配器模式分为类的适配器模式(采用继承实现)、对象的适配器模式(采用对象组合方式实现)和接口的适配器模式三种。 类适配器通过继承对一个类与另一个接口进行匹配，如下图所示。 类适配器模式涉及的角色及其职责如下： 客户端(Client)类：该类需要与符合条件的特定的接口协同工作。 目标(Target)接口类：客户端所需要的接口，在类适配器模式下该角色只能是接口。 适配者(Adaptee)类：需要被适配的类，适配者类一般是一个具体类，包含了客户端希望使用的某些业务方法。 适配器(Adapter)类：该类对适配者类和目标接口类进行适配，在类适配器模式下通过继承方式实现，即：Adapter 继承 Adaptee 并实现 Target 接口。 类适配器模式结构示意源代码如下：Target类包含Client类所需要的与特定领域相关的接口。 public interface Target { // Adaptee适配者有此方法的实现，但方法名可以不同 void specificOperation(); // Adaptee适配者没有的其他方法 void otherOperation(); } Adaptee类包含了客户端希望使用的某些业务方法，但Adaptee类不符合Client类所需接口的要求。 public class Adaptee { public void operation() { System.out.println(&quot;执行Adaptee的operation()方法...&quot;); } } Adapter类继承Adaptee并实现Target接口，这样Adapter类既符合Client类所需接口的要求，又包含了Client类希望使用的而原属于Adaptee类的业务方法。 public class Adapter extends Adaptee implements Target { @Override public void specificOperation() { this.operation(); } @Override public void otherOperation() { System.out.println(&quot;执行Adapter的otherOperation()方法...&quot;); } } 为简单起见我们为Client类添加一个clientOperation()方法，该方法需要传入一个Target接口对象，在该Target接口对象中我们要复用现有的Adaptee类的方法。 public class Client { public static void clientOperation(Target target) { target.specificOperation(); target.otherOperation(); } public static void main(String[] args) { Adapter adapter = new Adapter(); clientOperation(adapter); } } 运行程序打印结果如下： 执行Adaptee的operation()方法…执行Adapter的otherOperation()方法… 对象适配器通过组合对一个类及其子类与另一个接口进行匹配，如下图所示。 适配器模式涉及的角色及其职责如下： 客户端(Client)类：该类需要与符合条件的特定的接口协同工作。 目标(Target)接口类：客户端所需要的接口，在对象适配器模式下该角色可以是接口、抽象类或者非final的具体类。 适配者(Adaptee)类：需要被适配的类，适配者类一般是一个具体类，包含了客户端希望使用的某些业务方法。 适配器(Adapter)类：该类对适配者类和目标接口类进行适配，在对象适配器模式下通过组合方式实现，即：Adapter类继承Target类或者实现Target接口，并在其内部包含一个Adaptee对象的引用，通过对其内部的Adaptee对象的调用实现客户端所需要的接口。 接下来以Target为接口举例，对象适配器模式结构示意源代码如下：Target类包含Client类所需要的与特定领域相关的接口。 public interface Target { // Adaptee适配者有此方法的实现，但方法名可以不同 void specificOperation(); // Adaptee适配者没有的其他方法 void otherOperation(); } Adaptee 包含了 Client 希望使用的某些业务方法，但 Adaptee 不符合 Client 的接口要求。 public class Adaptee { public void operation() { System.out.println(&quot;执行Adaptee的operation()方法...&quot;); } } Adapter 实现 Target 接口，并在其内部包含一个 Adaptee 对象的引用，通过对其内部的 Adaptee 对象的方法调用来实现客户端所需要的接口。 public class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { super(); this.adaptee = adaptee; } @Override public void specificOperation() { this.adaptee.operation(); } @Override public void otherOperation() { System.out.println(&quot;执行Adapter的otherOperation()方法...&quot;); } } 同样的，Client 依旧要与一个 Target 接口协同工作，对Client进行简单修改。 public class Client { public static void clientOperation(Target target){ target.specificOperation(); target.otherOperation(); } public static void main(String[] args) { Adapter adapter = new Adapter(new Adaptee()); clientOperation(adapter); } } 运行程序打印结果如下： 执行Adaptee的operation()方法…执行Adapter的otherOperation()方法… 接口适配器模式又被叫作缺省适配器(DefaultAdapter)模式，DefaultAdapter 为一个接口提供缺省实现，这样需实现该接口的类就可以直接从 DefaultAdapter 进行扩展，而不必再从原有接口进行扩展。当原接口中定义的方法很多，而其中大部分方法又不被需要时，这种模式非常实用。由缺省适配器类（由于该类一般都只为接口提供缺省的空实现，所以该类一般都被定义为抽象类）直接实现接口，并为所有方法提供缺省实现。这样，如果有用户类需要实现该接口就可以直接继承适配器类，并只需实现感兴趣的方法就可以了。 缺省适配器模式涉及的角色及其职责如下： 目标(Target)接口类：用户类所需要实现的接口，定义有很多方法，但这些方法不一定全都被用户类所需要。 缺省适配器(DefaultAdapter)类：实现目标接口，并为所有接口方法提供缺省实现。 具体(ConcreteClass)用户类：用户类要实现某一个接口，但是又用不到接口所规定的所有的方法。 类适配器模式结构示意源代码如下：Target接口类是用户类所需要实现的接口，该接口定义有很多方法。 public interface Target { public void operation1(); public void operation2(); public void operation3(); public void operation4(); public void operation5(); public void operation6(); } DefaultAdapter类实现Target接口，并为所有接口方法提供缺省实现。 public class DefaultAdapter implements Target { public void operation1() { System.out.println(&quot;执行缺省适配器的operation1()方法...&quot;); } public void operation2() { System.out.println(&quot;执行缺省适配器的operation2()方法...&quot;); } public void operation3() { System.out.println(&quot;执行缺省适配器的operation3()方法...&quot;); } public void operation4() { System.out.println(&quot;执行缺省适配器的operation4()方法...&quot;); } public void operation5() { System.out.println(&quot;执行缺省适配器的operation5()方法...&quot;); } public void operation6() { System.out.println(&quot;执行缺省适配器的operation6()方法...&quot;); } } 接下来就要定义用户类了，我们定义两个具体用户类 ConcreteClassA 和 ConcreteClassB ，两个类都只实现 Target 接口中的部分方法。 public class ConcreteClassA extends DefaultAdapter { public void operation3() { System.out.println(&quot;执行ConcreteClassA的operation3()方法...&quot;); } } public class ConcreteClassB extends DefaultAdapter { public void operation4() { System.out.println(&quot;执行ConcreteClassB的operation4()方法...&quot;); } public void operation5() { System.out.println(&quot;执行ConcreteClassB的operation5()方法...&quot;); } } 在很多情况下，用户类会需要实现某一个接口，但是又用不到接口所规定的所有的方法。通常的处理方法是，用户类要实现所有的方法，为那些有用的方法添加实现，为那些没有用的方法添加空的、平庸的实现。为不需要的方法添加空实现其实是一种浪费，有时也是一种混乱。除非看过这些方法的源代码或文档，程序员可能会以为这些方法不是空的。即便他知道其中有一些方法是空的，也不一定知道哪些方法是空的，哪些方法不是空的。缺省适配模式可以很好的处理这一情况。 从以上两个具体用户类 ConcreteClassA 和 ConcreteClassB的代码可以看出：两个用户类通过继承缺省适配器类，而无需再为接口中的全部方法添加实现。 4、适配器模式应用举例应用场景：SD内存卡是一种很常见的手机外置存储设备，我们可以通过给手机插入一个SD卡来扩展手机的存储空间， 当SD卡中存储的文件很多需要整理的时候问题来了，直接在手机上对SD卡中的文件进行整理(拷贝、删除、移动、修改等等)操作起来很不方便，于是我们想如果能够将SD卡插入电脑，然后通过电脑对SD卡上的文件进行整理该多方便。可不幸的是，大多数的电脑仅能连接具有USB接口的设备，显然，SD卡并不具备USB接口。 以上是适配器模式的一个典型应用场景，SD卡是专门为手机而设计的，在设计之初也并未想过要去把它插入电脑。现在我们想要把SD卡插入到电脑了，却发现SD卡因不具有USB插头而不能插入电脑。此时，再去重新设计和生产一种新型的具有USB接口的SD卡显然也并不合理。但是，很明显SD卡与U盘等USB接口设备都是存储设备，二者并无本质区别，理论上来说是完全可以插入电脑的。那么我们到底该怎么办呢？ 以上问题的解决方法其实很简单：找一个USB接口的读卡器，将SD卡插入到读卡器，再将读卡器插入电脑，此时你会发现SD卡连上电脑了。 上例中的读卡器其实就是一个适配SD卡和USB接口的适配器，接下来我们用Java代码来进行演示说明。 首先，为了使演示更加清晰，我们重新定义一个File类，用来表示SD卡中存储的文件。 public class File { //文件名 private String fileName; //文件大小 private Double fileSize; //构造方法中指定文件名和文件大小 public File(String fileName, Double fileSize) { super(); this.fileName = fileName; this.fileSize = fileSize; } public String getFileName() { return fileName; } public Double getFileSize() { return fileSize; } } 我们的SD卡类提供了基本的文件添加、文件删除、显示已存储文件的功能，其完整代码如下。 import java.util.HashMap; import java.util.Map; import java.util.Map.Entry; public class SDCard { // SD卡的存储空间总大小 private Double volume; // SD卡的可用存储空间大小 private Double vacantVolume; // 将SD卡中存储的文件保存到一个Map里面 private Map&lt;String, File&gt; fileMap = new HashMap&lt;String, File&gt;(); public SDCard(Double volume) { super(); this.volume = volume; this.vacantVolume = volume; } public Double getVacantVolume() { return vacantVolume; } public void setVacantVolume(Double vacantVolume) { this.vacantVolume = vacantVolume; } public Double getVolume() { return volume; } public Map&lt;String, File&gt; getFileMap() { return fileMap; } public void addFile(File file) { File tempFile = this.fileMap.get(file.getFileName()); if (null != tempFile) { System.out.println(&quot;文件《&quot; + file.getFileName() + &quot;》已存在，添加失败...&quot;); } else { if (this.vacantVolume &gt; file.getFileSize()) { this.fileMap.put(file.getFileName(), file); this.vacantVolume = this.vacantVolume - file.getFileSize(); System.out.println(&quot;添加文件《&quot; + file.getFileName() + &quot;》成功...&quot;); } else { System.out.println(&quot;剩余存储空间不足，文件《&quot; + file.getFileName() + &quot;》添加失败...&quot;); } } } public void deleteFile(String fileName) { File tempFile = this.fileMap.get(fileName); if (null == tempFile) { System.out.println(&quot;文件《&quot; + fileName + &quot;》不存在，删除失败...&quot;); } else { this.fileMap.remove(fileName); this.vacantVolume = this.vacantVolume + tempFile.getFileSize(); System.out.println(&quot;删除文件《&quot; + fileName + &quot;》成功...&quot;); } } public void listFiles() { if (fileMap.size() &gt; 0) { System.out.println(); System.out .println(&quot;$$$$$$$$$$$$$$$$$$$$文件列表$$$$$$$$$$$$$$$$$$$$&quot;); int i = 1; for (Entry&lt;String, File&gt; entry : fileMap.entrySet()) { System.out.println(i + &quot;. 文件名：《&quot; + entry.getValue().getFileName() + &quot;》，文件大小：&quot; + entry.getValue().getFileSize() + &quot;兆。&quot;); i++; } System.out.println(); } } } 接下来定义一个USB存储设备的接口类 USBDevice，其声明的方法如下。 import java.util.List; public interface USBDevice { //返回USB存储设备的总容量 public Double getUSBVolume(); //返回USB存储设备的剩余可用空间 public Double getUSBVacantVolume(); //列出USB存储设备中的文件信息 public void listUSBFiles(); //添加文件到USB存储设备 public void addToUSB(File file); //从USB存储设备删除单个文件 public void deleteFromUSB(String fileName); //从USB存储设备批量删除文件 public void deleteFromUSB(List&lt;String&gt; fileNames); } 接下来该定义我们的适配器类了，该类名为 CardReader (读卡器),它通过调用SD卡类中的方法实现了在 USBDevice 中声明的接口方法，代码如下。 import java.util.List; public class CardReader implements USBDevice{ private SDCard sdCard; public CardReader(SDCard sdCard) { super(); this.sdCard = sdCard; } @Override public Double getUSBVolume() { return this.sdCard.getVolume(); } @Override public Double getUSBVacantVolume() { return this.sdCard.getVacantVolume(); } @Override public void listUSBFiles() { this.sdCard.listFiles(); } @Override public void addToUSB(File file) { this.sdCard.addFile(file); } @Override public void deleteFromUSB(String fileName) { this.sdCard.deleteFile(fileName); } @Override public void deleteFromUSB(List&lt;String&gt; fileNames) { if(null!=fileNames &amp;&amp; fileNames.size()&gt;0){ for(String fileName:fileNames){ this.sdCard.deleteFile(fileName); } } } } 最后定义电脑 Computer 类，该类仅支持插入具有USB接口的设备(即实现了 USBDevice 接口的对象)，我们在此为其添加了一个 USBDevice 的内部属性代表连接到电脑的USB设备，在 Computer 类中创建一个Main方法进行测试。 import java.util.ArrayList; public class Computer { private USBDevice usbDevice; private USBDevice getUsbDevice() { return usbDevice; } private void setUsbDevice(USBDevice usbDevice) { this.usbDevice = usbDevice; } public static void main(String[] args) { // 新建一个大小为1024M的SD卡 SDCard sdCard = new SDCard(1024D); // 在SD卡中存入两个文件 sdCard.addFile(new File(&quot;Java从入门到放弃.pdf&quot;, 10D)); sdCard.addFile(new File(&quot;不良人之灵主.avi&quot;, 68D)); // 拷入重复文件测试 sdCard.addFile(new File(&quot;不良人之灵主.avi&quot;, 68D)); // 列出SD卡中文件信息 sdCard.listFiles(); // 接下来将SD卡插入到读卡器 CardReader cardReader = new CardReader(sdCard); Computer computer = new Computer(); // 再将读卡器插入电脑 computer.setUsbDevice(cardReader); computer.getUsbDevice().addToUSB(new File(&quot;唐伯虎点秋香.rmvb&quot;, 600D)); computer.getUsbDevice().addToUSB(new File(&quot;C++基础算法.txt&quot;, 0.01D)); computer.getUsbDevice().addToUSB(new File(&quot;冰河世纪4.rmvb&quot;, 888D)); computer.getUsbDevice().listUSBFiles(); computer.getUsbDevice().deleteFromUSB(&quot;Java从入门到放弃.pdf&quot;); computer.getUsbDevice().listUSBFiles(); computer.getUsbDevice().deleteFromUSB(new ArrayList&lt;String&gt;() { { add(&quot;Java从入门到放弃.pdf&quot;); add(&quot;不良人之灵主.avi&quot;); } }); computer.getUsbDevice().listUSBFiles(); } } 运行程序结果打印如下： 添加文件《Java从入门到放弃.pdf》成功…添加文件《不良人之灵主.avi》成功…文件《不良人之灵主.avi》已存在，添加失败… $$$$$$$$$$$$$$$$$$$$文件列表$$$$$$$$$$$$$$$$$$$$ 文件名：《Java从入门到放弃.pdf》，文件大小：10.0兆。 文件名：《不良人之灵主.avi》，文件大小：68.0兆。 添加文件《唐伯虎点秋香.rmvb》成功…添加文件《C++基础算法.txt》成功…剩余存储空间不足，文件《冰河世纪4.rmvb》添加失败… $$$$$$$$$$$$$$$$$$$$文件列表$$$$$$$$$$$$$$$$$$$$ 文件名：《唐伯虎点秋香.rmvb》，文件大小：600.0兆。 文件名：《Java从入门到放弃.pdf》，文件大小：10.0兆。 文件名：《C++基础算法.txt》，文件大小：0.01兆。 文件名：《不良人之灵主.avi》，文件大小：68.0兆。 删除文件《Java从入门到放弃.pdf》成功… $$$$$$$$$$$$$$$$$$$$文件列表$$$$$$$$$$$$$$$$$$$$ 文件名：《唐伯虎点秋香.rmvb》，文件大小：600.0兆。 文件名：《C++基础算法.txt》，文件大小：0.01兆。 文件名：《不良人之灵主.avi》，文件大小：68.0兆。 文件《Java从入门到放弃.pdf》不存在，删除失败…删除文件《不良人之灵主.avi》成功… $$$$$$$$$$$$$$$$$$$$文件列表$$$$$$$$$$$$$$$$$$$$ 文件名：《唐伯虎点秋香.rmvb》，文件大小：600.0兆。 文件名：《C++基础算法.txt》，文件大小：0.01兆。 5、适配器模式的选择通过使用适配器模式，我们可以达到以下目的： 复用现有的类，解决现有类和复用环境要求不一致的问题。 将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码。 一个对象适配器可以把适配者类和它的子类都适配到目标接口。 类适配器模式和对象适配器模式比较： 类适配器通过继承方式来实现，是静态的；而对象适配器通过组合方式来实现，是动态的。 对于类适配器，适配器直接继承自 Adaptee ，这使得适配器不能和 Adaptee 的子类一起工作。 对于对象适配器，同一个适配器可以把 Adaptee 和它的子类都适配到目标接口。 对于类适配器，适配器可以重定义 Adaptee 的部分行为，相当于子类覆盖父类的部分实现方法。 对于对象适配器，要重定义 Adaptee 的行为比较困难，这种情况下，需要定义 Adaptee 的子类来实现重定义，然后让适配器组合子类。 参考文章&lt; GoF经典的著作《 Design Patterns: Elements of Reusable Object-Oriented Software 》（《设计模式：可复用面向对象软件的基础》）&gt; https://www.ibm.com/developerworks/cn/java/j-lo-adapter-pattern/index.html https://blog.csdn.net/name_110/article/details/6903819 https://www.cnblogs.com/xwdreamer/archive/2012/03/29/2424008.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"适配器模式,Java,设计模式","slug":"适配器模式-Java-设计模式","permalink":"/tags/适配器模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--动态代理模式（下）","slug":"Java设计模式之--动态代理模式（下）","date":"2020-05-24T08:47:47.000Z","updated":"2023-04-30T10:21:41.355Z","comments":true,"path":"2020/05/24/Java设计模式之--动态代理模式（下）/","link":"","permalink":"/2020/05/24/Java设计模式之--动态代理模式（下）/","excerpt":"","text":"一、前章回顾在前一章动态代理模式（上）中我们分别使用JDK自带的动态代理和CGLIB动态代理为数据库增加了日志记录功能。然而，生成的动态代理类到底是个什么样子呢？本章我们就一起来揭开它的庐山真面目。 二、深入剖析JAVA动态代理类我们先来看看生成的动态代理类是什么类型，对前一章第二节中示例的客户端进行如下简单修改，将生成的动态代理类实例的类型打印到控制台。 import java.lang.reflect.Proxy; public class MainClass { public static void main(String[] args) { // 创建用来处理代理对象请求的调用处理程序userHandler UserDao userDao = new ImpUserDao(); DataBaseLogHandler userHandler = new DataBaseLogHandler(userDao); // 创建用来处理代理对象请求的调用处理程序documentHandler DocumentDao doucumentDao = new ImpDocumentDao(); DataBaseLogHandler documentHandler = new DataBaseLogHandler(doucumentDao); // 开始创建代理对象，分别实现接口UserDao和DocumentDao UserDao userProxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[] { UserDao.class }, userHandler); DocumentDao documentProxy = (DocumentDao) Proxy.newProxyInstance(DocumentDao.class.getClassLoader(), new Class[] { DocumentDao.class }, documentHandler); // 将两个代理类的类型打印到控制台 System.out.println(&quot;实现了UserDao接口的动态代理类型为：&quot; + userProxy.getClass()); System.out.println(&quot;实现了DocumentDao接口的动态代理类型为：&quot; + documentProxy.getClass()); // 接下来我们再创建两个动态代理类对象，二者都实现UserDao和DocumentDao两个接口，只是接口实现的先后顺序不同 UserDao udProxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[] { UserDao.class, DocumentDao.class }, userHandler); DocumentDao duProxy = (DocumentDao) Proxy.newProxyInstance(DocumentDao.class.getClassLoader(), new Class[] { DocumentDao.class, UserDao.class }, documentHandler); // 将这两个代理类的类型也打印到控制台 System.out.println(&quot;实现了UserDao和DocumentDao接口的动态代理类型为：&quot; + udProxy.getClass()); System.out.println(&quot;实现了DocumentDao和UserDao接口的动态代理类型为：&quot; + duProxy.getClass()); } } 运行程序打印结果如下：实现了UserDao接口的动态代理类型为：class $Proxy0实现了DocumentDao接口的动态代理类型为：class $Proxy1实现了UserDao和DocumentDao接口的动态代理类型为：class $Proxy2实现了DocumentDao和UserDao接口的动态代理类型为：class $Proxy3 原来生成的动态代理类都是形似 $Proxy0、$Proxy1、$Proxy2、$Proxy3 这种类型，同时，貌似生成的动态代理类的类型与传入方法newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 中的interfaces接口数组参数有关，而且接口数组中接口的先后顺序也会对最后生成的动态代理类的类型产生影响（这一点貌似sun做得不是很好）。 知晓了这一点，接下来我们再刨深点，看看这些代理类到底长什么样子，对MainClass再进行修改。 import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import java.lang.reflect.Proxy; public class MainClass { public static void main(String[] args) { UserDao userDao = new ImpUserDao(); DataBaseLogHandler userHandler = new DataBaseLogHandler(userDao); UserDao userProxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[] { UserDao.class }, userHandler); System.out.println(&quot;实现了UserDao接口的动态代理类的类型为：&quot; + userProxy.getClass()); // 接下来我们在创建两个动态代理类对象，二者都实现UserDao和DocumentDao两个接口，只是接口实现的先后顺序不同 UserDao udProxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[] { UserDao.class, DocumentDao.class }, userHandler); System.out.println(&quot;实现了UserDao和DocumentDao接口的动态代理类的类型为：&quot; + udProxy.getClass()); System.out.println(&quot;&quot;); Class userProxyClass = userProxy.getClass(); Class udProxyClass = udProxy.getClass(); printClassDefinition(userProxyClass); printClassDefinition(udProxyClass); } public static String getModifier(int modifier) { String result = &quot;&quot;; switch (modifier) { case Modifier.PRIVATE: result = &quot;private&quot;; case Modifier.PUBLIC: result = &quot;public&quot;; case Modifier.PROTECTED: result = &quot;protected&quot;; case Modifier.ABSTRACT: result = &quot;abstract&quot;; case Modifier.FINAL: result = &quot;final&quot;; case Modifier.NATIVE: result = &quot;native&quot;; case Modifier.STATIC: result = &quot;static&quot;; case Modifier.SYNCHRONIZED: result = &quot;synchronized&quot;; case Modifier.STRICT: result = &quot;strict&quot;; case Modifier.TRANSIENT: result = &quot;transient&quot;; case Modifier.VOLATILE: result = &quot;volatile&quot;; case Modifier.INTERFACE: result = &quot;interface&quot;; } return result; } public static void printClassDefinition(Class clz) { String clzModifier = getModifier(clz.getModifiers()); if (clzModifier != null &amp;&amp; !clzModifier.equals(&quot;&quot;)) { clzModifier = clzModifier + &quot; &quot;; } String superClz = clz.getSuperclass().getName(); if (superClz != null &amp;&amp; !superClz.equals(&quot;&quot;)) { superClz = &quot;extends &quot; + superClz; } Class[] interfaces = clz.getInterfaces(); String inters = &quot;&quot;; for (int i = 0; i &lt; interfaces.length; i++) { if (i == 0) { inters += &quot;implements &quot; + interfaces[i].getName(); } else { inters += &quot;,&quot; + interfaces[i].getName(); } } System.out.println(clzModifier + clz.getName() + &quot; &quot; + superClz + &quot; &quot; + inters); System.out.println(&quot;{&quot;); Field[] fields = clz.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) { String modifier = getModifier(fields[i].getModifiers()); if (modifier != null &amp;&amp; !modifier.equals(&quot;&quot;)) { modifier = modifier + &quot; &quot;; } String fieldName = fields[i].getName(); String fieldType = fields[i].getType().getName(); System.out.println(&quot; &quot; + modifier + fieldType + &quot; &quot; + fieldName + &quot;;&quot;); } System.out.println(); Method[] methods = clz.getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) { Method method = methods[i]; String modifier = getModifier(method.getModifiers()); if (modifier != null &amp;&amp; !modifier.equals(&quot;&quot;)) { modifier = modifier + &quot; &quot;; } String methodName = method.getName(); Class returnClz = method.getReturnType(); String retrunType = returnClz.getName(); Class[] clzs = method.getParameterTypes(); String paraList = &quot;(&quot;; for (int j = 0; j &lt; clzs.length; j++) { paraList += clzs[j].getName(); if (j != clzs.length - 1) { paraList += &quot;, &quot;; } } paraList += &quot;)&quot;; clzs = method.getExceptionTypes(); String exceptions = &quot;&quot;; for (int j = 0; j &lt; clzs.length; j++) { if (j == 0) { exceptions += &quot;throws &quot;; } exceptions += clzs[j].getName(); if (j != clzs.length - 1) { exceptions += &quot;, &quot;; } } exceptions += &quot;;&quot;; String methodPrototype = modifier + retrunType + &quot; &quot; + methodName + paraList + exceptions; System.out.println(&quot; &quot; + methodPrototype); } System.out.println(&quot;}&quot;); } } 运行程序打印结果如下：实现了UserDao接口的动态代理类型为：class $Proxy0实现了UserDao和DocumentDao接口的动态代理类型为：class $Proxy1实现了UserDao接口的动态代理类型为：class $Proxy0实现了UserDao和DocumentDao接口的动态代理类型为：class $Proxy1 $Proxy0 extends java.lang.reflect.Proxy implements UserDao { java.lang.reflect.Method m1; java.lang.reflect.Method m3; java.lang.reflect.Method m4; java.lang.reflect.Method m0; java.lang.reflect.Method m2; java.lang.String login(java.lang.Long, java.lang.String); java.lang.String logout(); boolean equals(java.lang.Object); java.lang.String toString(); int hashCode(); } $Proxy1 extends java.lang.reflect.Proxy implements UserDao，DocumentDao { java.lang.reflect.Method m1; java.lang.reflect.Method m6; java.lang.reflect.Method m3; java.lang.reflect.Method m5; java.lang.reflect.Method m4; java.lang.reflect.Method m0; java.lang.reflect.Method m2; java.lang.String login(java.lang.Long, java.lang.String); java.lang.String logout(); java.lang.String add(Document); boolean equals(java.lang.Object); java.lang.String toString(); int hashCode(); java.lang.String delete(Document); } 这下子似乎是清晰了一点，生成的代理类继承了java.lang.reflect.Proxy类，并实现了作为参数传入newProxyInstance()方法中的 Class&lt;?&gt;[] interfaces 接口数组，但由于Java的反射机制并不能获取到方法体的具体内容，所以动态代理类方法体的具体内容我们还不得而知。为此，我们不得不另辟蹊径：使用class字节码文件反编译方法，以期待能够看到动态代理类中方法体的具体内容。 由于 Proxy.newProxyInstance()方法在生成动态代理类字节码文件的时候会调用到 sun.misc.ProxyGenerator.generateProxyClass()方法，在 Proxy.newProxyInstance()方法调用之前可以进行设置,将generateProxyClass()生成的代理类的字节码文件以 .class 文件的形式备份到当前Java项目的根目录下,配置代码如下： System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);使用软件对上例中实现了UserDao接口的代理类 $Proxy0 的字节码文件进行反编译，其完整内容如下。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements UserDao { private static Method m1; private static Method m3; private static Method m4; private static Method m0; private static Method m2; public $Proxy0(InvocationHandler invocationHandler) throws { super(invocationHandler); } public final boolean equals(Object object) throws { try { return (Boolean)this.h.invoke(this, m1, new Object[]{object}); } catch (Error | RuntimeException v0) { throw v0; } catch (Throwable var2_2) { throw new UndeclaredThrowableException(var2_2); } } public final String login(Long l) throws { try { return (String)this.h.invoke(this, m3, new Object[]{l}); } catch (Error | RuntimeException v0) { throw v0; } catch (Throwable var2_2) { throw new UndeclaredThrowableException(var2_2); } } public final String logout() throws { try { return (String)this.h.invoke(this, m4, null); } catch (Error | RuntimeException v0) { throw v0; } catch (Throwable var1_1) { throw new UndeclaredThrowableException(var1_1); } } public final int hashCode() throws { try { return (Integer)this.h.invoke(this, m0, null); } catch (Error | RuntimeException v0) { throw v0; } catch (Throwable var1_1) { throw new UndeclaredThrowableException(var1_1); } } public final String toString() throws { try { return (String)this.h.invoke(this, m2, null); } catch (Error | RuntimeException v0) { throw v0; } catch (Throwable var1_1) { throw new UndeclaredThrowableException(var1_1); } } static { try { m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m3 = Class.forName(&quot;UserDao&quot;).getMethod(&quot;login&quot;, Class.forName(&quot;java.lang.Long&quot;)); m4 = Class.forName(&quot;UserDao&quot;).getMethod(&quot;logout&quot;, new Class[0]); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]); return; } catch (NoSuchMethodException var1) { throw new NoSuchMethodError(var1.getMessage()); } catch (ClassNotFoundException var1_1) { throw new NoClassDefFoundError(var1_1.getMessage()); } } } 通过对以上动态代理类字节码文件反编译的内容的观察，我们不难得出以下结论：所谓动态代理，其实就是java.lang.reflect.Proxy类动态地根据你所指定的接口生成一个class 字节码文件，该 class 会继承 Proxy 类，并实现所有你指定的接口（您在newProxyInstance()方法的参数中传入的 Class&lt;?&gt;[] interfaces 接口数组）中的所有方法，同时，还会从java.lang.Object继承equals()、toString()、hashCode()三个方法；然后再利用你指定的类加载器（您在newProxyInstance()方法的参数中传入的 ClassLoader loader）将 class 字节码文件加载进系统，最后生成这样一个类的对象，并初始化该对象的一些值、以及所有的 Method 成员， 初始化之后将对象返回给调用的客户端，这样客户端拿到的就是一个实现你指定的所有接口的Proxy对象了。然后，客户端在调用该动态代理对象的方法时会通过动态代理类中的 this.h.invoke()方法自动将请求转发给与动态代理对象关联的InvocationHandler对象(您在newProxyInstance()方法的参数中传入的 InvocationHandler h)的invoke()方法，由invoke()方法来实现对请求的统一处理并返回处理结果。 参考文章https://www.cnblogs.com/xiaoluo501395377/p/3383130.html https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/ http://www.lxway.com/4445954962.htm https://blog.csdn.net/lovelion/article/details/8116704 https://blog.csdn.net/hejingyuan6/article/details/36203505 https://blog.csdn.net/rokii/article/details/4046098","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"代理模式,Java,设计模式,动态","slug":"代理模式-Java-设计模式-动态","permalink":"/tags/代理模式-Java-设计模式-动态/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--动态代理模式（上）","slug":"Java设计模式之--动态代理模式（上）","date":"2020-05-24T08:46:29.000Z","updated":"2023-04-30T10:21:41.355Z","comments":true,"path":"2020/05/24/Java设计模式之--动态代理模式（上）/","link":"","permalink":"/2020/05/24/Java设计模式之--动态代理模式（上）/","excerpt":"","text":"一、什么是动态代理在静态代理(Static Proxy)模式中，代理类都是真实存在的，由程序员提前创建好的java类，是静态的，每一个代理类在编译之后都会生成一个.class字节码文件，静态代理类所实现的接口和所代理的方法早在编译期都已被固定了。 动态代理(Dynamic Proxy)则不同：动态代理使用字节码动态生成和加载技术，在系统运行时动态地生成和加载代理类。 与静态代理相比，动态代理有以下优点： 首先，无需再为每一个真实主题写一个形式上完全一样的代理类，假如抽象主题接口中的方法很多的话，为每一个接口方法写一个代理方法也很麻烦，同样地，如果后期抽象主题接口发生变动，则真实主题和代理类都要修改，不利于系统维护； 其次，动态代理可以让系统根据实际需要来动态创建代理类，同一个代理类能够代理多个不同的真实主题类，并且可以代理多个不同的方法。 二、Java对动态代理的支持从JDK 1.3版本开始，Java语言提供了对动态代理的支持，在Java中实现动态代理机制，需要用到 java.lang.reflect 包中的 InvocationHandler 接口和 Proxy 类,我们先来看看java的API帮助文档是怎么样对这两个类进行描述的： InvocationHandlerInvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler. 大致的意思是： InvocationHandler 是代理实例的调用处理程序实现的接口。 每个代理实例都具有一个与之关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程 序的 invoke() 方法。 invoke() 方法形式如下： Object invoke(Object proxy,Method method,Object[] args) throws Throwable InvocationHandler 接口只包含invoke()这唯一一个方法，该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含三个参数，其中第一个参数proxy表示代理类的实例，第二个参数method表示需要代理的方法，第三个参数args表示代理方法的参数数组。 ProxyProxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods. 大致的意思是： Proxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。Proxy提供给我们的静态方法有以下四个： //返回指定代理实例的调用处理程序。 static InvocationHandler getInvocationHandler(Object proxy) //返回代理类的 java.lang.Class 对象，并向其提供类加载器和接口数组。 static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;[] interfaces) //当且仅当指定的类通过 getProxyClass 方法或 newProxyInstance 方法动态生成为代理类时，返回 true。 static boolean isProxyClass(Class&lt;?&gt; cl) //返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。 //方法中的 ClassLoader loader 参数用来指定动态代理类的类加载器，Class&lt;?&gt;[] interfaces用来指定动态代理类要实现的接口。 //InvocationHandler h 用来指定与即将生成的动态代理对象相关联的调用处理程序 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 下面我们以为数据库增加日志记录功能（为简单起见，我们仅记录下所有操作的执行时间及操作执行的结果）为例来看一看如何使用这两个类实现动态代理： 为了使演示更清晰，在此先定义两个简单类，一个User类和一个Document类分别表示数据库中的用户记录和文档记录，其代码如下。 public class User { // 用户在数据库中的ID private Long id; // 用户的姓名 private String name; public User(Long id, String name) { super(); this.id = id; this.name = name; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } public class Document { // 文档在数据库中的ID private Long id; // 文档的标题 private String title; public Document(Long id, String title) { super(); this.id = id; this.title = title; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } } 另外还需定义一个DataBase类用来扮演数据库的功能，在此为简单起见，将数据库中的用户记录和文档记录分别存储在一个Map中，代码如下。 import java.util.HashMap; import java.util.Map; public class DataBase { private static Map&lt;Long, User&gt; userMap = null; private static Map&lt;Long, Document&gt; documentMap = null; // 用来记录当前登陆用户信息 private static User currentUser = null; private DataBase() { // 数据初始化，为数据库中增加几条用户记录。。。 userMap = new HashMap&lt;Long, User&gt;(); userMap.put(20160708L, new User(20160708L, &quot;燕凌娇&quot;)); userMap.put(20160709L, new User(20160709L, &quot;姬如雪&quot;)); userMap.put(20160710L, new User(20160710L, &quot;百里登风&quot;)); // 数据初始化，为数据库中增加几条文档记录。。。 documentMap = new HashMap&lt;Long, Document&gt;(); documentMap.put(30160708L, new Document(30160708L, &quot;C++常用算法手册&quot;)); documentMap.put(30160709L, new Document(30160709L, &quot;深入理解Android内核设计思想&quot;)); documentMap.put(30160710L, new Document(30160710L, &quot;Java从入门到放弃&quot;)); } public User getCurrentUser() { return currentUser; } public void setCurrentUser(User currentUser) { DataBase.currentUser = currentUser; } public Map&lt;Long, User&gt; getUserMap() { return userMap; } public Map&lt;Long, Document&gt; getDocumentMap() { return documentMap; } public static DataBase getDataBaseInstance() { return DataBaseHolder.dataBase; } public static class DataBaseHolder { private static DataBase dataBase = new DataBase(); } } 数据库布置完成了，接下来开始写动态代理相关代码了，为了与静态代理进行比较，在此我们来创建两个接口（抽象主题角色）。 public interface UserDao { // 登陆数据库，为了演示方便将字符串作为执行结果返回 String login(Long id); // 退出数据库，为了演示方便将字符串作为执行结果返回 String logout(); } public interface DocumentDao { // 新增文档，为了演示方便将字符串作为执行结果返回 String add(Document document); // 删除文档，为了演示方便将字符串作为执行结果返回 String delete(Document document); } 接下来是两个真实主题角色，ImpUserDao 类和ImpDocumentDao类，为了使示例结果清晰，此处将接口的执行结果直接以字符串形式返回。 public class ImpUserDao implements UserDao { @Override public String login(Long id) { User user = DataBase.getDataBaseInstance().getUserMap().get(id); if (null != user) { // 数据库有此用户的信息，则允许登陆... DataBase.getDataBaseInstance().setCurrentUser(user); return &quot;用户[&quot; + user.getName() + &quot;]登陆成功...&quot;; } else { // 数据库没有此用户信息，则不让登陆... return &quot;登陆失败，ID为\\&quot;&quot; + id + &quot;\\&quot;的用户不存在！&quot;; } } @Override public String logout() { User user = DataBase.getDataBaseInstance().getCurrentUser(); if (null != user) { // 若当前有用户登陆，则退出成功... DataBase.getDataBaseInstance().setCurrentUser(null); return &quot;用户[&quot; + user.getName() + &quot;]退出登陆成功...&quot;; } else { // 若当前无用户登陆，则退出失败... return &quot;退出登陆失败，当前无登陆用户！&quot;; } } } public class ImpDocumentDao implements DocumentDao { @Override public String add(Document document) { User user = DataBase.getDataBaseInstance().getCurrentUser(); if (null == user) { // 若当前用户未登陆，则新增文档失败... return &quot;保存失败，未获取到登陆信息！&quot;; } else { Document dbDocument = DataBase.getDataBaseInstance().getDocumentMap().get(document.getId()); if (null != dbDocument) { // 若数据库中已经存在该ID的文档，则新增文档失败... return &quot;添加文档《&quot; + document.getTitle() + &quot;》失败，文档已存在！&quot;; } else { // 若该ID的文档在数据库不存在，则新增文档成功... DataBase.getDataBaseInstance().getDocumentMap().put(document.getId(), document); return &quot;添加文档《&quot; + document.getTitle() + &quot;》成功...&quot;; } } } @Override public String delete(Document document) { User user = DataBase.getDataBaseInstance().getCurrentUser(); if (null == user) { // 若当前用户未登陆，则新增文档失败... return &quot;保存失败，未获取到登陆信息！&quot;; } else { Document dbDocument = DataBase.getDataBaseInstance().getDocumentMap().get(document.getId()); if (null == dbDocument) { // 若数据库中该文档不存在，则删除文档失败... return &quot;删除文档《&quot; + document.getTitle() + &quot;》失败，文档不存在！&quot;; } else { // 若数据库中该文档存在，则删除文档成功... DataBase.getDataBaseInstance().getDocumentMap().remove(document.getId()); return &quot;删除文档《&quot; + document.getTitle() + &quot;》成功...&quot;; } } } } 最后，我们就要定义动态代理类了，前面说过，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Calendar; import java.util.GregorianCalendar; public class DataBaseLogHandler implements InvocationHandler { private Object object; private Calendar calendar; public DataBaseLogHandler(Object object) { super(); this.object = object; } // invoke()方法用于处理对代理类实例的方法调用并返回相应的结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { before(method); // 继续转发请求给内部真实主题角色 Object result = method.invoke(object, args); after(result); if (method.getName().equalsIgnoreCase(&quot;logout&quot;)) { System.out.println(&quot;$$$$$$$$$$$$$$$$$$$$$$$$&quot;); System.out.println(&quot;&quot;); } return result; } public void before(Method method) { calendar = new GregorianCalendar(); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int date = calendar.get(Calendar.DATE); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); String time = hour + &quot;时&quot; + minute + &quot;分&quot; + second + &quot;秒&quot;; System.out.println(&quot;北京时间：&quot; + year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot; + time + &quot;,执行方法\\&quot;&quot; + method.getName() + &quot;\\&quot;&quot;); } public void after(Object object) { System.out.println(&quot;执行结果:&quot; + object); } } 至此，动态代理所需要的类就算创建完成了，接下来创建一个Client充当客户端来测试一下。 import java.lang.reflect.Proxy; public class MainClass { public static void main(String[] args) { // 此处来创建了两个动态代理类对象... UserDao userDao = new ImpUserDao(); DataBaseLogHandler userHandler = new DataBaseLogHandler(userDao); DocumentDao doucumentDao = new ImpDocumentDao(); DataBaseLogHandler documentHandler = new DataBaseLogHandler(doucumentDao); UserDao userProxy = (UserDao) Proxy.newProxyInstance(UserDao.class.getClassLoader(), new Class[] { UserDao.class }, userHandler); DocumentDao documentProxy = (DocumentDao) Proxy.newProxyInstance(DocumentDao.class.getClassLoader(), new Class[] { DocumentDao.class }, documentHandler); // 先输入一个不存在的用户Id登陆试试... userProxy.login(20160718L); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); userProxy.logout(); // 再用一个真实用户Id登陆试试... userProxy.login(20160708L); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); userProxy.logout(); } } 运行程序打印结果如下： 北京时间：2016年6月11日19时33分46秒,执行方法”login”执行结果:登陆失败，ID为”20160718”的用户不存在！北京时间：2016年6月11日19时33分46秒,执行方法”add”执行结果:保存失败，未获取到登陆信息！北京时间：2016年6月11日19时33分46秒,执行方法”logout”执行结果:退出登陆失败，当前无登陆用户！$$$$$$$$$$$$$$$$$$$$$$$$ 北京时间：2016年6月11日19时33分46秒,执行方法”login”执行结果:用户[燕凌娇]登陆成功…北京时间：2016年6月11日19时33分46秒,执行方法”add”执行结果:添加文档《转角遇见幸福》成功…北京时间：2016年6月11日19时33分46秒,执行方法”add”执行结果:添加文档《转角遇见幸福》失败，文档已存在！北京时间：2016年6月11日19时33分46秒,执行方法”logout”执行结果:用户[燕凌娇]退出登陆成功…$$$$$$$$$$$$$$$$$$$$$$$$ 从以上程序的最终运行结果可以看出：通过使用JDK自带的动态代理，我们同时实现了对ImpUserDao和ImpDocumentDao两个真实主题类的统一代理和集中控制。至于该动态代理类是如何被创建的？将在下一篇文章详细讨论，接下来我们先看看如何使用CGLIB实现动态代理。 三、使用CGLIB实现动态代理生成动态代理类的方法很多，如上例中JDK自带的动态代理、CGLIB、Javassist 或者 ASM 库。JDK 的动态代理使用简单，它内置在 JDK 中，因此不需要引入第三方 Jar 包，但相对功能比较弱。CGLIB 和 Javassist 都是高级的字节码生成库，总体性能比 JDK 自带的动态代理好，而且功能十分强大。ASM 是低级的字节码生成工具，使用 ASM 已经近乎于在使用 Java bytecode 编程，对开发人员要求最高，当然，也是性能最好的一种动态代理生成工具。但 ASM 的使用很繁琐，而且性能也没有数量级的提升，与 CGLIB 等高级字节码生成工具相比，ASM 程序的维护性较差，如果不是在对性能有苛刻要求的场合，还是推荐 CGLIB 或者 Javassist。 接下来我们继续用上面的例子来体验一下如何使用CGLIB实现动态代理。 首先，使用CGLIB来实现动态代理需引入“asm.jar”(CGLIB的底层是使用ASM实现的)和“cglib.jar”两个第三方jar包,引入两个jar包时需注意其版本，若版本有冲突会出现以下异常： Exception in thread “main” java.lang.NoSuchMethodError: org.objectweb.asm.ClassWriter.(I)V 接下来开始写代码，延用上例中的：User类、Document类、DataBase类、两个抽象主题接口UserDao和DocumentDao、两个真实主题角色类ImpUserDao和ImpDocumentDao，这几个类无需做任何修改，此处不再重复贴出。 去掉上例中的 DataBaseLogHandler 类，新增一个 CglibProxy 类，该类需实现CGLIB的 MethodInterceptor(方法拦截) 接口。 import java.lang.reflect.Method; import java.util.Calendar; import java.util.GregorianCalendar; import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; public class CglibProxy implements MethodInterceptor { private Calendar calendar; /** * 创建动态代理类对象 * * @param clazz * 需要创建子类代理的父类的类型 * * @return */ public Object getProxyInstance(Class&lt;?&gt; clazz) { Enhancer enhancer = new Enhancer(); // 设置要创建的动态代理类的父类 enhancer.setSuperclass(clazz); // 设置回调的对象，此句会导致调用动态代理类对象的方法会被指派到CglibProxy对象的intercept()方法 enhancer.setCallback(this); // 通过字节码技术动态创建动态代理类实例 return enhancer.create(); } @Override // 回调方法 public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { before(method); // 通过动态子类代理实例调用父类的方法 Object result = proxy.invokeSuper(obj, args); after(result); if (method.getName().equalsIgnoreCase(&quot;logout&quot;)) { System.out.println(&quot;**********************************&quot;); System.out.println(&quot;&quot;); } return result; } public void before(Method method) { calendar = new GregorianCalendar(); int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); int date = calendar.get(Calendar.DATE); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); String time = hour + &quot;时&quot; + minute + &quot;分&quot; + second + &quot;秒&quot;; System.out .println(&quot;北京时间：&quot; + year + &quot;年&quot; + month + &quot;月&quot; + date + &quot;日&quot; + time + &quot;,执行方法\\&quot;&quot; + method.getName() + &quot;\\&quot;&quot;); } public void after(Object object) { System.out.println(&quot;执行结果:&quot; + object); } } 对客户端进行相应修改，如下。 public class MainClass { public static void main(String[] args) { // 创建一个CglibProxy代理类对象，用来创建子类代理实例 CglibProxy cglib = new CglibProxy(); // 为ImpUserDao类添加一个动态代理类对象，即子类代理对象 UserDao userProxy = (UserDao) cglib.getProxyInstance(ImpUserDao.class); // 为ImpDocumentDao类添加一个动态代理类对象，即子类代理对象 DocumentDao documentProxy = (DocumentDao) cglib.getProxyInstance(ImpDocumentDao.class); // 先输入一个不存在的用户Id登陆试试... userProxy.login(20160718L); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); userProxy.logout(); // 再用一个真实用户Id登陆试试... userProxy.login(20160708L); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); documentProxy.add(new Document(30160711L, &quot;转角遇见幸福&quot;)); userProxy.logout(); } } 运行程序结果打印如下，与之前使用JDK自带动态代理程序运行结果完全相同： 北京时间：2016年6月12日20时22分35秒,执行方法”login”执行结果:登陆失败，ID为”20160718”的用户不存在！北京时间：2016年6月12日20时22分35秒,执行方法”add”执行结果:保存失败，未获取到登陆信息！北京时间：2016年6月12日20时22分35秒,执行方法”logout”执行结果:退出登陆失败，当前无登陆用户！$$$$$$$$$$$$$$$$$$$$$$$$北京时间：2016年6月12日20时22分35秒,执行方法”login”执行结果:用户[燕凌娇]登陆成功…北京时间：2016年6月12日20时22分35秒,执行方法”add”执行结果:添加文档《转角遇见幸福》成功…北京时间：2016年6月12日20时22分35秒,执行方法”add”执行结果:添加文档《转角遇见幸福》失败，文档已存在！北京时间：2016年6月12日20时22分35秒,执行方法”logout”执行结果:用户[燕凌娇]退出登陆成功…$$$$$$$$$$$$$$$$$$$$$$$$ PS:CGLib创建的动态代理对象性能比JDK创建的动态代理对象的性能高不少，但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。同时，由于CGLib采用动态创建子类的方法来对被代理的父类的功能进行增强和代理，所以，无法对被声明为final的类或方法进行代理。 四、动态代理模式的特点动态代理类使用字节码动态生成加载技术，在运行时生成并加载代理类。与静态代理相比，动态代理具有以下优点： 无需单独为每一个接口添加一个代理类，使用动态代理可以一次性为多个接口实现代理。 无需逐个为接口中的所有方法添加实现，使用动态代理可以一次性为多个接口中的所有方法实现代理，在接口方法数量比较多的时候，可以避免出现大量的重复代码。 动态代理的缺点： 目前，JDK中提供的动态代理只能对接口实现代理，无法代理未实现接口的类。如果需要动态代理未实现接口的类，必须借助第三方工具，如：CGLib(Code Generation Library)等。 参考文章https://www.cnblogs.com/xiaoluo501395377/p/3383130.html https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/ http://www.lxway.com/4445954962.htm https://blog.csdn.net/lovelion/article/details/8116704 https://blog.csdn.net/hejingyuan6/article/details/36203505 https://blog.csdn.net/rokii/article/details/4046098","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"代理模式,Java,设计模式,动态","slug":"代理模式-Java-设计模式-动态","permalink":"/tags/代理模式-Java-设计模式-动态/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--静态代理模式","slug":"Java设计模式之--静态代理模式","date":"2020-05-24T08:44:45.000Z","updated":"2023-04-30T10:21:41.363Z","comments":true,"path":"2020/05/24/Java设计模式之--静态代理模式/","link":"","permalink":"/2020/05/24/Java设计模式之--静态代理模式/","excerpt":"","text":"一、什么是代理模式代理（Proxy）模式为其他对象提供一种代理以控制对这个对象的访问。（原文：The Proxy Pattern Provide a surrogate or placeholder for another object to control access to it.） 代理模式的作用：在客户端和被代理对象之间起到中介作用，通过代理可以有效地控制客户端对被代理对象的直接访问，进而可以很好地隐藏和保护被代理对象。 代理模式按照其代理类生成方式的不同又可以分为静态代理和动态代理两种，本章先跟大家来聊聊静态代理。 二、静态代理模式的结构代理模式是一种结构型设计模式，在代理模式中，代理与被代理的对象通常要实现相同的接口，以便在需要的时候可以使用代理来替代被代理对象，客户端必须通过代理与被代理对象进行交互，并且可以在交互的过程中（交互前后）添加一些额外的功能。 静态代理模式的UML结构示意图如下。 静态代理模式涉及的角色及其职责： 抽象主题(Subject)角色：这是一个抽象角色，通常被定义为接口，真实主题角色和代理主题角色都需实现此接口，以便将来可以使用代理主题对象来替代真实主题对象。 真实主题(RealSubject)角色：也叫被代理角色，是代理主题角色所代表的真实对象，是业务逻辑的实际执行者。 代理主题(Proxy)角色：也叫代理角色，该角色内部含有对真实主题对象的引用，从而可以操作真实主题对象，同时代理对象提供与真实主题对象相同的接口以便在任何时刻都能代替真实主题对象。通常代理角色会在将客户端调用传递给真实主题对象之前或者之后执行某些操作，而不是单纯地将调用传递给真实主题对象。 静态代理模式结构示意源代码如下： 抽象主题(Subject)角色 public interface Subject { // 声明真实主题角色和代理主题角色都需实现的方法 public void operation(); } 真实主题(RealSubject)角色 public class RealSubject implements Subject { //实现了抽象主题角色定义的接口 @Override public void operation() { System.out.println(&quot;调用真实主题对象执行操作进行中...&quot;); } } 代理主题(Proxy)角色 public class Proxy implements Subject { //包含一个真实主题对象的引用 private Subject realSubject; public Proxy(Subject realSubject) { this.realSubject = realSubject; } public void before() { System.out.println(&quot;调用真实主题对象之前进行的相关操作...&quot;); } public void after() { System.out.println(&quot;调用真实主题对象之后进行的相关操作...&quot;); } //通过调用内部真实主题对象的引用实现了抽象主题角色定义的接口，并添加了一些额外处理功能 @Override public void operation() { before(); realSubject.operation(); after(); } } 在MainClass中测一下： public class MainClass { public static void main(String[] args) { Subject realSubject=new RealSubject(); Proxy proxy= new Proxy(realSubject); proxy.operation(); } } 运行程序打印结果如下： 调用真实主题对象之前进行的相关操作…调用真实主题对象执行操作进行中…调用真实主题对象之后进行的相关操作… 从上面的例子可以看出代理对象将客户端的调用委派给被代理对象，并在调用被代理对象的方法之前和之后执行了一些特殊操作，此种模式与装饰模式有点相似，两者的区别在于：代理模式的目的在于控制访问，装饰模式的目的在于添加功能。 PS：不理解代理模式与装饰模式之间区别？没关系，待我们讲完接下来数据库连接池的例子，相信你一定会有所领悟。 三、静态代理模式应用举例在软件设计中，使用代理模式的意图很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节 (如 RMI)，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 应用一我们都知道，对于一个简单的数据库应用，由于对于数据库的访问不是很频繁。这时可以简单地在需要访问数据库时，就新创建一个连接，用完后就关闭它，这样做也不会带来什么明显的性能上的开销。但是对于一个复杂的数据库应用，情况就完全不同了，频繁的建立、关闭数据库连接，会极大的降低系统的性能，此时，对于连接的使用就成了系统性能的瓶颈。 由于存在以上弊病，我们一般都是通过使用数据库连接池来解决连接问题，即创造一堆等待被使用的连接，等到用的时候就从连接池里取一个，不用了再放回去，数据库连接在整个应用启动期间，几乎是不关闭的。 但是在程序员编写程序的时候，会经常使用connection.close()这样的方法，去关闭数据库连接，而且这样做是对的，所以你并不能告诉程序员们说，你们使用连接都不要关了，去调用一个其他的类似方法将连接重新归还给连接池吧。这是不符合程序员的编程思维的，也很勉强，而且具有风险性，因为程序员会忘的。 解决这一问题的办法就是使用代理模式，因为通过代理可以有效控制客户端对被代理对象的直接访问，客户端只能通过代理与被代理对象进行交互，这样代理可以很轻易对被代理对象的行为进行扩展或者修改，而我们在这里要做的就是替换掉connection的close()方法。 为清晰起见，我在此重新创建了一个连接接口名为IConnection，它包含query()和close()两个方法。 public interface IConnection { // 执行一条查询语句 void query(); // 关闭连接 void close(); } 接下来写一个实现的IConnection接口的ImpConnection类，它扮演了代理模式中的真实主题角色。 public class ImpConnection implements IConnection { @Override public void query() { System.out.println(&quot;执行一条查询语句...&quot;); } @Override public void close() { System.out.println(&quot;关闭连接...&quot;); } } 接下来我们要写代理类ConnectionProxy，代理类也要实现IConnection这个接口，由于通过继承方式实现代理模式不够灵活，推荐使用组合方式。 public class ConnectionProxy implements IConnection { private IConnection iConnection; public ConnectionProxy(IConnection iConnection) { super(); this.iConnection = iConnection; } @Override public void query() { //对于我们不关心的方法，直接调用真实对象去处理 iConnection.query(); } @Override public void close() { // 不真正关闭连接，而是将连接归还给连接池 ConnectionPool.getInstance().returnConnection(iConnection); } } 接下来是连接池的简单代码 import java.util.LinkedList; public class ConnectionPool { private static LinkedList&lt;IConnection&gt; connectionList = new LinkedList&lt;IConnection&gt;(); private static IConnection createNewConnection() { return new ImpConnection(); } private ConnectionPool() { if (connectionList == null || connectionList.size() == 0) { for (int i = 0; i &lt; 10;) { System.out.println(&quot;创建第 &quot; + (++i) + &quot; 个连接...&quot;); connectionList.add(createNewConnection()); } System.out.println(&quot;连接池初始化完成...&quot;); showConnectionCount(); } } public static void showConnectionCount() { System.out.println(&quot;当前连接池可用连接数为： &quot; + connectionList.size()); } public IConnection getConnection() { if (connectionList.size() &gt; 0) { // return connectionList.remove(); // 这是原有的方式，直接返回连接，这样可能会出现程序员把连接给关闭掉的情况 // 下面是使用代理的方式，程序员再调用close时，就会调用代理的close()方法把连接归还到连接池 IConnection iConnection = null; iConnection = connectionList.remove(); System.out.println(&quot;从连接池获取一条连接...&quot;); showConnectionCount(); return new ConnectionProxy(iConnection); } return null; } public void returnConnection(IConnection connection) { System.out.println(&quot;将连接归还给连接池。。。&quot;); connectionList.add(connection); showConnectionCount(); } public static ConnectionPool getInstance() { return ConnectionPoolInstance.connectionPool; } private static class ConnectionPoolInstance { private static ConnectionPool connectionPool = new ConnectionPool(); } } 在MainClass里面测试一下。 public class MainClass { public static void main(String[] args) { // 此条语句用来测试单例ConnectionPool是否实现延迟加载 // 由于未使用连接，此条语句不会导致数据库连接池内连接初始化 ConnectionPool.showConnectionCount(); System.out.println(&quot;----------接下来要从连接池取连接了----------&quot;); IConnection connection = ConnectionPool.getInstance().getConnection(); System.out.println(&quot;----------可以使用连接进行数据库操作了----------&quot;); // 使用连接执行查询语句 connection.query(); connection.query(); System.out.println(&quot;----------连接用完了之后，该归还连接了----------&quot;); connection.close(); } } 运行程序结果打印：当前连接池可用连接数为： 0———-接下来要从连接池取连接了———-创建第 1 个连接…创建第 2 个连接…创建第 3 个连接…创建第 4 个连接…创建第 5 个连接…创建第 6 个连接…创建第 7 个连接…创建第 8 个连接…创建第 9 个连接…创建第 10 个连接… 连接池初始化完成…当前连接池可用连接数为： 10 从连接池获取一条连接…当前连接池可用连接数为： 9 ———-可以使用连接进行数据库操作了———-执行一条查询语句…执行一条查询语句… ———-连接用完了之后，该归还连接了———-将连接归还给连接池。。。 当前连接池可用连接数为： 10 好了，这下我们的连接池返回的连接全是代理，就算程序员调用了close方法也只会把连接归还给连接池了。如果我们使用连接池getConnection()方法中被注释掉的语句 “return connectionList.remove();“ ，直接返回连接对象，那么以上MainClass中连接用完了之后连接池中的可用连接数将变为：9，即连接被真正关闭了。 我们使用代理模式解决了上述问题，从静态代理的使用上来看，我们一般是这么做的。 代理类一般要持有一个被代理的对象的引用。 对于我们不关心的方法，全部委托给被代理的对象处理。 我们只处理我们关心的方法。 应用二以上示例使用单例模式实现了ConnectionPool对象的延迟加载，示例稍微有点复杂，接下来我们再以一个简单的示例来感受一下使用代理模式实现延迟加载的方法及其意义。 延迟加载(lazy load)(也称为懒加载)是为了避免一些无谓的性能开销而提出来的，所谓延迟加载就是当在真正需要数据的时候，才去执行数据加载操作。延迟加载的实际应用很多：比如使用浏览器打开网站，浏览器一般总是先加载文本，待文本显示出来以后再加载图片、视频等耗时较多的资源，这样做的好处是用户不必非要等到所有东西都下载完成以后才能看到页面，可以极大地减少用户的等待时间；又比如Windows操作系统的启动过程，若我们将系统的所有服务项都设置为开机启动，那么我们每次启动计算机都需要等待非常长的时间，所以我们一般都是将系统必须的服务和一些常用服务设置为开机启动，对于那些不常用的服务我们只在用到的时候再去开启，这样做可以减少每次开机时系统启动所需时间，提高系统的启动速度。 接下来该引出我们的第二个例子了： 假设某客户端软件有根据用户请求去数据库查询数据的功能，在查询数据前，需要获得数据库连接，如果我们在软件开启时就去初始化并获得数据库连接，会存在以下弊端：软件开启时需初始化系统的所有类，如果系统还有大量类似资源耗费较多的操作(比如 XML 解析，本地或远程文件资源加载)也需在此时进行初始化，所有这些初始化操作的叠加会使得系统的启动速度变得非常缓慢。为此，我们使用代理模式的代理类对数据库查询类的初始化操作进行封装，当系统启动时，初始化这个代理类，而非真实的数据库查询类，由于此时代理类什么都没有做，因此，它的构造是相当迅速的。在用户真正做查询操作时再由代理类单独去加载真实的数据库查询类，完成用户的请求，这样就使用代理模式实现了延迟加载。 源代码如下： 定义一个接口 IConnection 作为抽象主题角色，该接口用来定义代理类和真实主题类需要对外提供的服务，本例只在其中定义了一个用来进行数据库查询的 query()方法。 public interface IConnection { void query(); } ImpConnection 是真实主题角色，负责实际的业务操作。 public class ImpConnection implements IConnection { ImpConnection() { try { for (int i = 0; i &lt; 3; i++) { System.out.println(&quot;ImpConnection对象创建中...&quot;); Thread.sleep(1000);// 假设数据库连接等耗时操作 } System.out.println(&quot;ImpConnection对象创建完成...&quot;); } catch (InterruptedException ex) { ex.printStackTrace(); } } @Override public void query() { System.out.println(&quot;执行一次数据库查询操作...&quot;); } } ConnectionProxy 是 ImpConnection 的代理类。 public class ConnectionProxy implements IConnection { private ImpConnection connection = null; @Override public void query() { // 在真正需要的时候才能创建真实对象，创建过程可能很慢 if (connection == null) { connection = new ImpConnection(); } connection.query(); } } 在MainClass中进行数据库查询测试。 public class MainClass { public static void main(String[] args) { IConnection connection = new ConnectionProxy(); // 使用代理 connection.query(); // 在真正使用时才创建真实主题对象 } } 运行程序结果打印：ImpConnection对象创建中…ImpConnection对象创建中…ImpConnection对象创建中…ImpConnection对象创建完成…执行一次数据库查询操作… 将MainClass中的 “connection.query();” 一行删除之后，将再没有任何结果打印到控制台，由此证明：若没有发生请求，将不会创建ImpConnection对象，使用代理模式实现了被代理对象延迟加载的功能。 使用代理模式实现延迟加载的核心思想是：如果当前并没有使用这个组件，则不需要真正地初始化它，使用一个代理对象替代它的原有的位置，只在真正需要的时候才对它进行加载。使用代理模式的延迟加载是非常有意义的，首先，它可以在时间轴上分散系统压力，尤其在系统启动时，不必完成所有的初始化工作，从而加快启动速度；其次，对很多真实主题而言，在软件启动直到被关闭的整个过程中，可能根本不会被调用，初始化这些数据无疑是一种资源浪费。例如上面这个例子，若系统不使用代理模式，则在启动时就要初始化 ImpConnection 对象，而使用代理模式后，启动时只需要初始化一个轻量级的 ConnectionProxy对象。 四、代理模式的应用场景代理模式主要应用于以下几个场景： 远程代理，也就是为一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实。比如说 WebService，当我们在应用程序的项目中加入一个 Web 引用，引用一个 WebService，此时会在项目中声称一个 WebReference 的文件夹和一些文件，这个就是起代理作用的，这样可以让那个客户端程序调用代理解决远程访问的问题； 虚拟代理，是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。这样就可以达到性能的最优化，比如打开一个网页，这个网页里面包含了大量的文字和图片，但我们可以很快看到文字，但是图片却是一张一张地下载后才能看到，那些未打开的图片框，就是通过虚拟代理来替换了真实的图片，此时代理存储了真实图片的路径和尺寸； 安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候； 指针引用，是指当调用真实对象时，代理处理另外一些事。比如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它，或当第一次引用一个持久对象时，将它装入内存，或是在访问一个实际对象前，检查是否已经释放它，以确保其他对象不能改变它。这些都是通过代理在访问一个对象时附加一些事务处理； 延迟加载，用代理模式实现延迟加载的一个经典应用就在 Hibernate 框架里面。当 Hibernate 加载实体 bean 时，并不会一次性将数据库所有的数据都装载。默认情况下，它会采取延迟加载的机制，以提高系统的性能。Hibernate 中的延迟加载主要分为属性的延迟加载和关联表的延时加载两类。实现原理是使用代理拦截原有的 getter 方法，在真正使用对象数据时才去数据库或者其他第三方组件加载实际的数据，从而提升系统性能。 PS：此外还有防火墙代理，智能引用代理，缓存代理，同步代理，复杂隐藏代理，写入时复制代理等等，都有各自特殊的用途。 五、静态代理模式的特点静态代理的优点： 被代理对象只要和代理类实现了同一接口即可，代理类无须知道被代理对象具体是什么类、怎么做的，而客户端只需知道代理即可，实现了类之间的解耦合。 静态代理的缺点： 代理类和被代理类实现了相同的接口，代理类通过被代理类实现了相同的方法，这样就出现了大量的代码重复。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。 每个代理类只能为一个接口服务，如果程序开发中要使用代理的接口很多的话，必然会产生许多的代理类，造成类膨胀。 参考文章http://http//www.lxway.com/4445954962.htm https://blog.csdn.net/lovelion/article/details/8116704 https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"代理模式,Java,设计模式,静态","slug":"代理模式-Java-设计模式-静态","permalink":"/tags/代理模式-Java-设计模式-静态/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--观察者模式","slug":"Java设计模式之--观察者模式","date":"2020-05-24T08:43:06.000Z","updated":"2023-04-30T10:21:41.361Z","comments":true,"path":"2020/05/24/Java设计模式之--观察者模式/","link":"","permalink":"/2020/05/24/Java设计模式之--观察者模式/","excerpt":"","text":"一、什么是观察者模式 观察者(Observer)模式是行为模式之一，它的作用是当一个被观察对象的状态发生变化时，能够自动通知相关的观察者对象，自动更新观察者对象中被观察对象的状态。它提供给关联对象一种同步通信的手段，使某个对象与依赖它的其他对象之间保持状态同步。 二、观察者模式的典型应用观察者(Observer)模式多被应用于以下场景： 侦听事件驱动程序设计中的外部事件 侦听/监视某个对象的状态变化 发布者/订阅者(publisher/subscriber)模型中，当一个外部事件（新的产品，消息的出现等等）被触发时，通知邮件列表中的订阅者 三、观察者模式的结构 观察者模式中的角色及其职责如下： 抽象被观察者（Subject）角色 被观察对象的抽象类，为所有具体被观察者角色提供了一个统一接口，主要包括添加、删除、通知观察者对象方法，其内包含一个用以储存所有观察者对象的容器（Collection），当被观察者的状态发生变化时，需要通知容器中所有观察者对象，并维护（添加，删除，通知）观察者对象列表。 具体被观察者（ConcreteSubject）角色 被观察者的具体实现，包含一些基本的属性状态及其他操作，当具体被观察者的状态发生变化时，会给注册的所有观察者对象发送通知，以提示观察者对象们对其内被观察对象的状态进行更新。 抽象观察者（Observer）角色 这是一个抽象角色，通常被定义为接口，为所有的具体观察者定义一个接口，当收到被观察对象状态发生变化的通知时更新自己。 具体观察者（ConcreteObserver）角色 观察者的具体实现，得到通知后将对内部被观察对象的状态进行更新，并完成一些具体的业务逻辑处理。 观察者模式结构示意源代码如下： 抽象被观察者（Subject）角色 public abstract class Subject { //用来保存注册过的观察者 private List&lt;Observer&gt; observers=new ArrayList&lt;Observer&gt;(); //注册一个观察者 public void registerObserver(Observer observer){ this.observers.add(observer); } //删除一个观察者 public void unregisterObserver(Observer observer){ this.observers.remove(observer); } //通知所有观察者进行状态更新 public void notifyObservers(Subject subject){ for(Observer o:observers){ o.update(subject); } } } 具体被观察者（ConcreteSubject）角色 public class ConcreteSubject extends Subject { //具体被观察者类可以具有自己的属性或状态 private String state; public String getState() { return state; } public void setState(String newState){ this.state = newState; System.out.println(&quot;被观察者自身状态更新为：&quot; + this.state); //状态发生改变，通知所有观察者 this.notifyObservers(this); } } 抽象观察者（Observer）角色 public interface Observer{ //更新观察者的状态 public void update(Subject subject); } 具体观察者（ConcreteObserver）角色 public class ConcreteObserverA implements Observer { private ConcreteSubject subject; public ConcreteSubject getSubject() { return subject; } public void setSubject(ConcreteSubject subject) { this.subject = subject; } @Override public void update(Subject subject) { this.subject=(ConcreteSubject)subject; System.out.println(&quot;观察者A中被观察对象的状态更新为：&quot;+this.subject.getState()); } } public class ConcreteObserverB implements Observer { private ConcreteSubject subject; public ConcreteSubject getSubject() { return subject; } public void setSubject(ConcreteSubject subject) { this.subject = subject; } @Override public void update(Subject subject) { this.subject=(ConcreteSubject)subject; System.out.println(&quot;观察者B中被观察对象的状态更新为：&quot;+this.subject.getState()); } } 编写一个MainClass类来测试一番。 public class MainClass { public static void main(String[] args) { //创建被观察者对象 ConcreteSubject subject=new ConcreteSubject(); //创建观察者对象 ConcreteObserverA observerA=new ConcreteObserverA(); ConcreteObserverB observerB=new ConcreteObserverB(); //为被观察者对象注册观察者 subject.registerObserver(observerA); subject.registerObserver(observerB); subject.setState(&quot;复活中...&quot;); System.out.println(); System.out.println(&quot;----------一千年以后...----------&quot;); System.out.println(); subject.setState(&quot;疯狂杀戮中...&quot;); } } 运行MainClass打印结果如下： 被观察者自身状态更新为：复活中…观察者A中被观察对象的状态更新为：复活中…观察者B中被观察对象的状态更新为：复活中…———-一千年以后…———-被观察者自身状态更新为：疯狂杀戮中…观察者A中被观察对象的状态更新为：疯狂杀戮中…观察者B中被观察对象的状态更新为：疯狂杀戮中… 四、Java对观察者模式的支持在JAVA语言的java.util库里面有一个Observable类和一个Observer接口，通过两者配合使用可以实现观察者模式。 Observable类： Observable中文意思“可以被观察的”，即Observable类是可以被观察的，想要实现观察者模式只需将你想要被观察的类继承自Observable类即可。 一个 Observable对象可以有一个或多个观察者，观察者可以是实现了Observer接口的任意对象。一个Observable对象状态改变后,会调用notifyObservers()方法来通知观察者。 以下是Observable类提供的一些常用方法： public void addObserver(Observer o) //向观察者集合中添加观察者 public void deleteObserver(Observer o) //从观察者集合中删除某一个观察者 public void notifyObservers(Object arg) //如果hasChanged方法指示对象已改变，则通知其所有观察者，并调用 clearChanged 方法来清除对象的已改变标记。此方法可不带参数，仅将Observable对象传递给update()方法，此时update方法中arg参数为Null。 public void deleteObservers() //清除观察者列表，使此对象不再有任何观察者 protected void setChanged() //标记Observable对象已经改变 protected void clearChanged() //清除Observable对象已改变标记 public boolean hasChanged() //测试对象是否改变 public int countObservers() //返回Observable对象的观察者数目 Observer接口： Observer接口只包含一个update()方法,该方法仅接受两个参数：继承自Observable类的被观察对象和传递给notifyObservers() 方法的参数。当Observable(被观察者)对象状态发生改变时将通过notifyObservers()方法向所有的Observer(观察者)发送更新通知，Observer(观察者)对象在收到通知后即调用此方法完成状态更新。 void update(Observable o, Object arg) 接下来我们举个简单的例子来演示一下如何使用Observable类和Observer接口实现观察者模式，去年2015年是牛市，炒股的基本都发家了，在此我们以炒股为例。 在炒股这个例子中，不用我说，相信你也想的到：股票Stock就是我们的被观察者。 import java.util.Observable; public class Stock extends Observable{ //为股票的状态创建一个枚举类：RISE 涨,FALL 跌 public enum StockState{ RISE,FALL } //股票涨跌状态 private StockState state; //股票的价格 private double price; //股票的历史最低价格 private double LowestPrice; //股票无参的构造方法 public Stock(){ } //股票的带参数构造方法 public Stock(StockState state, double price, double lowestPrice) { super(); this.state = state; this.price = price; LowestPrice = lowestPrice; } public StockState getState() { return state; } private void setState(StockState state) { this.state = state; } public double getPrice() { return price; } public void setPrice(double price) { if(price&lt;this.price){ setState(StockState.FALL); } else{ setState(StockState.RISE); } if(price&lt;this.LowestPrice){ setLowestPrice(price); } this.price = price; //更新股票状态标记为已改变 this.setChanged(); //通知观察者 notifyObservers(); } public double getLowestPrice() { return LowestPrice; } private void setLowestPrice(double lowestPrice) { LowestPrice = lowestPrice; } } 我们这些只有韭菜命的股民自然就是观察者了。 import java.util.Observable; import java.util.Observer; import com.ibeifeng.news.Stock.StockState; public class Investor implements Observer { public void update(Observable o, Object arg) { Stock stock=(Stock)o; if(stock.getPrice()==stock.getLowestPrice()) { System.out.println(&quot;股票已经跌到历史最低了，我得赶紧抄底...&quot;); } else{ if(stock.getState().equals(StockState.RISE)){ System.out.println(&quot;股票在涨，目前价格：&quot;+stock.getPrice()); } else{ System.out.println(&quot;股票在跌，目前价格：&quot;+stock.getPrice()); } } } } 在客户端里面测试一下。 public class Client{ public static void main(String[] args) { Stock stock=new Stock(StockState.FALL,14.7D,13.2D); stock.addObserver(new Investor()); stock.setPrice(13.7); stock.setPrice(12.6); stock.setPrice(14.0); } } 运行程序打印结果如下： 股票在跌，目前价格：13.7股票已经跌到历史最低了，我得赶紧抄底…股票在涨，目前价格：14.0 五、观察者模式的优点观察者Observer模式解决了对象之间一对多的复杂依赖关系问题，大大地提高了程序的可维护性和可扩展性，也很好的符合了开放-封闭原则。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"观察者模式,Java,设计模式","slug":"观察者模式-Java-设计模式","permalink":"/tags/观察者模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--策略模式","slug":"Java设计模式之--策略模式","date":"2020-05-24T08:41:38.000Z","updated":"2023-04-30T10:21:41.359Z","comments":true,"path":"2020/05/24/Java设计模式之--策略模式/","link":"","permalink":"/2020/05/24/Java设计模式之--策略模式/","excerpt":"","text":"一、什么是策略模式策略（Strategy）模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。（原文：The Strategy Pattern defines a family of algorithms,encapsulates each one,and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.） 二、策略模式的结构 在策略模式中的角色有： 抽象策略(Strategy)角色:这是一个抽象角色，通常由一个接口或抽象类实现,用以声明所有具体策略类要实现的方法。 具体策略(ConcreteStrategy)角色:各种策略（算法）的具体实现。 环境(Context)角色:策略的外部封装类，或者说策略的容器类，它持有一个Strategy的引用，Strategy策略由客户端决定，不同Strategy策略可以执行不同的行为。 策略模式结构示意源代码如下： 抽象策略(Strategy)角色 public interface Strategy { // 抽象策略角色 public void strategyInterface(); } 具体策略(ConcreteStrategy)角色 public class ConcreteStrategyA implements Strategy { // 具体策略角色 @Override public void strategyInterface() { // 相关的业务 } } public class ConcreteStrategyB implements Strategy { // 具体策略角色 @Override public void strategyInterface() { // 相关的业务 } } public class ConcreteStrategyC implements Strategy { // 具体策略角色 @Override public void strategyInterface() { // 相关的业务 } } 环境(Context)角色 public class Context { // 持有一个具体策略的对象 private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } // 环境角色策略方法 public void contextInterface() { strategy.strategyInterface(); } } 从策略模式中环境(Context)角色的功能可以看出，策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性，它体现了面向对象程序设计中两个非常重要的原则： 封装变化 把一个类中经常改变或者将来可能改变的部分提取出来，作为一个接口（也可以是抽象类），然后在类中包含实现了这个接口的实例，这样这个类就可以通过其内包含的实例来实现接口的行为。 依赖倒转(Dependence Inversion Principle ) 编程中更多地使用抽象，而不是具体的实现。 三、策略模式应用场景超市出售商品的折扣是一个很复杂的问题，对于不同类型的顾客会有不同的折扣，在不同的时间购买商品也有可能折扣不同，我们假设超市的折扣有以下几种情况： 对普通顾客，没有折扣。 对普通会员，所有商品9.5折。 对VIP会员，所有商品9.0折。 使用策略模式模拟以上折扣的算法： 抽象策略（Strategy）角色 public interface DiscountStrategy { /** * 计算打折后的价格 * * @param num * 商品原价 * @return 折后价格 */ public double calcPrice(double num); } 实现DiscountStrategy（折扣策略）接口的具体策略角色。 普通顾客策略类 public class CommonCustomerStrategy implements DiscountStrategy { @Override public double calcPrice(double num) { // 普通会员没有折扣 return num; } } 普通会员策略类 public class CommonMemberStrategy implements DiscountStrategy { @Override public double calcPrice(double num) { // 普通会员9.5折 return num * 0.95; } } VIP会员策略类 public class VipMemberStrategy implements DiscountStrategy { @Override public double calcPrice(double num) { // 普通会员9.0折 return num * 0.9; } } 环境角色类 public class Price { // 持有一个具体的策略对象 private DiscountStrategy strategy; // 构造方法中传入一个具体的策略对象 public Price(DiscountStrategy strategy) { this.strategy = strategy; } public double calcPrice(double num) { // 调用内部包含的策略对象方法计算价格 return this.strategy.calcPrice(num); } } 创建一个MainClass类测试一番 public class MainClass { public static void main(String[] args) { // 商品原价 double num = 200; // 普通顾客策略计算折后价格 Price price = new Price(new CommonCustomerStrategy()); double newPrice = price.calcPrice(num); System.out.println(&quot;普通顾客购买该商品的折后价格是：&quot; + newPrice); // 普通会员策略计算折后价格 price = new Price(new CommonMemberStrategy()); newPrice = price.calcPrice(num); System.out.println(&quot;普通会员购买该商品的折后价格是：&quot; + newPrice); // VIP会员策略计算折后价格 price = new Price(new VipMemberStrategy()); newPrice = price.calcPrice(num); System.out.println(&quot;VIP会员购买该商品的折后价格是：&quot; + newPrice); } } 运行程序打印结果： 普通顾客购买该商品的折后价格是：200.0普通会员购买该商品的折后价格是：190.0VIP会员购买该商品的折后价格是：180.0 从以上示例可以看出策略模式的意图是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。策略模式自身并不能决定何时该采用哪种策略算法，该使用何种算法是由客户端来决定的。 四、策略模式的特点优点： 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 使用策略模式可以避免使用（if-else）多重条件转移语句。多重条件转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么具体策略类的数目就会很可观。 参考文章http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"策略模式,Java,设计模式","slug":"策略模式-Java-设计模式","permalink":"/tags/策略模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--装饰模式","slug":"Java设计模式之--装饰模式","date":"2020-05-24T08:36:36.000Z","updated":"2023-04-30T10:21:41.361Z","comments":true,"path":"2020/05/24/Java设计模式之--装饰模式/","link":"","permalink":"/2020/05/24/Java设计模式之--装饰模式/","excerpt":"","text":"一、什么是装饰模式装饰（ Decorator ）模式又叫做包装( Wrapper )模式，它通过一种对客户端透明的方式来扩展对象的功能，是继承关系的一个替换方案。 二、装饰模式实现装饰模式通过一种对客户端透明的方式动态地为一个对象附加上新的功能，它可以使客户端在不需要创建更多子类的情况下，自由地对创建对象的功能进行扩展，装饰模式是继承关系的一个替换方案。 举个简单的例子：沙发可以坐、可以躺，我们还可以为它添加上按摩功能使它成为保健沙发，我们还可以为它添加上可以展开供人睡觉的功能让它变成沙发床，接下来我们就使用子类继承方式来模拟为沙发添加上这些新功能。 首先我们要定义一个沙发Sofa的接口用以声明所有沙发都应该具有的功能，此处额外增加了一个show()方法用来展示沙发的功能。 public interface Sofa { // 测试方法，用以展示沙发具有的功能 public void show(); // 坐 public void sit(); // 躺 public void lie(); } 接下来我们就要声明普通沙发CommonSofa、SofaBed和HealthCareSofa三种沙发了。 普通沙发只能坐和躺。 public class CommonSofa implements Sofa { @Override public void show() { this.sit(); this.lie(); } @Override public void sit() { System.out.println(&quot;可以坐&quot;); } @Override public void lie() { System.out.println(&quot;可以躺&quot;); } } 沙发床除了能坐和躺外，还可以睡觉。 public class SofaBed implements Sofa { @Override public void show() { this.sit(); this.lie(); this.sleep(); } @Override public void sit() { System.out.println(&quot;可以坐&quot;); } @Override public void lie() { System.out.println(&quot;可以躺&quot;); } public void sleep() { System.out.println(&quot;可以睡觉&quot;); } } 保健沙发除了坐和躺外，还可以按摩。 public class HealthCareSofa implements Sofa { @Override public void show() { this.sit(); this.lie(); this.massage(); } @Override public void sit() { System.out.println(&quot;可以坐&quot;); } @Override public void lie() { System.out.println(&quot;可以躺&quot;); } public void massage() { System.out.println(&quot;可以按摩&quot;); } } 创建一个客户端来进行测试。 public class Client { public static void main(String[] args) { System.out.println(&quot;---------普通沙发功能如下：---------&quot;); Sofa commonSofa = new CommonSofa(); commonSofa.show(); System.out.println(); System.out.println(&quot;---------沙发床功能如下：---------&quot;); Sofa sofaBed = new SofaBed(); sofaBed.show(); System.out.println(); System.out.println(&quot;---------保健沙发功能如下：---------&quot;); Sofa healthCareSofa = new HealthCareSofa(); healthCareSofa.show(); } } 运行程序打印结果如下： ———普通沙发功能如下：———可以坐 可以躺———沙发床功能如下：———可以坐 可以躺 可以睡觉———保健沙发功能如下：———可以坐 可以躺 可以按摩 以上是通过继承来实现沙发Sofa功能的扩展，功能实现了但却有个严重的缺陷：通过继承实现的功能扩展是静态的，我们必须提前预知需要为对象添加哪些功能，并创建好相应的子类，对象能够扩展哪些功能这是在java虚拟机对类进行加载编译时就已经决定了的，因而是静态的。还是以沙发Sofa为例，如果我们需要创建一个既能睡觉又能按摩的保健沙发床对象时，我们就不得不再新添加一个Sofa的子类（保健沙发床）并为其附加上sleep()和massage()两个方法，倘若以后沙发又增加上可拆洗的功能，对各个功能进行组合我们就要再增加可拆洗沙发、可拆洗沙发床、可拆洗保健沙发、可拆洗保健沙发床四个子类，功能若继续增加势必造成子类数量的成倍增加，出现”类膨胀”情况。 装饰模式的设计初衷：以一种更为灵活的方式动态地为对象附加一些新功能，装饰模式的实现结构图如下： 装饰模式涉及的角色及其职责如下： 抽象组件(Component)角色： 一个抽象接口，是被装饰类（ConcreteComponent）和装饰类（Decorator）的父接口。 具体组件(ConcreteComponent)角色：抽象组件的实现类。 抽象装饰(Decorator)角色：包含一个组件的引用，并定义了与抽象组件一致的接口。 具体装饰(ConcreteDecorator)角色：为抽象装饰角色的实现类，负责具体的装饰(为组件附加上新的功能)。 接下来我们使用装饰模式来实现沙发的功能扩展，首先定义一个沙发Sofa的接口同上，担当装饰模式中的抽象组件角色。 public interface Sofa { // 测试方法，用以展示沙发所具有的功能 public void show(); // 坐 public void sit(); // 躺 public void lie(); } 再定义一个Sofa接口的实现类，扮演装饰模式中的具体组件角色。 public class CommonSofa implements Sofa { @Override public void show() { this.sit(); this.lie(); } @Override public void sit() { System.out.println(&quot;可以坐&quot;); } @Override public void lie() { System.out.println(&quot;可以躺&quot;); } } 再定义一个抽象装饰角色，其内部要包含一个被装饰对象的引用，并实现抽象组件的所有接口 public class SofaDecorator implements Sofa { // 私有的被装饰对象的引用 private Sofa sofa; // 公有的获取被装饰对象的方法 public Sofa getSofa() { return sofa; } public void setSofa(Sofa sofa) { this.sofa = sofa; } public SofaDecorator(Sofa sofa) { this.sofa = sofa; } public void show() { this.sit(); this.lie(); } @Override public void sit() { System.out.println(&quot;可以坐&quot;); } @Override public void lie() { System.out.println(&quot;可以躺&quot;); } } 最后创建具体装饰角色，为被装饰对象附件上新功能 public class BedDecorator extends SofaDecorator { public BedDecorator(Sofa sofa) { super(sofa); } public void show() { this.getSofa().show(); this.sleep(); } // 为沙发添加睡觉功能 public void sleep() { System.out.println(&quot;可以睡觉&quot;); } } public class HealthCareDecorator extends SofaDecorator { public HealthCareDecorator(Sofa sofa) { super(sofa); } public void show() { this.getSofa().show(); this.massage(); } // 为沙发添加按摩功能 public void massage() { System.out.println(&quot;可以按摩&quot;); } } 创建一个客户端测试一下，其代码如下： public class MainClass { public static void main(String[] args) { // 先创建一个要被装饰的普通沙发对象 Sofa sofa = new CommonSofa(); System.out.println(&quot;---------普通沙发功能如下：---------&quot;); sofa.show(); System.out.println(); // 用BedDecorator对创建好的普通沙发对象进行装饰，为其增加睡觉功能 System.out.println(&quot;---------沙发床功能如下：---------&quot;); Sofa sofaBed = new BedDecorator(sofa); sofaBed.show(); System.out.println(); // 用HealthCareDecorator对创建好的普通沙发对象进行装饰，为其增加按摩功能 System.out.println(&quot;---------保健沙发功能如下：---------&quot;); Sofa healthCareSofa = new HealthCareDecorator(sofa); healthCareSofa.show(); System.out.println(); // 用HealthCareDecorator对创建好的沙发床对象进行装饰，为其增加按摩功能 System.out.println(&quot;---------保健沙发床功能如下：---------&quot;); Sofa healthCareSofaBed = new HealthCareDecorator(sofaBed); healthCareSofaBed.show(); } } 运行程序打印结果如下： ———普通沙发功能如下：———可以坐 可以躺———沙发床功能如下：———可以坐 可以躺 可以睡觉———保健沙发功能如下：———可以坐 可以躺 可以按摩———保健沙发床功能如下：———可以坐 可以躺 可以睡觉 可以按摩 装饰模式通过对普通沙发的功能进行层层装饰，最终连具有保健和睡觉功能的沙发也创建成功了。 三、装饰模式的特点 装饰对象和真实对象有相同的接口。 装饰对象包含一个真实对象的引用（reference） 装饰对象接受所有的来自客户端的请求。它把这些请求转发给真实的对象。 装饰对象可以在转发这些请求以前或以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。 参考文章http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"装饰模式,Java,设计模式","slug":"装饰模式-Java-设计模式","permalink":"/tags/装饰模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--建造者模式","slug":"Java设计模式之--建造者模式","date":"2020-05-24T08:35:22.000Z","updated":"2023-04-30T10:21:41.357Z","comments":true,"path":"2020/05/24/Java设计模式之--建造者模式/","link":"","permalink":"/2020/05/24/Java设计模式之--建造者模式/","excerpt":"","text":"前言在听完厉风行老师《设计模式系列课程》中的建造者模式一节后顿时感觉有点头大，感觉它有点像工厂方法模式，查看了网上很多文章也是众说纷纭，看到了corn的这篇文章才有点拨开云雾见晴天的感觉。 一、什么是建造者模式建造者（Builder）模式也叫生成器模式，是由GoF提出的23种设计模式中的一种，其设计意图是：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 GoF给出的描述很简短，不易理解，我是这样理解的：我们要创建的对象会包含有各种各样的属性（可以是对象，也可以不是对象，就好比汽车的零配件），这些属性就叫做这个对象的表示，有了属性之后我们还需要将这些属性按照一定的规则或者顺序组装起来才能创造出对象来（这就好比用汽车零件组装汽车），而这个组装的过程就是对象的构建，Builder模式将对象的表示与对象的构建分别交由建造者和指挥者去负责，整个对象的创建过程对客户端是隐藏的，客户端只需要去调用建造者和指挥者去创建对象，而不必关系这个对象都有哪些属性，以及各个属性之间是怎么样进行组装的，达到了责任划分和封装的目的。 二、建造者模式的结构建造者模式适合于创建比较复杂的对象，所谓复杂有两个方向： 创建过程复杂，创建的步骤有严格的顺序。 创建对象的结构复杂，创建对象包含的属性数量多。 针对以上两类的复杂对象Builder模式也分别演化出了两种表现形式。 第一种：通过Product、ConcreteBuilder、Builder和Director形成的建造者模式。 从上图可以看出，这种Builder模式包含4个角色：产品(Product)，具体建造者(ConcreteBuilder)，建造者(Builder)，指挥者(Director) 产品：需要创建的对象产品 建造者：本质为抽象类，里面的抽象方法供具体建造者重写。 具体建造者：创建产品的实例并且实现建造者多个方法对产品进行装配。 指挥者：有条不紊的按顺序调用建造者抽象类及其方法。 我们都知道计算机重装系统是一件很复杂的事情，首先你要备份重要数据、格式化硬盘，安装操作系统，然后再拷贝数据，安装驱动，安装常用软件，等等…，接下来我们就以重装计算机操作系统为例来体会一下Builder模式的作用。 我们需要一个类来说明安装后的系统要包含哪些东西，这个类就是我们要创建的产品类。 public class SysApplication { // 系统中的文件数据 private String data; // 操作系统 private String operationSystem; // 驱动 private String driver; // 包含哪些有用的软件 private String usefulSoftware; public String getData() { return data; } public void setData(String data) { this.data = data; } public String getOperationSystem() { return operationSystem; } public void setOperationSystem(String operationSystem) { this.operationSystem = operationSystem; } public String getDriver() { return driver; } public void setDriver(String driver) { this.driver = driver; } public String getUsefulSoftware() { return usefulSoftware; } public void setUsefulSoftware(String usefulSoftware) { this.usefulSoftware = usefulSoftware; } } 再创建一个ISysInstallBuilder接口把重装系统过程中我们要做的事情都罗列出来，这个接口就扮演了Builder模式中的建造者角色。 public interface ISysInstallBuilder { // 备份数据 public void backupdata(); // 格式化硬盘 public void formatDisk(); // 复制数据 public void copyData(); // 安装操作系统 public void installOperationSystem(); // 安装驱动 public void installDriver(); // 安装有用的软件 public void installUsefulSoftware(); // 获取安装好的系统 public SysApplication getSystemApplication(); } 接下来我们来实现安装Windows XP系统的具体建造者类WinXpInstallBuilder，以后需要安装Windows XP系统就用它。 public class WinXpInstallBuilder implements ISysInstallBuilder { private SysApplication systemApplication = new SysApplication(); @Override public void backupdata() { // 此处填写数据备份相关代码 System.out.println(&quot;备份数据&quot;); } @Override public void formatDisk() { // 此处填写硬盘格式化相关代码 System.out.println(&quot;格式化硬盘&quot;); } @Override public void copyData() { // 此处填写复制数据相关代码 System.out.println(&quot;复制数据&quot;); this.systemApplication.setData(&quot;原系统备份的数据&quot;); } @Override public void installOperationSystem() { // 此处填写安装Windows XP操作系统相关代码 System.out.println(&quot;安装Windows XP操作系统&quot;); this.systemApplication.setOperationSystem(&quot;Windows XP&quot;); } @Override public void installDriver() { // 此处填写安装Windows XP驱动相关代码 System.out.println(&quot;安装Windows XP驱动&quot;); this.systemApplication.setDriver(&quot;Windows XP驱动&quot;); } @Override public void installUsefulSoftware() { // 此处填写安装Windows XP操作系统下常用软件相关代码 System.out.println(&quot;安装Windows XP操作系统下常用软件&quot;); this.systemApplication.setUsefulSoftware(&quot;Windows XP操作系统下常用软件&quot;); } @Override public SysApplication getSystemApplication() { // 将安装好的系统返回 return this.systemApplication; } } 现在我们有了一个具体建造者类WinXpInstallBuilder，接下来我们尝试着用它来重装一下系统。 public class MainClass { public static void main(String[] args) { // 创建一个WinXpInstallBuilder ISysInstallBuilder builder = new WinXpInstallBuilder(); // 调用WinXpInstallBuilder，开始装系统了 builder.backupdata(); builder.copyData(); builder.formatDisk(); builder.installDriver(); builder.installOperationSystem(); builder.installUsefulSoftware(); // 获取到安装好的系统 SysApplication sysApplication = builder.getSystemApplication(); System.out.println(&quot;----------系统信息如下----------&quot;); System.out.println(&quot;数据：&quot; + sysApplication.getData()); System.out.println(&quot;驱动：&quot; + sysApplication.getDriver()); System.out.println(&quot;操作系统：&quot; + sysApplication.getOperationSystem()); System.out.println(&quot;软件：&quot; + sysApplication.getUsefulSoftware()); } } 运行程序打印结果如下： 备份数据复制数据格式化硬盘安装Windows XP驱动安装Windows XP操作系统安装Windows XP操作系统下常用软件———-系统信息如下———-数据：原系统备份的数据驱动：Windows XP驱动操作系统：Windows XP软件：Windows XP操作系统下常用软件 细心的你可能发现了，我安装的这个系统是有问题的，我把系统安装步骤的顺序搞乱了，复制数据应该放在格式化硬盘并安装好操作系统之后，安装驱动应该放在安装操作系统之后。由于安装系统的步骤比较复杂，虽然我已经很小心翼翼可还是把安装步骤给搞错了，怎样才能让系统按照正确的步骤安装而不会搞乱顺序呢？到了指挥者出场的时刻了。 public class SysInstallDirector { private ISysInstallBuilder builder; public SysInstallDirector(ISysInstallBuilder builder) { this.builder = builder; } public void installSystem() { builder.backupdata(); builder.formatDisk(); builder.installOperationSystem(); builder.installDriver(); builder.installUsefulSoftware(); builder.copyData(); } } 接下来我们再使用指挥者装一次系统试试。 public class Client{ public static void main(String[] args) { // 创建一个WinXpInstallBuilder ISysInstallBuilder builder = new WinXpInstallBuilder(); //创建一个指挥者 SysInstallDirector director = new SysInstallDirector(builder); //建造者在指挥者的指挥下开始安装系统了 director.installSystem(); // 从建造者手里获取到安装好的系统 SysApplication sysApplication = builder.getSystemApplication(); System.out.println(&quot;----------系统信息如下----------&quot;); System.out.println(&quot;数据：&quot; + sysApplication.getData()); System.out.println(&quot;驱动：&quot; + sysApplication.getDriver()); System.out.println(&quot;操作系统：&quot; + sysApplication.getOperationSystem()); System.out.println(&quot;软件：&quot; + sysApplication.getUsefulSoftware()); } } 运行程序打印结果如下： 数据备份硬盘格式化安装Windows XP操作系统安装Windows XP驱动安装Windows XP操作系统下常用软件复制数据———-系统信息如下———-数据：原系统备份的数据驱动：Windows XP驱动操作系统：Windows XP软件：Windows XP操作系统下常用软件 在有了指挥者的帮忙后，系统按照正确的顺序安装完成了。 接下来我们再实现一个安装Win7系统的具体建造者类Win7InstallBuilder。 public class Win7InstallBuilder implements ISysInstallBuilder { private SysApplication systemApplication = new SysApplication(); @Override public void backupdata() { // 此处填写数据备份相关代码 System.out.println(&quot;数据备份&quot;); } @Override public void formatDisk() { // 此处填写硬盘格式化相关代码 System.out.println(&quot;硬盘格式化&quot;); } @Override public void copyData() { // 此处填写复制数据相关代码 System.out.println(&quot;复制数据&quot;); this.systemApplication.setData(&quot;原系统备份的数据&quot;); } @Override public void installOperationSystem() { // 此处填写安装安装Win7操作系统相关代码 System.out.println(&quot;安装Win7操作系统&quot;); this.systemApplication.setOperationSystem(&quot;Win7&quot;); } @Override public void installDriver() { // 此处填写安装安装Win7驱动相关代码 System.out.println(&quot;安装Win7驱动&quot;); this.systemApplication.setDriver(&quot;Win7驱动&quot;); } @Override public void installUsefulSoftware() { // 此处填写安装安装Win7操作系统下常用软件相关代码 System.out.println(&quot;安装Win7操作系统下常用软件&quot;); this.systemApplication.setUsefulSoftware(&quot;Win7操作系统下常用软件&quot;); } @Override public SysApplication getSystemApplication() { // 将安装好的系统返回 return this.systemApplication; } } 在客户端中测试一下安装Win7系统。 public class Client{ public static void main(String[] args) { // 创建一个Win7InstallBuilder ISysInstallBuilder builder = new Win7InstallBuilder(); // 创建一个指挥者 SysInstallDirector director = new SysInstallDirector(builder); // 建造者在指挥者的指挥下开始安装系统了 director.installSystem(); // 从建造者手里获取到安装好的系统 SysApplication sysApplication = builder.getSystemApplication(); System.out.println(&quot;----------系统信息如下----------&quot;); System.out.println(&quot;数据：&quot; + sysApplication.getData()); System.out.println(&quot;驱动：&quot; + sysApplication.getDriver()); System.out.println(&quot;操作系统：&quot; + sysApplication.getOperationSystem()); System.out.println(&quot;软件：&quot; + sysApplication.getUsefulSoftware()); } } 运行程序打印结果如下： 数据备份硬盘格式化安装Win7操作系统安装Win7驱动安装Win7操作系统下常用软件复制数据———-系统信息如下———-数据：原系统备份的数据驱动：Win7驱动操作系统：Win7软件：Win7操作系统下常用软件 Win7系统也被正确安装，Builder模式通过指挥者和建造者将要创建的对象属性和属性的装配过程进行分离，一样的创建过程由于传入的具体建造者不同最终创建出了完全不同的对象，而且无需再担忧把组装顺序搞混了。 第二种：通过静态内部类实现复杂对象的无序构造。 创建一个个人信息类PersonalInfo，其中包含个人信息包括：电话号码，地址，姓名，年龄，性别，身份证号。 public class PersonalInfo { private String name; private int age; private String gender; private String address; private String iDNumber; private String phoneNumber; public String getPhoneNumber() { return phoneNumber; } public String getAddress() { return address; } public String getName() { return name; } public int getAge() { return age; } public String getGender() { return gender; } public String getIDNumber() { return iDNumber; } public static class Builder { private String name; private int age; private String gender; private String address; private String iDNumber; private String phoneNumber; public Builder(String name) { this.name = name; } public Builder phoneNumber(String phoneNumber) { this.phoneNumber = phoneNumber; return this; } public Builder address(String address) { this.address = address; return this; } public Builder age(int age) { this.age = age; return this; } public Builder gender(String gender) { this.gender = gender; return this; } public Builder iDNumber(String iDNumber) { this.iDNumber = iDNumber; return this; } public PersonalInfo build() { return new PersonalInfo(this); } } private PersonalInfo(Builder builder) { this.address = builder.address; this.age = builder.age; this.gender = builder.gender; this.iDNumber = builder.iDNumber; this.name = builder.name; this.phoneNumber = builder.phoneNumber; } } 在客户端中使用此类创建个人信息测试一下。 public class Client{ public static void main(String[] args) { PersonalInfo personalInfo = new PersonalInfo.Builder(&quot;姬如雪&quot;) .address(&quot;幻音坊&quot;).age(19).gender(&quot;女&quot;).build(); System.out.println(&quot;------------个人信息----------------&quot;); System.out.println(&quot;姓名：&quot;+personalInfo.getName()); System.out.println(&quot;住址：&quot;+personalInfo.getAddress()); System.out.println(&quot;年龄：&quot;+personalInfo.getAge()); System.out.println(&quot;性别：&quot;+personalInfo.getGender()); } } 运行程序打印结果如下： ————个人信息—————-姓名：姬如雪住址：幻音坊年龄：19性别：女 此种方式通过级联方式去创建对象，可自由控制创建对象的属性个数，减少了重复代码，使对象的创建更加形象直观。 三、建造者模式应用场景如果碰到以下情况，可以考虑使用建造者模式： 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。 当构造过程必须允许被构造的对象有不同的表示时。 创建的是一个复合对象：被创建的对象为一个具有复合属性的复合对象","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"建造者模式,Java,设计模式","slug":"建造者模式-Java-设计模式","permalink":"/tags/建造者模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--原型模式","slug":"Java设计模式之--原型模式","date":"2020-05-24T08:33:59.000Z","updated":"2023-04-30T10:21:41.356Z","comments":true,"path":"2020/05/24/Java设计模式之--原型模式/","link":"","permalink":"/2020/05/24/Java设计模式之--原型模式/","excerpt":"","text":"一、什么是原型模式原型（Prototype）模式是一种对象创建型模式，它通过原型实例指定创建对象的种类，并采用拷贝原型实例的方法来创建新的对象。所以，使用原型模式创建的实例，具有与原型实例一样的数据。 二、原型模式实现原型模式主要用于对象的复制，Prototype类需要具备以下两个条件()： 实现Cloneable接口。在java语言有一个Cloneable接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用clone方法。在java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。 重写Object类中的clone方法。Java中，所有类的父类都是Object类，Object类中有一个clone方法，作用是返回对象的一个拷贝，但是其作用域protected类型的，一般的类无法调用，因此，Prototype类需重写clone方法并将的方法的作用域修改为public类型。 原型模式是一种比较简单的模式，也非常容易理解，实现一个接口，重写一个方法即完成了原型模式。在实际应用中，原型模式很少单独出现，经常与其他模式混用，他的原型类Prototype也常用抽象类来替代。 原型模式的表现形式： 简单形式 登记形式 简单形式Prototype类为抽象时，示例代码如下。抽象原型角色：需实现Cloneable接口，并为子类提供公共方法。 public abstract class Prototype implements Cloneable { /** * 为子类提供一个复制方法 */ protected abstract Prototype clone(); /** * 以下两个方法为测试用，为每一个Prototype取上名字，方便区分 */ protected abstract String getName(); protected abstract void setName(String name); } 具体原型角色：需继承自抽象原型类，并实现父类的抽象方法。 public class ConcretePrototypeA extends Prototype { /** * 为ConcretePrototypeA的实例增加一个name属性，方便区分 */ protected String name; @Override public String getName() { return name; } @Override public void setName(String name) { this.name = name; } /** * 实现clone方法 */ @Override public Prototype clone() { Prototype prototype = new ConcretePrototypeA(); prototype.setName(this.name); System.out.println(&quot;ConcretePrototypeA创建完成！&quot;); return prototype; } } public class ConcretePrototypeB extends Prototype { /** * 为ConcretePrototypeA的实例增加一个name属性，方便区分 */ protected String name; @Override public String getName() { return name; } @Override public void setName(String name) { this.name = name; } /** * 实现clone方法 */ @Override protected Prototype clone() { Prototype prototype = new ConcretePrototypeB(); prototype.setName(this.name); System.out.println(&quot;ConcretePrototypeB创建完成！&quot;); return prototype; } } 创建一个客户端测试一下： public class Client{ public static void main(String[] args) { /** * 测试代码，首先创建好两个原型实例，以后创建新的Prototype对象就靠复制它了 */ Prototype prototypeA=null; Prototype prototypeB=null; /** * 为原型实例起个名字 */ prototypeA=new ConcretePrototypeA(); prototypeA.setName(&quot;A1&quot;); /** * 为原型实例起个名字 */ prototypeB=new ConcretePrototypeB(); prototypeB.setName(&quot;B1&quot;); /** * 复制实例 */ Prototype copyA=prototypeA.clone(); Prototype copyB=prototypeB.clone(); /** * 看看新复制的实例名字是否和原型一样 */ System.out.println(&quot;原型A的名字：&quot;+prototypeA.getName()); System.out.println(&quot;原型B的名字：&quot;+prototypeB.getName()); System.out.println(&quot;拷贝A的名字：&quot;+copyA.getName()); System.out.println(&quot;拷贝B的名字：&quot;+copyB.getName()); /** * 看看是不是真正的复制了一份 */ copyA.setName(&quot;备份A1&quot;); System.out.println(&quot;拷贝A的名字：&quot;+copyA.getName()); System.out.println(&quot;原型A的名字：&quot;+prototypeA.getName()); } } 运行程序打印结果如下： ConcretePrototypeA创建完成！ConcretePrototypeB创建完成！原型A的名字：A1原型B的名字：B1拷贝A的名字：A1拷贝B的名字：B1拷贝A的名字：备份A1原型A的名字：A1 由测试结果可以看出，在对拷贝A的name属性进行修改并未影响原型对象，拷贝A确实是复制而来的新对象。 使用原型模式创建对象无需关心这个实例本身的类型，只要它实现了clone方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。 登记形式该形式与简单形式的区别在于多增加了一个PrototypeManager(原型管理器)角色，该角色对要复制的原型对象进行登记管理，这个角色提供必要的方法供外界增加新的原型对象和取得已经登记过的原型对象。 该形式的抽象原型角色Prototype、具体原型角色ConcretePrototypeA、具体原型角色ConcretePrototypeB与简单形式完全相同。 原型管理器角色：此处以Map为容器对要复制的原型进行存储登记，PrototypeManager示例代码如下。 import java.util.HashMap; import java.util.Map; public class PrototypeManager { /** * 此处以Map为例，为每一个要复制的原型实例进行存储登记 */ private static Map&lt;String, Prototype&gt; map = new HashMap&lt;String, Prototype&gt;(); /** * 私有化构造方法，避免外部创建管理器 */ private PrototypeManager() { } /** * 向原型管理器里面登记原型对象或是修改某个原型对象登记信息 * * @param prototypeIndex * 原型索引 * @param prototype * 原型实例 */ public synchronized static void setPrototype(String prototypeIndex, Prototype prototype) { map.put(prototypeIndex, prototype); } /** * 从原型管理器里面删除某个登记好的原型对象 * * @param prototypeIndex * 原型索引 */ public synchronized static void removePrototype(String prototypeIndex) { map.remove(prototypeIndex); } /** * 获取某个原型索引对应的原型实例 * * @param prototypeIndex * 原型索引 * @return 原型索引对应的原型实例 * @throws Exception * 如果原型索引对应的实例不存在，则抛出异常 */ public synchronized static Prototype getPrototype(String prototypeIndex) throws Exception { Prototype prototype = map.get(prototypeIndex); if (prototype == null) { throw new Exception(&quot;该原型实例不存在！&quot;); } return prototype; } } 再创建一个客户端来测试一下： public class MainClass { public static void main(String[] args) throws Exception { /** * 测试代码，首先创建好两个原型实例，以后创建新的Prototype对象就靠复制它了 */ Prototype prototypeA = null; Prototype prototypeB = null; /** * 为原型实例起个名字 */ prototypeA = new ConcretePrototypeA(); prototypeA.setName(&quot;A&quot;); /** * 为原型实例起个名字 */ prototypeB = new ConcretePrototypeB(); prototypeB.setName(&quot;B&quot;); /** * 将创建好的原型实例在PrototypeManager中进行登记 */ PrototypeManager.setPrototype(&quot;A&quot;, prototypeA); PrototypeManager.setPrototype(&quot;B&quot;, prototypeB); /** * 使用PrototypeManager来对登记好的原型进行选择复制 我想要以 name 为 &quot;A&quot; 的原型为模板进行复制 */ Prototype copyA = PrototypeManager.getPrototype(&quot;A&quot;).clone(); /** * 使用PrototypeManager来对登记好的原型进行选择复制 我想要以 name 为 &quot;B&quot; 的原型为模板进行复制 */ Prototype copyB = PrototypeManager.getPrototype(&quot;B&quot;).clone(); /** * 看看新复制的实例名字是否和你想要的一样 */ System.out.println(&quot;原型A的名字：&quot; + prototypeA.getName()); System.out.println(&quot;原型B的名字：&quot; + prototypeB.getName()); System.out.println(&quot;拷贝A的名字：&quot; + copyA.getName()); System.out.println(&quot;拷贝B的名字：&quot; + copyB.getName()); /** * 看看是不是真正的复制了一份 */ copyA.setName(&quot;备份A1&quot;); System.out.println(&quot;拷贝A的名字：&quot; + copyA.getName()); System.out.println(&quot;原型A的名字：&quot; + prototypeA.getName()); } } 运行程序打印结果如下： ConcretePrototypeA创建完成！ConcretePrototypeB创建完成！原型A的名字：A原型B的名字：B拷贝A的名字：A拷贝B的名字：B拷贝A的名字：备份A1原型A的名字：A 使用登记形式原型模式在要复制的原型实例种类比较多而且要使用的原型实例经常变化的情况下比较方便，你只要写好原型实例并在原型管理器中登记好(起一个自己能够区分的名字作索引)，要复制哪个原型就从管理器直接获取。 三、Java中的深拷贝与浅拷贝(或深度克隆与浅度克隆)Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，但Object类的clone方法只会拷贝对象中的基本的数据类型，对于数组、容器对象、引用类型对象等都不会拷贝，这就是所谓浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。 注意事项: Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。 使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。 把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。 在Java语言里深度复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的拷贝）写到一个流里（序列化），再从流里读回来（反序列化），便可以重建对象。 利用序列化实现深度克隆：先创建一个Person类，该类需实现Serializable接口，为测试其是否为深拷贝为其添加一个List容器属性family，代码如下。 import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.Serializable; import java.util.List; @SuppressWarnings(&quot;serial&quot;) public class Person implements Serializable{ // 姓名 private String name; // 家庭成员 private List&lt;String&gt; family; public String getName() { return name; } public void setName(String name) { this.name = name; } public List&lt;String&gt; getFamily() { return family; } public void setFamily(List&lt;String&gt; family) { this.family = family; } public Person serializationClone() throws IOException, ClassNotFoundException { // 将对象写到流里 ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); // 从流里读回来 ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return (Person) ois.readObject(); } } 依旧创建一个客户端类来测试。 import java.util.ArrayList; import java.util.List; public class MainClass { public static void main(String[] args) throws Exception { /** * 创建一个原型实例对象，以后复制它 */ Person person = new Person(); /** * 为原型实例对象起个名字 */ person.setName(&quot;demo&quot;); /** * 给原型实例对象添加好家人，以测试serializationClone()方法是否对引用类型对象进行复制 */ List&lt;String&gt; family = new ArrayList&lt;String&gt;(); family.add(&quot;wife&quot;); family.add(&quot;child&quot;); person.setFamily(family); /** * 使用serializationClone()方法进行复制 */ Person copyPerson=person.serializationClone(); /** * 查看复制好的对象是否和原型实例相同 */ System.out.println(&quot;原型实例的名字:&quot;+person.getName()); System.out.println(&quot;原型实例的家人:&quot;+person.getFamily()); System.out.println(&quot;复制对象的名字:&quot;+copyPerson.getName()); System.out.println(&quot;复制对象的家人:&quot;+copyPerson.getFamily()); /** * 对复制好的对象属性进行修改，进一步测试该对象是否是真正的备份 */ copyPerson.setName(&quot;copy-demo&quot;); List&lt;String&gt; copyFamily = new ArrayList&lt;String&gt;(); copyFamily.add(&quot;copy-wife&quot;); copyFamily.add(&quot;copy-child&quot;); copyPerson.setFamily(copyFamily); /** * 打印修改后的复制对象和原型对象 */ System.out.println(&quot;复制对象修改后的名字:&quot;+copyPerson.getName()); System.out.println(&quot;复制对象修改后的家人:&quot;+copyPerson.getFamily()); System.out.println(&quot;原型实例的名字:&quot;+person.getName()); System.out.println(&quot;原型实例的家人:&quot;+person.getFamily()); } } 运行程序打印结果如下： 原型实例的名字:demo原型实例的家人:[wife, child]复制对象的名字:demo复制对象的家人:[wife, child]复制对象修改后的名字:copy-demo复制对象修改后的家人:[copy-wife, copy-child]原型实例的名字:demo原型实例的家人:[wife, child] 大功告成，person原型对象被完美深度复制了。 这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。 浅拷贝显然比深拷贝更容易实现，因为Java语言的所有类都会继承一个clone()方法，而这个clone()方法所做的正是浅拷贝。 有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用。 四、原型模式应用场景在以下情况可以考虑使用原型模式： 在创建对象的时候，我们不只是希望被创建的对象继承其基类的基本结构，还希望继承原型对象的数据。 希望对目标对象的修改不影响既有的原型对象（深度克隆的时候可以完全互不影响）。 隐藏克隆操作的细节。很多时候，对对象本身的克隆需要涉及到类本身的数据细节。 五、原型模式的特点 由原型对象自身创建目标对象。也就是说，对象创建这一动作发自原型对象本身。 目标对象是原型对象的一个克隆。也就是说，通过Prototype模式创建的对象，不仅仅与原型对象具有相同的结构，还与原型对象具有相同的值。 根据对象克隆深度层次的不同，有浅度克隆与深度克隆。 优点： 使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。 使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。 因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。 缺点： 原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。 参考文章http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html http://blog.csdn.net/jason0539/article/details/23158081","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"原型模式,Java,设计模式","slug":"原型模式-Java-设计模式","permalink":"/tags/原型模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--单例模式","slug":"Java设计模式之--单例模式","date":"2020-05-24T08:32:06.000Z","updated":"2023-04-30T10:21:41.355Z","comments":true,"path":"2020/05/24/Java设计模式之--单例模式/","link":"","permalink":"/2020/05/24/Java设计模式之--单例模式/","excerpt":"","text":"一、什么是单例模式单例（Singleton）模式是一种对象创建型模式，保证一个类只有一个实例存在，同时该类提供能对该实例加以访问的全局访问方法。 单例模式的本质：控制实例个数 设计意图：使用单例模式，可以保证为一个类只生成唯一的实例对象。也就是说，在整个程序空间中，该类只存在一个实例对象。 二、单例模式的应用场景如果碰到以下情况，可以考虑使用单例模式： 在多个线程之间，比如servlet环境，需共享同一个资源或者操作同一个对象。 在整个程序空间使用的全局变量，共享资源等。 大规模系统中，为了性能的考虑，需要节省对象的创建时间，等等…。 三、单例模式实现 饿汉式。 懒汉式。 双重检查。 饿汉式为保证单例类只能创建唯一实例需将该类的构造方法私有化以防止其他类通过构造方法显式创建单例类实例，另外单例类需对外提供一个公共的全局访问方法以使其他类可以通过该方法获取到单例类的唯一实例，饿汉式简单示例代码如下。 public class Singleton { private static Singleton singleton= new Singleton(); /** * 私有构造方法 */ private Singleton(){} /** * 静态的全局访问方法 */ public static Singleton getSingleton(){ return singleton; } } 在饿汉式中，在类加载时，静态变量singleton会调用类的私有构造方法进行初始化。这时候，单例类的唯一实例就被创建出来了。 饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。 懒汉式与饿汉式不同，懒汉式唯一实例采取了延迟实例化的方法，先不创建实例，等到需要用到实例的时候再创建。真的很懒，有木有？其代码示例如下。 public class Singleton { private static Singleton singleton = null; /** * 私有默认构造方法 */ private Singleton() { } /** * 静态的全局访问方法 */ public static Singleton getSingleton() { if (null == singleton) { singleton = new Singleton(); } return singleton; } } 懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费时间去判断。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。 上述懒汉式Singleton类在单线程中是安全的，但在多线程中存在隐患：首次运行 singleton=null 时，当有线程 A、B 需调用 getSingleton() 获取singleton实例时，线程A运行–&gt;进行判断if (null == singleton)*–&gt;进入if语句块中，还未来得及初始化此时线程A的运行时间突然结束，线程B开始运行，线程B也进行判断if (null == singleton)此时线程A还未对singleton完成初始化，singleton仍为null，线程B也进入if语句块中，线程B对singleton进行初始化并获取到singleton实例，在线程B结束运行之后线程A又被唤醒，线程A继续执行它之前未完成的singleton初始化工作，初始化完成后线程A也获得了singleton实例。在这种情况下线程A，B获取到的singleton实例就会指向两个不同的Singleton对象而不是同一实例。 既然上述懒汉式Singleton类在多线程中是不安全的，可以通过将getSingleton()方法同步化来解决，代码如下： public class Singleton { private static Singleton singleton = null; /** * 私有默认构造方法 */ private Singleton() { } /** * 静态的全局访问方法 */ public static synchronized Singleton getSingleton() { if (null == singleton) { singleton = new Singleton(); } return singleton; } } 这样Singleton类虽然解决了线程安全问题，可又带来了新的问题，由于getSingleton()方法被同步化，当多个线程同时需要获取singleton实例时只能一个一个线程排队执行，这样会降低整个访问的速度。 那么，有没有一种办法可以既可以实现懒汉式的延迟实例化，又线程安全且不会降低整个系统的访问速度呢？答案是：双重检查。 双重检查双重检查单例模式的产生是为了解决懒汉式单例模式同步化后系统执行效率慢的问题，其代码示例如下， public class Singleton { private volatile static Singleton singleton = null; /** * 私有默认构造方法 */ private Singleton() { } /** * 静态的全局访问方法 */ public static Singleton getSingleton() { //先检查实例是否已创建，如果未创建才进入同步块 if (null == singleton) { synchronized (Singleton.class) { //再次检查实例是否已创建，如果真的未创建才创建实例 if (null == singleton) { singleton = new Singleton(); } } } return singleton; } } 所谓的双重检查即：调用getSingleton()方法时先检查singleton实例是否已被创建，如果未创建才进入同步块，这是第一重检查，进入同步块之后再次检查确认singleton实例是否已被创建，如果真的未被创建才创建实例，这是第二重检查。这样一来，同步只在第一次调用getSingleton()方法singleton==null时进行，之后每次获取实例都无需进行同步判断，减少了同步判断浪费的时间。 “双重检查”机制的实现使用了关键字volatile，它的意思是：被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。 四、单例模式的特点 单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须向整个系统提供对该实例加以访问的全局访问方法。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"单例模式,Java,设计模式","slug":"单例模式-Java-设计模式","permalink":"/tags/单例模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--抽象工厂模式","slug":"Java设计模式之--抽象工厂模式","date":"2020-05-24T08:25:42.000Z","updated":"2023-04-30T10:21:41.358Z","comments":true,"path":"2020/05/24/Java设计模式之--抽象工厂模式/","link":"","permalink":"/2020/05/24/Java设计模式之--抽象工厂模式/","excerpt":"","text":"一、什么是抽象工厂模式抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的。抽象工厂模式可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，能够创建多个产品族的产品对象。 此处引入了一个新的概念产品族，那什么是产品族呢？百度一下：产品族是以产品平台为基础，通过添加不同的个性模块，以满足不同客户个性化需求的一组相关产品。 所谓产品族通俗来说即是：具有某一共性的一系列相关产品.以前面的Apple(苹果),Banana(香蕉),Pear(梨)为例，Apple(苹果),Banana(香蕉),Pear(梨)这三种水果对应上图中的产品等级结构。 这三种水果有产自南方的，也有产自北方的，北方和南方则对应上图中的产品族，产自北方的Apple(苹果),Banana(香蕉),Pear(梨)就构成一个产品族，它们的共性是产自北方，同样产自南方的Apple(苹果),Banana(香蕉),Pear(梨)也构成了一个产品族。 二、模式中包含的角色及其职责 抽象工厂（Factory）角色：抽象工厂模式的核心，包含对多个产品等级结构的声明，任何工厂类都必须实现这个接口。 具体工厂（ConcreteFactory）角色：具体工厂类是抽象工厂的一个实现，负责实例化某个产品族中的产品对象。 抽象（Product）角色：抽象模式所创建的所有对象的父类，或声明所有具体产品所共有的公共接口。 具体产品（ConcreteProduct）角色：抽象工厂模式所创建的真正实例。 总结：抽象工厂中的方法对应产品等级结构，具体工厂对应产品族。 接下来用代码进行说明：保留之前工厂方法模式中的Fruit接口，用来负责描述所有水果实例应该共有的方法。 public interface Fruit { /* * 采集 */ public void get(); } 此时Apple(苹果)和Banana(香蕉)将不再是具体的产品类而是抽象类，因为它们还需要进一步划分北方和南方两个产品族。 public abstract class Apple implements Fruit{ /* * 采集 */ public abstract void get(); } public abstract class Banana implements Fruit{ /* * 采集 */ public abstract void get(); } 再进一步细分，苹果（Apple）被具体化为北方苹果(NorthApple)和南方苹果(SouthApple)。 public class NorthApple extends Apple { public void get() { System.out.println(&quot;采集北方苹果&quot;); } } public class SouthApple extends Apple { public void get() { System.out.println(&quot;采集南方苹果&quot;); } } 香蕉(Banana)被具体化为北方香蕉(NorthBanana)和南方香蕉(SouthBanana). public class NorthBanana extends Banana { public void get() { System.out.println(&quot;采集北方香蕉&quot;); } } public class SouthBanana extends Banana { public void get() { System.out.println(&quot;采集南方香蕉&quot;); } } 继续写工厂，与之前的FruitFactory有所不同，此时的FruitFactory需为每一个产品等级结构添加获取方法声明。 public interface FruitFactory { //实例化Apple public Fruit getApple(); //实例化Banana public Fruit getBanana(); } 为每一个产品族添加相应的工厂，NorthFruitFactory负责生产所有北方的水果，SouthFruitFactory负责生产所有南方的水果。 public class NorthFruitFactory implements FruitFactory { public Fruit getApple() { return new NorthApple(); } public Fruit getBanana() { return new NorthBanana(); } } public class SouthFruitFactory implements FruitFactory { public Fruit getApple() { return new SouthApple(); } public Fruit getBanana() { return new SouthBanana(); } } 在客户端中进行测试，代码如下。 public class Client { public static void main(String[] args) { FruitFactory ff1 = new NorthFruitFactory(); Fruit apple1 = ff1.getApple(); apple1.get(); Fruit banana1 = ff1.getBanana(); banana1.get(); FruitFactory ff2 = new SouthFruitFactory(); Fruit apple2 = ff2.getApple(); apple2.get(); Fruit banana2 = ff2.getBanana(); banana2.get(); } } 运行程序打印结果如下： 采集北方苹果采集北方香蕉采集南方苹果采集南方香蕉 三、抽象工厂模式的优缺点抽象工厂模式有以下优点： 抽象工厂模式隔离了具体产品类的生产，使得客户并不需要知道即将创建的对象的具体类型。 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。 抽象工厂模式有以下缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。 优点代码举例：需求更改需要增加温室产品族。 先增加温室苹果和温室香蕉两个类。 public class WenshiApple extends Apple { public void get() { System.out.println(&quot;采集温室苹果&quot;); } } public class WenshiBanana extends Banana { public void get() { System.out.println(&quot;采集温室香蕉&quot;); } } 再增加生产温室水果的温室工厂。 public class WenshiFruitFactory implements FruitFactory { public Fruit getApple() { return new WenshiApple(); } public Fruit getBanana() { return new WenshiBanana(); } } 在客户端中测试一下，创建温室水果测试。 public class Client{ public static void main(String[] args) { FruitFactory ff3 = new WenshiFruitFactory(); Fruit apple3 = ff3.getApple(); apple3.get(); Fruit banana3 = ff3.getBanana(); banana3.get(); } } 运行程序打印结果如下： 采集温室苹果采集温室香蕉 产自温室的苹果和香蕉被正确创建，只是增加了新产品族的具体产品类和负责生产该产品族所有产品的工厂，无需对现有代码进行修改，很好的符合“开闭原则”。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"工厂模式,Java,设计模式","slug":"工厂模式-Java-设计模式","permalink":"/tags/工厂模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"10分钟掌握Markdown","slug":"10分钟掌握Markdown","date":"2020-05-24T03:56:03.000Z","updated":"2023-04-30T10:21:41.340Z","comments":true,"path":"2020/05/24/10分钟掌握Markdown/","link":"","permalink":"/2020/05/24/10分钟掌握Markdown/","excerpt":"","text":"前言&emsp;&emsp;写过博客或者github上面的文档的，应该知道Markdown语法的重要性，不知道的朋友们也别着急，一篇博客带你轻松搞定Markdown语法。 快捷键 功能 快捷键 加粗 Ctrl + B 斜体 Ctrl + I 引用 Ctrl + Q 插入链接 Ctrl + L 插入代码 Ctrl + K 插入图片 Ctrl + G 提升标题 Ctrl + H 有序列表 Ctrl + O 无序列表 Ctrl + U 横线 Ctrl + R 撤销 Ctrl + Z 重做 Ctrl + Y 常用语法文本 示例 效果 正常文字 正常文字 *斜体文字* 斜体文字 _斜体文字_ 斜体文字 **粗体文字** 粗体文字 ***斜体加粗*** 斜体加粗 标题&emsp;&emsp;一级标题：# 一级标题&emsp;&emsp;二级标题：## 二级标题&emsp;&emsp;三级标题：### 三级标题&emsp;&emsp;四级标题：#### 四级标题&emsp;&emsp;五级标题：##### 五级标题&emsp;&emsp;六级标题：###### 六级标题 链接 示例 效果 [CSDN](https://www.csdn.net/ &quot;CSDN技术论坛&quot;) CSDN [CSDN][csdn-addr][csdn-addr]:https://www.csdn.net/ &quot;CSDN技术论坛&quot; CSDN &lt;https://www.csdn.net/&gt; https://www.csdn.net/ 图片&emsp;&emsp;示例1:![CSDN头像](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &quot;我的头像&quot;)&emsp;&emsp;或者：![CSDN头像][csdn-image][csdn-image]:https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &quot;我的头像&quot;&emsp;&emsp;效果： &emsp;&emsp;示例2：调整大小&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw&quot; width=&quot;100px&quot; height=&quot;100px&quot; /&gt;&emsp;&emsp;示例3：居中&lt;div align=center&gt;![CSDN头像](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9hdmF0YXIuY3Nkbi5uZXQvNy83L0IvMV9yYWxmX2h4MTYzY29tLmpwZw &quot;我的头像&quot;) &emsp;&emsp;示例4：引用本地图片![CSDN头像](./imgs/csdn.jpg &quot;我的头像&quot;) 分割线&emsp;&emsp;在一行中使用 *** 或者 --- 或者 ___ 都可以插入一个分割线，行内不允许有其他内容。 代码块&emsp;&emsp;行内代码块（使用ESC键上的英文字符 ` 包裹代码）： `var foo = &#39;bar&#39;;` 代码块（缩进 4 个空格或是 1 个制表符）： &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 多行代码块（使用连续3个ESC键上的英文字符 ` 包裹代码）： ``` &lt;table&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小明&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; ``` 引用&emsp;&emsp;单层引用：在被引用的文本前加上 &gt; 符号，例如：&gt; 语出《论语》 语出《论语》 &emsp;&emsp;嵌套引用： &gt; #引用1 &gt;&gt; ##引用2 列表&emsp;&emsp;无序列表（使用 *，+，- 表示）: + 1. item1 - 2. item2 * 3. item3 &emsp;&emsp;效果： item1 item2 item3 &emsp;&emsp;有序列表（使用数字紧跟一个英文句点表示）： 1. item1 2. item2 3. item3 item1 item2 item3 &emsp;&emsp;无序列表和有序列表的列表序号和列表内容之间必须有一个空格。 表格| Column 1 | Column 2 |Column 2 | |:--------:| -------------:|:-------------| | centered 文本居中 | right-aligned 文本居右 | left-aligned 文本居左 | &emsp;&emsp;示例： |项目 | Value | |:--------|:--------| |电脑 | $1600 | |手机 | $12 | |导管 | $1 | &emsp;&emsp;效果： 项目 Value 电脑 $1600 手机 $12 导管 $1 常用技巧换行 连续两个以上空格+回车 使用html语言换行标签：&lt;br/&gt; 缩进 &amp;nbsp;：缩进1/4中文字符 &amp;ensp;：缩进1/2中文字符,1英文字符 &amp;emsp;：缩进1中文字符,2英文字符","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"/tags/Markdown/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Java设计模式系列之--工厂方法模式","slug":"Java设计模式之--工厂方法模式","date":"2020-05-24T03:56:03.000Z","updated":"2023-04-30T10:21:41.357Z","comments":true,"path":"2020/05/24/Java设计模式之--工厂方法模式/","link":"","permalink":"/2020/05/24/Java设计模式之--工厂方法模式/","excerpt":"","text":"一、什么是工厂方法模式工厂方法模式同样属于类的创建型模式又被称为多态工厂模式 。工厂方法模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责声明具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。 二、模式中包含的角色及其职责抽象工厂（Factory）角色：工厂方法模式的核心，所有具体工厂类都必须实现这个接口。 具体工厂（ ConcreteFactory）角色：具体工厂类是抽象工厂的一个实现，负责实例化具体的产品。 抽象产品（Product）角色：工厂方法模式所创建的所有具体产品的父类，或约定所有具体产品类都应实现的公共接口。 具体产品（ConcreteProduct）角色：工厂方法模式所创建的真正对象。 在简单工厂模式中我们了解了简单工厂模式，我们使用如下具体的工厂FruitFactory对所有的水果对象进行实例化，缺点是显而易见的：当有新品种的水果需要产生时就需要修改工厂的getFruit()方法，加入新品种水果的逻辑判断和业务代码，这极不符合java“开放–封闭”原则。 public class FruitFactory { /* * get方法，获得所有产品对象 */ public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException, ClassNotFoundException { if(type.equalsIgnoreCase(&quot;apple&quot;)) { return Apple.class.newInstance(); } else if(type.equalsIgnoreCase(&quot;banana&quot;)) { return Banana.class.newInstance(); } /* * 如果有新品种的水果需要生产需在此处增加相应逻辑判断及业务代码，例如： * else if(type.equalsIgnoreCase(&quot;pear&quot;)) { * return Pear.class.newInstance(); * } */ else { System.out.println(&quot;找不到相应的实例化类&quot;); return null; } } } 接下来我们使用工厂方法模式对以上工厂进行改进，首先工厂方法模式中FruitFactory被设计为了抽象工厂(可以是抽象类或者接口),它不再负责具体的产品创建，而是将产品的创建工作推迟到了由它的子类来实现，接下来以具体的代码为例。 抽象后的FruitFactory仅用来声明其所有子类需实现的接口。 public interface FruitFactory { public Fruit getFruit(); } 有了这个抽象工厂以后，假如我们需要苹果了该怎么办？很简单，创建一个生产苹果的工厂AppleFactory即可。 public class AppleFactory implements FruitFactory{ public Fruit getFruit(){ return new Apple(); } } 假如我们又需要获取香蕉了该怎么办？依旧简单，创建一个生产香蕉的工厂BananaFactory即可。 public class BananaFactory implements FruitFactory{ public Fruit getFruit(){ return new Banana(); } } 如果以后还有其他更多新品种的水果加入，只需要创建一个生产相应水果的工厂并让该工厂实现抽象工厂FruitFactory 的接口，需要哪种水果我们就调用相应工厂的getFruit()方法得到水果，这样做有一个好处，无论我们增加多少种水果，我们只需增加一个生产相应水果的工厂即可，无需对现有的代码进行修改，这就很好的符合了”开放–封闭”原则。 三、工厂方法模式和简单工厂模式比较工厂方法模式与简单工厂模式在结构上的不同不是很明显。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。 工厂方法模式之所以有一个别名叫多态性工厂模式是因为具体工厂类都有共同的接口，或者有共同的抽象父类。当系统扩展需要添加新的产品对象时，仅仅需要添加一个具体对象以及一个具体工厂对象，原有工厂对象不需要进行任何修改，也不需要修改客户端，很好的符合了“开放－封闭”原则。而简单工厂模式在添加新产品对象后不得不修改工厂方法，扩展性不好。 工厂方法模式退化后可以演变成简单工厂模式。","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"工厂模式,Java,设计模式","slug":"工厂模式-Java-设计模式","permalink":"/tags/工厂模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"Java设计模式系列之--简单工厂模式","slug":"Java设计模式之--简单工厂模式","date":"2020-05-24T03:56:03.000Z","updated":"2023-04-30T10:21:41.359Z","comments":true,"path":"2020/05/24/Java设计模式之--简单工厂模式/","link":"","permalink":"/2020/05/24/Java设计模式之--简单工厂模式/","excerpt":"","text":"一、什么是简单工厂模式简单工厂模式属于类的创建型模式。提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类。 简单工厂模式的本质：选择实现 设计意图： 通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 二、简单工厂模式的结构简单工厂模式涉及的角色及其职责如下： 工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑，该类可以被外界直接调用，创建所需的产品对象。 抽象（Product）角色：简单工厂模式所创建的所有对象的父类，它负责约定所有具体产品类所共有的公共接口。 具体产品（ConcreteProduct）角色：简单工厂模式所创建的真正实例对象。 以具体代码为例：现在有两种水果：苹果(Apple)和香蕉(Banana)，为了演示，为这两种水果添加一个采集get()方法。 public class Apple{ /* * 采集 */ public void get(){ System.out.println(&quot;采集苹果&quot;); } } public class Banana{ /* * 采集 */ public void get(){ System.out.println(&quot;采集香蕉&quot;); } } 如果要采集水果，在不使用任何设计模式的情况下，我们一般都会这样做。 public class Client { public static void main(String[] args){ //实例化一个Apple Apple apple = new Apple(); //实例化一个Banana Banana banana = new Banana(); apple.get(); banana.get(); } } 客户端分别创建苹果和香蕉两个具体产品的实例并调用其采集的方法，这样做存在的问题是：客户端需要知道所有的具体水果种类，即客户端与所有的水果类都存在了耦合关系，不符合面向对象设计中的“低耦合”原则。 以上问题如何解决呢？答案：使用简单工厂，利用接口进行“封装隔离”。 Apple和Banana类既然都是水果，且共有一个采集的get()方法，我们可以为其添加一个父类或让其实现一个共同的接口。在此，我们添加一个Fruit接口。 public interface Fruit { /* * 采集 */ public void get(); } 让Apple和Banana类都实现Fruit接口。 public class Apple implements Fruit{ /* * 采集 */ public void get(){ System.out.println(&quot;采集苹果&quot;); } } public class Banana implements Fruit{ /* * 采集 */ public void get(){ System.out.println(&quot;采集香蕉&quot;); } } 接下来创建一个水果工厂类FruitFactory，在工厂中实现对Apple和Banana类的实例化。 public class FruitFactory { /* * 获得Apple类的实例 */ public static Fruit getApple(){ return new Apple(); } /* * 获得Banana类实例 */ public static Fruit getBanana(){ return new Banana(); } } 若FruitFactory中getXXX()方法未声明为static的话，每次调用方法需创建FruitFactory实例比较麻烦，我们直接声明方法为static。 这样，我们就能够使用FruitFactory创建Apple和Banana实例对象了。 public class Client{ public static void main(String[] args){ //实例化一个Apple Fruit apple = FruitFactory.getApple(); Fruit banana = FruitFactory.getBanana(); apple.get(); banana.get(); } } 观察以上工厂，其为每一个水果具体类都添加了一个getXXX()方法，当水果种类增多时方法数量也会增加导致FruitFactory类比较臃肿，而且各个方法之间关系也不够紧密不符合“高内聚”原则，我们再对其进行优化。 public class FruitFactory { /* * getFruit方法，获得所有产品对象 */ public static Fruit getFruit(String type) throws InstantiationException, IllegalAccessException{ if(type.equalsIgnoreCase(&quot;apple&quot;)) { return Apple.class.newInstance(); } elseif(type.equalsIgnoreCase(&quot;banana&quot;)) { return Banana.class.newInstance(); } else{ System.out.println(&quot;找不到相应的实例化类&quot;); return null; } } } 在客户端，使用改良后的FruitFactory来创建Apple和Banana实例对象。 public class Client{ public static void main(String[] args){ Fruit apple = FruitFactory.getFruit(&quot;apple&quot;); Fruit banana = FruitFactory.getFruit(&quot;banana&quot;); apple.get(); banana.get(); } } 运行程序打印结果如下： 采集苹果采集香蕉 三、简单工厂模式的优缺点在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。不难发现，简单工厂模式的缺点也正体现在其工厂类上，由于工厂类集中了所有实例的创建逻辑，所以“高内聚”方面做的并不好。另外，当系统中的具体产品类不断增多时，可能会出现要求工厂类也要做相应的修改，扩展性并不很好。例如新增一个Pear(梨)类时，FruitFactory需在getFruit()方法中增加type==”Pear”的逻辑判断，此时不符合开闭原则。 FruitFactory可通过反射来解决扩展性和高内聚缺陷，代码如下。 public class FruitFactory{ /* * getFruit方法，获得所有产品对象 */ public static Fruit getFruit(String type)throws ClassNotFoundException, InstantiationException,IllegalAccessException { Class fruit = Class.forName(type); return (Fruit) fruit.newInstance(); } } 客户端使用FruitFactory创建Apple和Banana实例对象，此时getFruit()方法传入的参数需注意区分大小写，否则会抛出ClassNotFoundException异常，写法呆板，但可以解决扩展性和高内聚缺陷。 public class Client{ public static void main(String[] args){ Fruit apple = FruitFactory.getFruit(&quot;Apple&quot;); Fruit banana = FruitFactory.getFruit(&quot;Banana&quot;); apple.get(); banana.get(); } }","categories":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}],"tags":[{"name":"工厂模式,Java,设计模式","slug":"工厂模式-Java-设计模式","permalink":"/tags/工厂模式-Java-设计模式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"/categories/编程/"}]},{"title":"hexo-theme-sakura主题使用说明","slug":"Hexo-Theme-Sakura","date":"2020-05-20T03:56:03.000Z","updated":"2023-04-30T10:21:41.340Z","comments":true,"path":"2020/05/20/Hexo-Theme-Sakura/","link":"","permalink":"/2020/05/20/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"主题,樱花","slug":"主题-樱花","permalink":"/tags/主题-樱花/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Hexo快速入门","slug":"hello-world","date":"2020-05-20T03:56:03.000Z","updated":"2023-04-30T10:21:41.368Z","comments":true,"path":"2020/05/20/hello-world/","link":"","permalink":"/2020/05/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"/tags/Hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}